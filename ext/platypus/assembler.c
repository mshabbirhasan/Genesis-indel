/* Generated by Cython 0.20.1 on Mon Sep 15 11:17:47 2014 */

#define PY_SSIZE_T_CLEAN
#ifndef CYTHON_USE_PYLONG_INTERNALS
#ifdef PYLONG_BITS_IN_DIGIT
#define CYTHON_USE_PYLONG_INTERNALS 0
#else
#include "pyconfig.h"
#ifdef PYLONG_BITS_IN_DIGIT
#define CYTHON_USE_PYLONG_INTERNALS 1
#else
#define CYTHON_USE_PYLONG_INTERNALS 0
#endif
#endif
#endif
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02040000
    #error Cython requires Python 2.4+.
#else
#define CYTHON_ABI "0_20_1"
#include <stddef.h> /* For offsetof */
#ifndef offsetof
#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
#define CYTHON_COMPILING_IN_PYPY 1
#define CYTHON_COMPILING_IN_CPYTHON 0
#else
#define CYTHON_COMPILING_IN_PYPY 0
#define CYTHON_COMPILING_IN_CPYTHON 1
#endif
#if CYTHON_COMPILING_IN_PYPY
#define Py_OptimizeFlag 0
#endif
#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PY_FORMAT_SIZE_T ""
  #define CYTHON_FORMAT_SSIZE_T ""
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_As_int(o)
  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
                                (PyErr_Format(PyExc_TypeError, \
                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
                                 (PyObject*)0))
  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
                                  !PyComplex_Check(o))
  #define PyIndex_Check __Pyx_PyIndex_Check
  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
  #define __PYX_BUILD_PY_SSIZE_T "i"
#else
  #define __PYX_BUILD_PY_SSIZE_T "n"
  #define CYTHON_FORMAT_SSIZE_T "z"
  #define __Pyx_PyIndex_Check PyIndex_Check
#endif
#if PY_VERSION_HEX < 0x02060000
  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
  #define PyVarObject_HEAD_INIT(type, size) \
          PyObject_HEAD_INIT(type) size,
  #define PyType_Modified(t)
  typedef struct {
     void *buf;
     PyObject *obj;
     Py_ssize_t len;
     Py_ssize_t itemsize;
     int readonly;
     int ndim;
     char *format;
     Py_ssize_t *shape;
     Py_ssize_t *strides;
     Py_ssize_t *suboffsets;
     void *internal;
  } Py_buffer;
  #define PyBUF_SIMPLE 0
  #define PyBUF_WRITABLE 0x0001
  #define PyBUF_FORMAT 0x0004
  #define PyBUF_ND 0x0008
  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
#endif
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyType_Type
#endif
#if PY_VERSION_HEX < 0x02060000
  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
#endif
#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_CHECKTYPES 0
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#if PY_VERSION_HEX < 0x02060000
  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
#endif
#if PY_VERSION_HEX < 0x02060000 && !defined(Py_TPFLAGS_IS_ABSTRACT)
  #define Py_TPFLAGS_IS_ABSTRACT 0
#endif
#if PY_VERSION_HEX < 0x030400a1 && !defined(Py_TPFLAGS_HAVE_FINALIZE)
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
#else
  #define CYTHON_PEP393_ENABLED 0
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ? \
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#define __Pyx_PyString_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_VERSION_HEX < 0x02060000
  #define PyBytesObject                PyStringObject
  #define PyBytes_Type                 PyString_Type
  #define PyBytes_Check                PyString_Check
  #define PyBytes_CheckExact           PyString_CheckExact
  #define PyBytes_FromString           PyString_FromString
  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
  #define PyBytes_FromFormat           PyString_FromFormat
  #define PyBytes_DecodeEscape         PyString_DecodeEscape
  #define PyBytes_AsString             PyString_AsString
  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
  #define PyBytes_Size                 PyString_Size
  #define PyBytes_AS_STRING            PyString_AS_STRING
  #define PyBytes_GET_SIZE             PyString_GET_SIZE
  #define PyBytes_Repr                 PyString_Repr
  #define PyBytes_Concat               PyString_Concat
  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
                                         PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#if PY_VERSION_HEX < 0x02060000
  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
#else
  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#endif
#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
#else
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
#endif
#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_NAMESTR(n) ((char *)(n))
  #define __Pyx_DOCSTR(n)  ((char *)(n))
#else
  #define __Pyx_NAMESTR(n) (n)
  #define __Pyx_DOCSTR(n)  (n)
#endif
#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
   a quiet NaN. */
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif


#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
#define _USE_MATH_DEFINES
#endif
#include <math.h>
#define __PYX_HAVE__assembler
#define __PYX_HAVE_API__assembler
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "ctype.h"
#include "unistd.h"
#include "razf.h"
#include "stdint.h"
#include "bam.h"
#include "sam.h"
#include "pysam_util.h"
#include "math.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (    \
    (sizeof(type) < sizeof(Py_ssize_t))  ||             \
    (sizeof(type) > sizeof(Py_ssize_t) &&               \
          likely(v < (type)PY_SSIZE_T_MAX ||            \
                 v == (type)PY_SSIZE_T_MAX)  &&         \
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||       \
                                v == (type)PY_SSIZE_T_MIN)))  ||  \
    (sizeof(type) == sizeof(Py_ssize_t) &&              \
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||        \
                               v == (type)PY_SSIZE_T_MAX)))  )
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyObject_AsSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
#define __Pyx_PyByteArray_FromUString(s)   __Pyx_PyByteArray_FromString((char*)s)
#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
#if PY_MAJOR_VERSION < 3
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
{
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return u_end - u - 1;
}
#else
#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
#endif
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_COMPILING_IN_CPYTHON
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys = NULL;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    sys = PyImport_ImportModule("sys");
    if (sys == NULL) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    if (default_encoding == NULL) goto bad;
    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (ascii_chars_u == NULL) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
    }
    Py_XDECREF(sys);
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return 0;
bad:
    Py_XDECREF(sys);
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys = NULL;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (sys == NULL) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    if (default_encoding == NULL) goto bad;
    default_encoding_c = PyBytes_AS_STRING(default_encoding);
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(sys);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(sys);
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


#ifdef __GNUC__
  /* Test for GCC > 2.95 */
  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
    #define likely(x)   __builtin_expect(!!(x), 1)
    #define unlikely(x) __builtin_expect(!!(x), 0)
  #else /* __GNUC__ > 2 ... */
    #define likely(x)   (x)
    #define unlikely(x) (x)
  #endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */

static PyObject *__pyx_m;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "assembler.pyx",
  "samtoolsWrapper.pxd",
  "fastafile.pxd",
  "cwindow.pxd",
  "variant.pxd",
};

/*--- Type declarations ---*/
struct __pyx_obj_15samtoolsWrapper_IteratorRow;
struct __pyx_obj_15samtoolsWrapper_Samfile;
struct __pyx_obj_9fastafile_FastaIndex;
struct __pyx_obj_9fastafile_FastaFile;
struct __pyx_obj_7cwindow_ReadArray;
struct __pyx_obj_7cwindow_bamReadBuffer;
struct __pyx_obj_7variant_Variant;
struct __pyx_obj_7variant_VariantCandidateGenerator;
struct __pyx_opt_args_15samtoolsWrapper_7Samfile__open;
struct __pyx_opt_args_15samtoolsWrapper_7Samfile__parseRegion;
struct __pyx_t_15samtoolsWrapper_cAlignedRead;
typedef struct __pyx_t_15samtoolsWrapper_cAlignedRead __pyx_t_15samtoolsWrapper_cAlignedRead;

/* "samtoolsWrapper.pxd":248
 *     cdef int _isOpen( self )
 *     cdef _hasIndex( self )
 *     cpdef _open(self, mode, loadIndex=*)             # <<<<<<<<<<<<<<
 *     cdef char* getrname(self, int tid)
 *     cdef _parseRegion(self, reference=*, start=*, end=*, region=*)
 */
struct __pyx_opt_args_15samtoolsWrapper_7Samfile__open {
  int __pyx_n;
  PyObject *loadIndex;
};

/* "samtoolsWrapper.pxd":250
 *     cpdef _open(self, mode, loadIndex=*)
 *     cdef char* getrname(self, int tid)
 *     cdef _parseRegion(self, reference=*, start=*, end=*, region=*)             # <<<<<<<<<<<<<<
 *     cpdef IteratorRow fetch(self, char* reference, int start, int end)
 *     cpdef close(self)
 */
struct __pyx_opt_args_15samtoolsWrapper_7Samfile__parseRegion {
  int __pyx_n;
  PyObject *reference;
  PyObject *start;
  PyObject *end;
  PyObject *region;
};

/* "samtoolsWrapper.pxd":259
 * ###################################################################################################
 * 
 * ctypedef struct cAlignedRead:             # <<<<<<<<<<<<<<
 *     char* seq
 *     char* qual
 */
struct __pyx_t_15samtoolsWrapper_cAlignedRead {
  char *seq;
  char *qual;
  short *cigarOps;
  short *hash;
  short mateChromID;
  short cigarLen;
  short chromID;
  short rlen;
  int pos;
  int end;
  int insertSize;
  int matePos;
  int bitFlag;
  char mapq;
};
struct __pyx_t_9assembler_Node;
typedef struct __pyx_t_9assembler_Node __pyx_t_9assembler_Node;
struct __pyx_t_9assembler_NodeStack;
typedef struct __pyx_t_9assembler_NodeStack __pyx_t_9assembler_NodeStack;
struct __pyx_t_9assembler_Edge;
typedef struct __pyx_t_9assembler_Edge __pyx_t_9assembler_Edge;
struct __pyx_t_9assembler_EdgeStack;
typedef struct __pyx_t_9assembler_EdgeStack __pyx_t_9assembler_EdgeStack;
struct __pyx_t_9assembler_NodeDict;
typedef struct __pyx_t_9assembler_NodeDict __pyx_t_9assembler_NodeDict;
struct __pyx_t_9assembler_Path;
typedef struct __pyx_t_9assembler_Path __pyx_t_9assembler_Path;
struct __pyx_t_9assembler_PathStack;
typedef struct __pyx_t_9assembler_PathStack __pyx_t_9assembler_PathStack;
struct __pyx_t_9assembler_DeBruijnGraph;
typedef struct __pyx_t_9assembler_DeBruijnGraph __pyx_t_9assembler_DeBruijnGraph;

/* "assembler.pyx":73
 * 
 * # Represents a node in the graph
 * ctypedef struct Node:             # <<<<<<<<<<<<<<
 *     Edge* edges[4]
 *     char* sequence
 */
struct __pyx_t_9assembler_Node {
  __pyx_t_9assembler_Edge *edges[4];
  char *sequence;
  int colours;
  int position;
  int kmerSize;
  int nEdges;
  double weight;
  char dfsColour;
};

/* "assembler.pyx":84
 * 
 * # Simple implementation of a stack, for storing nodes.
 * ctypedef struct NodeStack:             # <<<<<<<<<<<<<<
 *     Node** elements
 *     int capacity
 */
struct __pyx_t_9assembler_NodeStack {
  __pyx_t_9assembler_Node **elements;
  int capacity;
  int top;
};

/* "assembler.pyx":69
 * 
 * # Forward declaration of Edge struct, so it can be referred to in Node.
 * ctypedef struct Edge             # <<<<<<<<<<<<<<
 * ctypedef struct EdgeStack
 * 
 */
struct __pyx_t_9assembler_Edge {
  __pyx_t_9assembler_Node *startNode;
  __pyx_t_9assembler_Node *endNode;
  double weight;
};

/* "assembler.pyx":70
 * # Forward declaration of Edge struct, so it can be referred to in Node.
 * ctypedef struct Edge
 * ctypedef struct EdgeStack             # <<<<<<<<<<<<<<
 * 
 * # Represents a node in the graph
 */
struct __pyx_t_9assembler_EdgeStack {
  __pyx_t_9assembler_Edge **elements;
  int capacity;
  int top;
};

/* "assembler.pyx":102
 * 
 * # A dictionary of Nodes
 * ctypedef struct NodeDict:             # <<<<<<<<<<<<<<
 *     Node*** buckets
 *     int* bucketSize
 */
struct __pyx_t_9assembler_NodeDict {
  __pyx_t_9assembler_Node ***buckets;
  int *bucketSize;
  int nBuckets;
};

/* "assembler.pyx":108
 * 
 * # Hold a path through the graph
 * ctypedef struct Path:             # <<<<<<<<<<<<<<
 *     NodeStack* nodes
 *     int nNodes
 */
struct __pyx_t_9assembler_Path {
  __pyx_t_9assembler_NodeStack *nodes;
  int nNodes;
  int isBubble;
  double weight;
};

/* "assembler.pyx":115
 * 
 * # A stack of paths
 * ctypedef struct PathStack:             # <<<<<<<<<<<<<<
 *     Path** elements
 *     int capacity
 */
struct __pyx_t_9assembler_PathStack {
  __pyx_t_9assembler_Path **elements;
  int capacity;
  int top;
};

/* "assembler.pyx":121
 * 
 * # A graph
 * ctypedef struct DeBruijnGraph:             # <<<<<<<<<<<<<<
 *     int kmerSize
 *     NodeStack* allNodes
 */
struct __pyx_t_9assembler_DeBruijnGraph {
  int kmerSize;
  __pyx_t_9assembler_NodeStack *allNodes;
  __pyx_t_9assembler_NodeDict *nodes;
};

/* "samtoolsWrapper.pxd":226
 * 
 * @cython.final
 * cdef class IteratorRow:             # <<<<<<<<<<<<<<
 *     cdef bam_fetch_iterator_t*  bam_iter # iterator state object
 *     cdef bam1_t* b
 */
struct __pyx_obj_15samtoolsWrapper_IteratorRow {
  PyObject_HEAD
  struct __pyx_vtabstruct_15samtoolsWrapper_IteratorRow *__pyx_vtab;
  bam_fetch_iterator_t *bam_iter;
  bam1_t *b;
  int useIndex;
};


/* "samtoolsWrapper.pxd":223
 * 
 * ###################################################################################################
 * cdef class Samfile             # <<<<<<<<<<<<<<
 * 
 * @cython.final
 */
struct __pyx_obj_15samtoolsWrapper_Samfile {
  PyObject_HEAD
  struct __pyx_vtabstruct_15samtoolsWrapper_Samfile *__pyx_vtab;
  char *filename;
  samfile_t *samfile;
  bam_index_t *index;
  int isbam;
  PyObject *indexesByRegion;
  PyObject *lock;
};


/* "fastafile.pxd":1
 * cdef class FastaIndex:             # <<<<<<<<<<<<<<
 *     cdef object theFile
 *     cdef dict getRefs(self, int parseNCBI)
 */
struct __pyx_obj_9fastafile_FastaIndex {
  PyObject_HEAD
  struct __pyx_vtabstruct_9fastafile_FastaIndex *__pyx_vtab;
  PyObject *theFile;
};


/* "fastafile.pxd":5
 *     cdef dict getRefs(self, int parseNCBI)
 * 
 * cdef class FastaFile(object):             # <<<<<<<<<<<<<<
 *     cdef object theFile
 *     cdef FastaIndex theIndex
 */
struct __pyx_obj_9fastafile_FastaFile {
  PyObject_HEAD
  struct __pyx_vtabstruct_9fastafile_FastaFile *__pyx_vtab;
  PyObject *theFile;
  struct __pyx_obj_9fastafile_FastaIndex *theIndex;
  PyObject *refs;
  PyObject *cache;
  PyObject *cacheRefName;
  PY_LONG_LONG cacheStartPos;
  PY_LONG_LONG cacheEndPos;
};


/* "cwindow.pxd":13
 * ###################################################################################################
 * 
 * cdef class ReadArray:             # <<<<<<<<<<<<<<
 *     cdef cAlignedRead** array
 *     cdef cAlignedRead** windowStart
 */
struct __pyx_obj_7cwindow_ReadArray {
  PyObject_HEAD
  struct __pyx_vtabstruct_7cwindow_ReadArray *__pyx_vtab;
  __pyx_t_15samtoolsWrapper_cAlignedRead **array;
  __pyx_t_15samtoolsWrapper_cAlignedRead **windowStart;
  __pyx_t_15samtoolsWrapper_cAlignedRead **windowEnd;
  int __pyx___size;
  int __pyx___capacity;
  int __pyx___longestRead;
};


/* "cwindow.pxd":29
 * ###################################################################################################
 * 
 * cdef class bamReadBuffer:             # <<<<<<<<<<<<<<
 *     cdef char* chrom
 *     cdef int chromID
 */
struct __pyx_obj_7cwindow_bamReadBuffer {
  PyObject_HEAD
  struct __pyx_vtabstruct_7cwindow_bamReadBuffer *__pyx_vtab;
  char *chrom;
  int chromID;
  int *filteredReadCountsByType;
  int isSorted;
  int startBase;
  int endBase;
  int windowStartBase;
  int windowEndBase;
  int maxReads;
  int minMapQual;
  int minBaseQual;
  int minFlank;
  int trimReadFlank;
  int verbosity;
  int minGoodBases;
  int trimOverlapping;
  int trimAdapter;
  __pyx_t_15samtoolsWrapper_cAlignedRead *lastRead;
  PyObject *sample;
  struct __pyx_obj_7cwindow_ReadArray *reads;
  struct __pyx_obj_7cwindow_ReadArray *badReads;
  struct __pyx_obj_7cwindow_ReadArray *brokenMates;
};


/* "variant.pxd":18
 * @cython.final
 * @cython.freelist(1000)
 * cdef class Variant:             # <<<<<<<<<<<<<<
 *     cdef:
 *         public bytes refName
 */
struct __pyx_obj_7variant_Variant {
  PyObject_HEAD
  struct __pyx_vtabstruct_7variant_Variant *__pyx_vtab;
  PyObject *refName;
  PyObject *added;
  PyObject *removed;
  PyObject *bamAdded;
  PyObject *bamRemoved;
  int refPos;
  int bamMinPos;
  int bamMaxPos;
  int minRefPos;
  int maxRefPos;
  int nSupportingReads;
  int varSource;
  int hashValue;
  int nAdded;
  int nRemoved;
  int varType;
};


/* "variant.pxd":45
 * 
 * @cython.final
 * cdef class VariantCandidateGenerator:             # <<<<<<<<<<<<<<
 *     cdef int CIGAR_M
 *     cdef int CIGAR_I
 */
struct __pyx_obj_7variant_VariantCandidateGenerator {
  PyObject_HEAD
  struct __pyx_vtabstruct_7variant_VariantCandidateGenerator *__pyx_vtab;
  int CIGAR_M;
  int CIGAR_I;
  int CIGAR_D;
  int CIGAR_N;
  int CIGAR_S;
  int CIGAR_H;
  int CIGAR_P;
  int minMapQual;
  int minBaseQual;
  int minFlank;
  int refId;
  int maxCoverage;
  int verbosity;
  int genSNPs;
  int genIndels;
  int maxReadLength;
  long rStart;
  long rEnd;
  long refSeqStart;
  long refSeqEnd;
  char *refSeq;
  PyObject *variantHeap;
  PyObject *pyRefSeq;
  PyObject *rname;
  struct __pyx_obj_9fastafile_FastaFile *refFile;
  PyObject *options;
  int qualBinSize;
};



/* "samtoolsWrapper.pxd":223
 * 
 * ###################################################################################################
 * cdef class Samfile             # <<<<<<<<<<<<<<
 * 
 * @cython.final
 */

struct __pyx_vtabstruct_15samtoolsWrapper_Samfile {
  void (*clearHeader)(struct __pyx_obj_15samtoolsWrapper_Samfile *);
  void (*clearIndex)(struct __pyx_obj_15samtoolsWrapper_Samfile *);
  void (*createCache)(struct __pyx_obj_15samtoolsWrapper_Samfile *);
  void (*clearCache)(struct __pyx_obj_15samtoolsWrapper_Samfile *);
  int (*_isOpen)(struct __pyx_obj_15samtoolsWrapper_Samfile *);
  PyObject *(*_hasIndex)(struct __pyx_obj_15samtoolsWrapper_Samfile *);
  PyObject *(*_open)(struct __pyx_obj_15samtoolsWrapper_Samfile *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_15samtoolsWrapper_7Samfile__open *__pyx_optional_args);
  char *(*getrname)(struct __pyx_obj_15samtoolsWrapper_Samfile *, int);
  PyObject *(*_parseRegion)(struct __pyx_obj_15samtoolsWrapper_Samfile *, struct __pyx_opt_args_15samtoolsWrapper_7Samfile__parseRegion *__pyx_optional_args);
  struct __pyx_obj_15samtoolsWrapper_IteratorRow *(*fetch)(struct __pyx_obj_15samtoolsWrapper_Samfile *, char *, int, int, int __pyx_skip_dispatch);
  PyObject *(*close)(struct __pyx_obj_15samtoolsWrapper_Samfile *, int __pyx_skip_dispatch);
  void (*loadOffsetsForRegions)(struct __pyx_obj_15samtoolsWrapper_Samfile *, PyObject *);
  void (*openBAMFile)(struct __pyx_obj_15samtoolsWrapper_Samfile *, PyObject *);
};
static struct __pyx_vtabstruct_15samtoolsWrapper_Samfile *__pyx_vtabptr_15samtoolsWrapper_Samfile;


/* "samtoolsWrapper.pxd":226
 * 
 * @cython.final
 * cdef class IteratorRow:             # <<<<<<<<<<<<<<
 *     cdef bam_fetch_iterator_t*  bam_iter # iterator state object
 *     cdef bam1_t* b
 */

struct __pyx_vtabstruct_15samtoolsWrapper_IteratorRow {
  int (*cnext)(struct __pyx_obj_15samtoolsWrapper_IteratorRow *);
};
static struct __pyx_vtabstruct_15samtoolsWrapper_IteratorRow *__pyx_vtabptr_15samtoolsWrapper_IteratorRow;


/* "fastafile.pxd":1
 * cdef class FastaIndex:             # <<<<<<<<<<<<<<
 *     cdef object theFile
 *     cdef dict getRefs(self, int parseNCBI)
 */

struct __pyx_vtabstruct_9fastafile_FastaIndex {
  PyObject *(*getRefs)(struct __pyx_obj_9fastafile_FastaIndex *, int);
};
static struct __pyx_vtabstruct_9fastafile_FastaIndex *__pyx_vtabptr_9fastafile_FastaIndex;


/* "fastafile.pxd":5
 *     cdef dict getRefs(self, int parseNCBI)
 * 
 * cdef class FastaFile(object):             # <<<<<<<<<<<<<<
 *     cdef object theFile
 *     cdef FastaIndex theIndex
 */

struct __pyx_vtabstruct_9fastafile_FastaFile {
  PyObject *(*getCharacter)(struct __pyx_obj_9fastafile_FastaFile *, PyObject *, PY_LONG_LONG);
  PyObject *(*getSequence)(struct __pyx_obj_9fastafile_FastaFile *, PyObject *, PY_LONG_LONG, PY_LONG_LONG);
  void (*setCacheSequence)(struct __pyx_obj_9fastafile_FastaFile *, PyObject *, PY_LONG_LONG, PY_LONG_LONG);
};
static struct __pyx_vtabstruct_9fastafile_FastaFile *__pyx_vtabptr_9fastafile_FastaFile;


/* "cwindow.pxd":13
 * ###################################################################################################
 * 
 * cdef class ReadArray:             # <<<<<<<<<<<<<<
 *     cdef cAlignedRead** array
 *     cdef cAlignedRead** windowStart
 */

struct __pyx_vtabstruct_7cwindow_ReadArray {
  int (*getSize)(struct __pyx_obj_7cwindow_ReadArray *);
  void (*append)(struct __pyx_obj_7cwindow_ReadArray *, __pyx_t_15samtoolsWrapper_cAlignedRead *);
  void (*setWindowPointers)(struct __pyx_obj_7cwindow_ReadArray *, int, int);
  void (*setWindowPointersBasedOnMatePos)(struct __pyx_obj_7cwindow_ReadArray *, int, int);
  int (*getLengthOfLongestRead)(struct __pyx_obj_7cwindow_ReadArray *);
  int (*countReadsCoveringRegion)(struct __pyx_obj_7cwindow_ReadArray *, int, int);
};
static struct __pyx_vtabstruct_7cwindow_ReadArray *__pyx_vtabptr_7cwindow_ReadArray;


/* "cwindow.pxd":29
 * ###################################################################################################
 * 
 * cdef class bamReadBuffer:             # <<<<<<<<<<<<<<
 *     cdef char* chrom
 *     cdef int chromID
 */

struct __pyx_vtabstruct_7cwindow_bamReadBuffer {
  void (*setWindowPointers)(struct __pyx_obj_7cwindow_bamReadBuffer *, int, int, int, int, char *, int);
  void (*recompressReadsInCurrentWindow)(struct __pyx_obj_7cwindow_bamReadBuffer *, int, int, char *, int, int);
  void (*addReadToBuffer)(struct __pyx_obj_7cwindow_bamReadBuffer *, __pyx_t_15samtoolsWrapper_cAlignedRead *);
  int (*countImproperPairs)(struct __pyx_obj_7cwindow_bamReadBuffer *);
  int (*countAlignmentGaps)(struct __pyx_obj_7cwindow_bamReadBuffer *);
  void (*sortReads)(struct __pyx_obj_7cwindow_bamReadBuffer *);
  void (*sortBrokenMates)(struct __pyx_obj_7cwindow_bamReadBuffer *);
  void (*logFilterSummary)(struct __pyx_obj_7cwindow_bamReadBuffer *);
  int (*countReadsCoveringRegion)(struct __pyx_obj_7cwindow_bamReadBuffer *, int, int);
};
static struct __pyx_vtabstruct_7cwindow_bamReadBuffer *__pyx_vtabptr_7cwindow_bamReadBuffer;


/* "variant.pxd":18
 * @cython.final
 * @cython.freelist(1000)
 * cdef class Variant:             # <<<<<<<<<<<<<<
 *     cdef:
 *         public bytes refName
 */

struct __pyx_vtabstruct_7variant_Variant {
  double (*indelPrior)(struct __pyx_obj_7variant_Variant *, struct __pyx_obj_9fastafile_FastaFile *, int);
  double (*calculatePrior)(struct __pyx_obj_7variant_Variant *, struct __pyx_obj_9fastafile_FastaFile *);
  void (*addVariant)(struct __pyx_obj_7variant_Variant *, struct __pyx_obj_7variant_Variant *);
  int (*overlaps)(struct __pyx_obj_7variant_Variant *, struct __pyx_obj_7variant_Variant *);
};
static struct __pyx_vtabstruct_7variant_Variant *__pyx_vtabptr_7variant_Variant;


/* "variant.pxd":45
 * 
 * @cython.final
 * cdef class VariantCandidateGenerator:             # <<<<<<<<<<<<<<
 *     cdef int CIGAR_M
 *     cdef int CIGAR_I
 */

struct __pyx_vtabstruct_7variant_VariantCandidateGenerator {
  void (*addVariantToList)(struct __pyx_obj_7variant_VariantCandidateGenerator *, struct __pyx_obj_7variant_Variant *);
  void (*getSnpCandidatesFromReadSegment)(struct __pyx_obj_7variant_VariantCandidateGenerator *, __pyx_t_15samtoolsWrapper_cAlignedRead *, char *, char *, int, int, int, int, int);
  void (*getVariantCandidatesFromSingleRead)(struct __pyx_obj_7variant_VariantCandidateGenerator *, __pyx_t_15samtoolsWrapper_cAlignedRead *);
  void (*addCandidatesFromReads)(struct __pyx_obj_7variant_VariantCandidateGenerator *, __pyx_t_15samtoolsWrapper_cAlignedRead **, __pyx_t_15samtoolsWrapper_cAlignedRead **);
  PyObject *(*getCandidates)(struct __pyx_obj_7variant_VariantCandidateGenerator *, int);
};
static struct __pyx_vtabstruct_7variant_VariantCandidateGenerator *__pyx_vtabptr_7variant_VariantCandidateGenerator;
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          if (acquire_gil) { \
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
              PyGILState_Release(__pyx_gilstate_save); \
          } else { \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext() \
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif /* CYTHON_REFNANNY */
#define __Pyx_XDECREF_SET(r, v) do {                            \
        PyObject *tmp = (PyObject *) r;                         \
        r = v; __Pyx_XDECREF(tmp);                              \
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {                             \
        PyObject *tmp = (PyObject *) r;                         \
        r = v; __Pyx_DECREF(tmp);                               \
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw); /*proto*/
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/

static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                  int lineno, const char *filename,
                                  int full_traceback); /*proto*/

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
#endif

#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) : \
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) : \
               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) : \
    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) : \
    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck);

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/

static void* __Pyx_GetVtable(PyObject *dict); /*proto*/

static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name); /*proto*/

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);

static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_char(char value);

static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

static int __Pyx_check_binary_version(void);

static int __Pyx_ExportFunction(const char *name, void (*f)(void), const char *sig); /*proto*/

#if !defined(__Pyx_PyIdentifier_FromString)
#if PY_MAJOR_VERSION < 3
  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
#else
  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
#endif
#endif

static PyObject *__Pyx_ImportModule(const char *name); /*proto*/

static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);  /*proto*/

static int __Pyx_ImportVoidPtr(PyObject *module, const char *name, void **p, const char *sig); /*proto*/

typedef struct {
    int code_line;
    PyCodeObject* code_object;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/


/* Module declarations from 'cython' */

/* Module declarations from 'samtoolsWrapper' */
static PyTypeObject *__pyx_ptype_15samtoolsWrapper_Samfile = 0;
static PyTypeObject *__pyx_ptype_15samtoolsWrapper_IteratorRow = 0;
static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsReverse(__pyx_t_15samtoolsWrapper_cAlignedRead *); /*proto*/
static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsPaired(__pyx_t_15samtoolsWrapper_cAlignedRead *); /*proto*/
static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsProperPair(__pyx_t_15samtoolsWrapper_cAlignedRead *); /*proto*/
static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsDuplicate(__pyx_t_15samtoolsWrapper_cAlignedRead *); /*proto*/
static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsUnmapped(__pyx_t_15samtoolsWrapper_cAlignedRead *); /*proto*/
static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_MateIsUnmapped(__pyx_t_15samtoolsWrapper_cAlignedRead *); /*proto*/
static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsQCFail(__pyx_t_15samtoolsWrapper_cAlignedRead *); /*proto*/
static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsReadOne(__pyx_t_15samtoolsWrapper_cAlignedRead *); /*proto*/
static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsSecondaryAlignment(__pyx_t_15samtoolsWrapper_cAlignedRead *); /*proto*/

/* Module declarations from 'fastafile' */
static PyTypeObject *__pyx_ptype_9fastafile_FastaIndex = 0;
static PyTypeObject *__pyx_ptype_9fastafile_FastaFile = 0;

/* Module declarations from 'cwindow' */
static PyTypeObject *__pyx_ptype_7cwindow_ReadArray = 0;
static PyTypeObject *__pyx_ptype_7cwindow_bamReadBuffer = 0;

/* Module declarations from 'variant' */
static PyTypeObject *__pyx_ptype_7variant_Variant = 0;
static PyTypeObject *__pyx_ptype_7variant_VariantCandidateGenerator = 0;
static int *__pyx_vp_7variant_PLATYPUS_VAR = 0;
#define __pyx_v_7variant_PLATYPUS_VAR (*__pyx_vp_7variant_PLATYPUS_VAR)
static int *__pyx_vp_7variant_FILE_VAR = 0;
#define __pyx_v_7variant_FILE_VAR (*__pyx_vp_7variant_FILE_VAR)
static int *__pyx_vp_7variant_ASSEMBLER_VAR = 0;
#define __pyx_v_7variant_ASSEMBLER_VAR (*__pyx_vp_7variant_ASSEMBLER_VAR)

/* Module declarations from 'assembler' */
static int __pyx_v_9assembler_REF;
static int __pyx_v_9assembler_READ;
static int __pyx_v_9assembler_REF_AND_READ;
static __pyx_t_9assembler_Path *__pyx_f_9assembler_createPath(int); /*proto*/
static void __pyx_f_9assembler_destroyPath(__pyx_t_9assembler_Path *); /*proto*/
static void __pyx_f_9assembler_addNodeToPath(__pyx_t_9assembler_Path *, __pyx_t_9assembler_Node *, double); /*proto*/
static __pyx_t_9assembler_Node *__pyx_f_9assembler_createNode(char *, int, int, int, double); /*proto*/
static void *__pyx_f_9assembler_destroyNode(__pyx_t_9assembler_Node *); /*proto*/
static CYTHON_INLINE int __pyx_f_9assembler_Node_Equal(__pyx_t_9assembler_Node *, __pyx_t_9assembler_Node *); /*proto*/
static CYTHON_INLINE void __pyx_f_9assembler_Node_AddEdge(__pyx_t_9assembler_Node *, __pyx_t_9assembler_Edge *); /*proto*/
static CYTHON_INLINE int __pyx_f_9assembler_nodePosComp(void *, void *); /*proto*/
static CYTHON_INLINE unsigned int __pyx_f_9assembler_hashKmer(char *, int); /*proto*/
static __pyx_t_9assembler_PathStack *__pyx_f_9assembler_createPathStack(int); /*proto*/
static void __pyx_f_9assembler_destroyPathStack(__pyx_t_9assembler_PathStack *); /*proto*/
static int __pyx_f_9assembler_PathStack_IsEmpty(__pyx_t_9assembler_PathStack *); /*proto*/
static int __pyx_f_9assembler_PathStack_IsFull(__pyx_t_9assembler_PathStack *); /*proto*/
static void __pyx_f_9assembler_PathStack_Push(__pyx_t_9assembler_PathStack *, __pyx_t_9assembler_Path *); /*proto*/
static __pyx_t_9assembler_Path *__pyx_f_9assembler_PathStack_Pop(__pyx_t_9assembler_PathStack *); /*proto*/
static __pyx_t_9assembler_NodeStack *__pyx_f_9assembler_createNodeStack(int); /*proto*/
static void __pyx_f_9assembler_destroyNodeStack(__pyx_t_9assembler_NodeStack *); /*proto*/
static int __pyx_f_9assembler_NodeStack_IsEmpty(__pyx_t_9assembler_NodeStack *); /*proto*/
static int __pyx_f_9assembler_NodeStack_IsFull(__pyx_t_9assembler_NodeStack *); /*proto*/
static void __pyx_f_9assembler_NodeStack_Push(__pyx_t_9assembler_NodeStack *, __pyx_t_9assembler_Node *); /*proto*/
static __pyx_t_9assembler_Node *__pyx_f_9assembler_NodeStack_Pop(__pyx_t_9assembler_NodeStack *); /*proto*/
static __pyx_t_9assembler_Edge *__pyx_f_9assembler_createEdge(__pyx_t_9assembler_Node *, __pyx_t_9assembler_Node *, double); /*proto*/
static void __pyx_f_9assembler_destroyEdge(__pyx_t_9assembler_Edge *); /*proto*/
static int __pyx_f_9assembler_EdgeStack_IsEmpty(__pyx_t_9assembler_EdgeStack *); /*proto*/
static int __pyx_f_9assembler_EdgeStack_IsFull(__pyx_t_9assembler_EdgeStack *); /*proto*/
static __pyx_t_9assembler_NodeDict *__pyx_f_9assembler_createNodeDict(int); /*proto*/
static void __pyx_f_9assembler_destroyNodeDict(__pyx_t_9assembler_NodeDict *); /*proto*/
static int __pyx_f_9assembler_NodeDict_FindOrInsert(__pyx_t_9assembler_NodeDict *, __pyx_t_9assembler_Node **, int, __pyx_t_9assembler_Node **); /*proto*/
static __pyx_t_9assembler_DeBruijnGraph *__pyx_f_9assembler_createDeBruijnGraph(int, int); /*proto*/
static void __pyx_f_9assembler_destroyDeBruijnGraph(__pyx_t_9assembler_DeBruijnGraph *); /*proto*/
static int __pyx_f_9assembler_DeBruijnGraph_InsertOrUpdateNode(__pyx_t_9assembler_DeBruijnGraph *, __pyx_t_9assembler_Node **); /*proto*/
static void __pyx_f_9assembler_DeBruijnGraph_AddEdge(__pyx_t_9assembler_DeBruijnGraph *, __pyx_t_9assembler_Node *, __pyx_t_9assembler_Node *, double); /*proto*/
static int __pyx_f_9assembler_dfsVisit(__pyx_t_9assembler_Node *, double); /*proto*/
static int __pyx_f_9assembler_detectCyclesInGraph_Recursive(__pyx_t_9assembler_DeBruijnGraph *, double); /*proto*/
static int __pyx_f_9assembler_checkPathForCycles(__pyx_t_9assembler_Path *); /*proto*/
static __pyx_t_9assembler_PathStack *__pyx_f_9assembler_getVariantPathsThroughGraphFromNode(__pyx_t_9assembler_DeBruijnGraph *, __pyx_t_9assembler_Path *, double); /*proto*/
static PyObject *__pyx_f_9assembler_findBubblesInGraph(__pyx_t_9assembler_DeBruijnGraph *, double, char *, char *, int, int, int, int, int); /*proto*/
static struct __pyx_obj_7variant_Variant *__pyx_f_9assembler_extractVarFromBubblePath(__pyx_t_9assembler_DeBruijnGraph *, __pyx_t_9assembler_Path *, char *, char *, int, int, int); /*proto*/
static void __pyx_f_9assembler_loadReferenceIntoGraph(__pyx_t_9assembler_DeBruijnGraph *, char *, int, int); /*proto*/
static void __pyx_f_9assembler_loadReadIntoGraph(__pyx_t_15samtoolsWrapper_cAlignedRead *, __pyx_t_9assembler_DeBruijnGraph *, int, int); /*proto*/
static void __pyx_f_9assembler_loadBAMDataIntoGraph(__pyx_t_9assembler_DeBruijnGraph *, PyObject *, int, int, int, int); /*proto*/
#define __Pyx_MODULE_NAME "assembler"
int __pyx_module_is_main_assembler = 0;

/* Implementation of 'assembler' */
static PyObject *__pyx_builtin_range;
static PyObject *__pyx_builtin_StandardError;
static PyObject *__pyx_builtin_sorted;
static char __pyx_k_Log[] = "Log";
static char __pyx_k_info[] = "info";
static char __pyx_k_main[] = "__main__";
static char __pyx_k_test[] = "__test__";
static char __pyx_k_debug[] = "debug";
static char __pyx_k_error[] = "error";
static char __pyx_k_heapq[] = "heapq";
static char __pyx_k_range[] = "range";
static char __pyx_k_import[] = "__import__";
static char __pyx_k_logger[] = "logger";
static char __pyx_k_sorted[] = "sorted";
static char __pyx_k_logging[] = "logging";
static char __pyx_k_warning[] = "warning";
static char __pyx_k_minReads[] = "minReads";
static char __pyx_k_noCycles[] = "noCycles";
static char __pyx_k_Null_Node[] = "Null Node";
static char __pyx_k_Null_path[] = "Null path";
static char __pyx_k_getLogger[] = "getLogger";
static char __pyx_k_verbosity[] = "verbosity";
static char __pyx_k_minMapQual[] = "minMapQual";
static char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
static char __pyx_k_collections[] = "collections";
static char __pyx_k_defaultdict[] = "defaultdict";
static char __pyx_k_minBaseQual[] = "minBaseQual";
static char __pyx_k_StandardError[] = "StandardError";
static char __pyx_k_assembleBadReads[] = "assembleBadReads";
static char __pyx_k_assemblerKmerSize[] = "assemblerKmerSize";
static char __pyx_k_assemblyRegionSize[] = "assemblyRegionSize";
static char __pyx_k_assembleBrokenPairs[] = "assembleBrokenPairs";
static char __pyx_k_Assembling_region_s_s_s[] = "Assembling region %s:%s-%s";
static char __pyx_k_Could_not_allocate_node[] = "Could not allocate node";
static char __pyx_k_Could_not_allocate_path[] = "Could not allocate path";
static char __pyx_k_Logging_path_of_s_nodes[] = "Logging path of %s nodes";
static char __pyx_k_Error_Could_not_NodeDict[] = "Error. Could not NodeDict";
static char __pyx_k_Could_not_re_allocate_bucket[] = "Could not re-allocate bucket";
static char __pyx_k_Error_Could_not_allocate_edge[] = "Error. Could not allocate edge";
static char __pyx_k_Could_not_assemble_region_s_s_s[] = "Could not assemble region %s:%s-%s without cycles. Max k-mer size tried = %s";
static char __pyx_k_Could_not_re_allocate_EdgeStack[] = "Could not re-allocate EdgeStack";
static char __pyx_k_Could_not_re_allocate_NodeStack[] = "Could not re-allocate NodeStack";
static char __pyx_k_Could_not_re_allocate_PathStack[] = "Could not re-allocate PathStack";
static char __pyx_k_Cython_module_used_to_interface[] = "\nCython module used to interface to assembler routines.\n";
static char __pyx_k_Node_struct_cannot_have_4_edges[] = "Node struct cannot have > 4 edges. Now we have %s. This will cause problems";
static char __pyx_k_Could_not_allocate_hash_table_bu[] = "Could not allocate hash table bucket with size %s";
static char __pyx_k_Could_not_allocate_memory_for_De[] = "Could not allocate memory for DeBruijnGraph";
static char __pyx_k_Could_not_allocate_memory_for_ch[] = "Could not allocate memory for charReadSeq of size %s";
static char __pyx_k_Could_not_allocate_memory_for_st[] = "Could not allocate memory for string of size %s";
static char __pyx_k_Error_Could_not_NodeDict_bucketS[] = "Error. Could not NodeDict.bucketSize of size %s";
static char __pyx_k_Error_Could_not_NodeDict_buckets[] = "Error. Could not NodeDict.buckets of size %s";
static char __pyx_k_Error_Could_not_allocate_edge_st[] = "Error. Could not allocate edge stack with capacity %s";
static char __pyx_k_Error_Could_not_allocate_node_st[] = "Error. Could not allocate node stack with capacity %s";
static char __pyx_k_Error_Could_not_allocate_path_st[] = "Error. Could not allocate path stack with capacity %s";
static char __pyx_k_Found_complex_variation_that_Pla[] = "Found complex variation that Platypus can't deal with yet at %s:%s-%s";
static char __pyx_k_Found_cycles_in_region_s_s_s_wit[] = "Found cycles in region %s:%s-%s with kmer size %s. Trying again with kmer size %s";
static char __pyx_k_Platypus_assembler_found_candida[] = "Platypus assembler found candidate variant of size %s. %s:%s-%s %s --> %s";
static char __pyx_k_Pos_s_Seq_s_RefSeq_c_Colours_s_N[] = "Pos = %s. Seq = %s. RefSeq = %c. Colours = %s. Node weight = %s";
static char __pyx_k_nNodes_s_nFilledBuckets_s_mean_e[] = "nNodes = %s. nFilledBuckets = %s. mean entries/bucket = %s";
static char __pyx_k_Error_Could_not_allocate_edge_st_2[] = "Error. Could not allocate edge stack elements with capacity %s";
static char __pyx_k_Error_Could_not_allocate_node_st_2[] = "Error. Could not allocate node stack elements with capacity %s";
static char __pyx_k_Error_Could_not_allocate_path_st_2[] = "Error. Could not allocate path stack elements with capacity %s";
static PyObject *__pyx_kp_s_Assembling_region_s_s_s;
static PyObject *__pyx_kp_s_Could_not_allocate_hash_table_bu;
static PyObject *__pyx_kp_s_Could_not_allocate_memory_for_De;
static PyObject *__pyx_kp_s_Could_not_allocate_memory_for_ch;
static PyObject *__pyx_kp_s_Could_not_allocate_memory_for_st;
static PyObject *__pyx_kp_s_Could_not_allocate_node;
static PyObject *__pyx_kp_s_Could_not_allocate_path;
static PyObject *__pyx_kp_s_Could_not_assemble_region_s_s_s;
static PyObject *__pyx_kp_s_Could_not_re_allocate_EdgeStack;
static PyObject *__pyx_kp_s_Could_not_re_allocate_NodeStack;
static PyObject *__pyx_kp_s_Could_not_re_allocate_PathStack;
static PyObject *__pyx_kp_s_Could_not_re_allocate_bucket;
static PyObject *__pyx_kp_s_Error_Could_not_NodeDict;
static PyObject *__pyx_kp_s_Error_Could_not_NodeDict_bucketS;
static PyObject *__pyx_kp_s_Error_Could_not_NodeDict_buckets;
static PyObject *__pyx_kp_s_Error_Could_not_allocate_edge;
static PyObject *__pyx_kp_s_Error_Could_not_allocate_edge_st;
static PyObject *__pyx_kp_s_Error_Could_not_allocate_edge_st_2;
static PyObject *__pyx_kp_s_Error_Could_not_allocate_node_st;
static PyObject *__pyx_kp_s_Error_Could_not_allocate_node_st_2;
static PyObject *__pyx_kp_s_Error_Could_not_allocate_path_st;
static PyObject *__pyx_kp_s_Error_Could_not_allocate_path_st_2;
static PyObject *__pyx_kp_s_Found_complex_variation_that_Pla;
static PyObject *__pyx_kp_s_Found_cycles_in_region_s_s_s_wit;
static PyObject *__pyx_n_s_Log;
static PyObject *__pyx_kp_s_Logging_path_of_s_nodes;
static PyObject *__pyx_kp_s_Node_struct_cannot_have_4_edges;
static PyObject *__pyx_kp_s_Null_Node;
static PyObject *__pyx_kp_s_Null_path;
static PyObject *__pyx_kp_s_Platypus_assembler_found_candida;
static PyObject *__pyx_kp_s_Pos_s_Seq_s_RefSeq_c_Colours_s_N;
static PyObject *__pyx_n_s_StandardError;
static PyObject *__pyx_n_s_assembleBadReads;
static PyObject *__pyx_n_s_assembleBrokenPairs;
static PyObject *__pyx_n_s_assemblerKmerSize;
static PyObject *__pyx_n_s_assemblyRegionSize;
static PyObject *__pyx_n_s_collections;
static PyObject *__pyx_n_s_debug;
static PyObject *__pyx_n_s_defaultdict;
static PyObject *__pyx_n_s_error;
static PyObject *__pyx_n_s_getLogger;
static PyObject *__pyx_n_s_heapq;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_info;
static PyObject *__pyx_n_s_logger;
static PyObject *__pyx_n_s_logging;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_minBaseQual;
static PyObject *__pyx_n_s_minMapQual;
static PyObject *__pyx_n_s_minReads;
static PyObject *__pyx_kp_s_nNodes_s_nFilledBuckets_s_mean_e;
static PyObject *__pyx_n_s_noCycles;
static PyObject *__pyx_n_s_pyx_vtable;
static PyObject *__pyx_n_s_range;
static PyObject *__pyx_n_s_sorted;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_verbosity;
static PyObject *__pyx_n_s_warning;
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_100;
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__5;
static PyObject *__pyx_tuple__6;
static PyObject *__pyx_tuple__7;
static PyObject *__pyx_tuple__8;
static PyObject *__pyx_tuple__9;
static PyObject *__pyx_tuple__10;

/* "assembler.pyx":128
 * ###################################################################################################
 * 
 * cdef Path* createPath(int initialSize):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a Path struct.
 */

static __pyx_t_9assembler_Path *__pyx_f_9assembler_createPath(int __pyx_v_initialSize) {
  __pyx_t_9assembler_Path *__pyx_v_thePath;
  __pyx_t_9assembler_Path *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createPath", 0);

  /* "assembler.pyx":132
 *     Create and return a Path struct.
 *     """
 *     cdef Path* thePath = <Path*>(malloc(sizeof(Path)))             # <<<<<<<<<<<<<<
 * 
 *     if thePath == NULL:
 */
  __pyx_v_thePath = ((__pyx_t_9assembler_Path *)malloc((sizeof(__pyx_t_9assembler_Path))));

  /* "assembler.pyx":134
 *     cdef Path* thePath = <Path*>(malloc(sizeof(Path)))
 * 
 *     if thePath == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Could not allocate path")
 * 
 */
  __pyx_t_1 = ((__pyx_v_thePath == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":135
 * 
 *     if thePath == NULL:
 *         logger.error("Could not allocate path")             # <<<<<<<<<<<<<<
 * 
 *     thePath.nodes = createNodeStack(initialSize)
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":137
 *         logger.error("Could not allocate path")
 * 
 *     thePath.nodes = createNodeStack(initialSize)             # <<<<<<<<<<<<<<
 *     thePath.nNodes = 0
 *     thePath.isBubble = 0
 */
  __pyx_v_thePath->nodes = __pyx_f_9assembler_createNodeStack(__pyx_v_initialSize);

  /* "assembler.pyx":138
 * 
 *     thePath.nodes = createNodeStack(initialSize)
 *     thePath.nNodes = 0             # <<<<<<<<<<<<<<
 *     thePath.isBubble = 0
 *     thePath.weight = 0.0
 */
  __pyx_v_thePath->nNodes = 0;

  /* "assembler.pyx":139
 *     thePath.nodes = createNodeStack(initialSize)
 *     thePath.nNodes = 0
 *     thePath.isBubble = 0             # <<<<<<<<<<<<<<
 *     thePath.weight = 0.0
 * 
 */
  __pyx_v_thePath->isBubble = 0;

  /* "assembler.pyx":140
 *     thePath.nNodes = 0
 *     thePath.isBubble = 0
 *     thePath.weight = 0.0             # <<<<<<<<<<<<<<
 * 
 *     return thePath
 */
  __pyx_v_thePath->weight = 0.0;

  /* "assembler.pyx":142
 *     thePath.weight = 0.0
 * 
 *     return thePath             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_thePath;
  goto __pyx_L0;

  /* "assembler.pyx":128
 * ###################################################################################################
 * 
 * cdef Path* createPath(int initialSize):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a Path struct.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_WriteUnraisable("assembler.createPath", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":146
 * ###################################################################################################
 * 
 * cdef void destroyPath(Path* thePath):             # <<<<<<<<<<<<<<
 *     """
 *     free up memory in Path struct.
 */

static void __pyx_f_9assembler_destroyPath(__pyx_t_9assembler_Path *__pyx_v_thePath) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("destroyPath", 0);

  /* "assembler.pyx":150
 *     free up memory in Path struct.
 *     """
 *     destroyNodeStack(thePath.nodes)             # <<<<<<<<<<<<<<
 *     thePath.nodes = NULL
 *     free(thePath)
 */
  __pyx_f_9assembler_destroyNodeStack(__pyx_v_thePath->nodes);

  /* "assembler.pyx":151
 *     """
 *     destroyNodeStack(thePath.nodes)
 *     thePath.nodes = NULL             # <<<<<<<<<<<<<<
 *     free(thePath)
 *     thePath = NULL
 */
  __pyx_v_thePath->nodes = NULL;

  /* "assembler.pyx":152
 *     destroyNodeStack(thePath.nodes)
 *     thePath.nodes = NULL
 *     free(thePath)             # <<<<<<<<<<<<<<
 *     thePath = NULL
 * 
 */
  free(__pyx_v_thePath);

  /* "assembler.pyx":153
 *     thePath.nodes = NULL
 *     free(thePath)
 *     thePath = NULL             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_v_thePath = NULL;

  /* "assembler.pyx":146
 * ###################################################################################################
 * 
 * cdef void destroyPath(Path* thePath):             # <<<<<<<<<<<<<<
 *     """
 *     free up memory in Path struct.
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":157
 * ###################################################################################################
 * 
 * cdef void addNodeToPath(Path* thePath, Node* theNode, double weight):             # <<<<<<<<<<<<<<
 *     """
 *     Add a Node to the specified path.
 */

static void __pyx_f_9assembler_addNodeToPath(__pyx_t_9assembler_Path *__pyx_v_thePath, __pyx_t_9assembler_Node *__pyx_v_theNode, double __pyx_v_weight) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("addNodeToPath", 0);

  /* "assembler.pyx":161
 *     Add a Node to the specified path.
 *     """
 *     if thePath == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Null path")
 * 
 */
  __pyx_t_1 = ((__pyx_v_thePath == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":162
 *     """
 *     if thePath == NULL:
 *         logger.error("Null path")             # <<<<<<<<<<<<<<
 * 
 *     if theNode == NULL:
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":164
 *         logger.error("Null path")
 * 
 *     if theNode == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Null Node")
 * 
 */
  __pyx_t_1 = ((__pyx_v_theNode == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":165
 * 
 *     if theNode == NULL:
 *         logger.error("Null Node")             # <<<<<<<<<<<<<<
 * 
 *     NodeStack_Push(thePath.nodes, theNode)
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "assembler.pyx":167
 *         logger.error("Null Node")
 * 
 *     NodeStack_Push(thePath.nodes, theNode)             # <<<<<<<<<<<<<<
 *     thePath.nNodes += 1
 *     thePath.weight += weight
 */
  __pyx_f_9assembler_NodeStack_Push(__pyx_v_thePath->nodes, __pyx_v_theNode);

  /* "assembler.pyx":168
 * 
 *     NodeStack_Push(thePath.nodes, theNode)
 *     thePath.nNodes += 1             # <<<<<<<<<<<<<<
 *     thePath.weight += weight
 * 
 */
  __pyx_v_thePath->nNodes = (__pyx_v_thePath->nNodes + 1);

  /* "assembler.pyx":169
 *     NodeStack_Push(thePath.nodes, theNode)
 *     thePath.nNodes += 1
 *     thePath.weight += weight             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_v_thePath->weight = (__pyx_v_thePath->weight + __pyx_v_weight);

  /* "assembler.pyx":157
 * ###################################################################################################
 * 
 * cdef void addNodeToPath(Path* thePath, Node* theNode, double weight):             # <<<<<<<<<<<<<<
 *     """
 *     Add a Node to the specified path.
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_WriteUnraisable("assembler.addNodeToPath", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":173
 * ###################################################################################################
 * 
 * cdef Node* createNode(char* sequence, int colour, int position, int kmerSize, double weight):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a new node.
 */

static __pyx_t_9assembler_Node *__pyx_f_9assembler_createNode(char *__pyx_v_sequence, int __pyx_v_colour, int __pyx_v_position, int __pyx_v_kmerSize, double __pyx_v_weight) {
  __pyx_t_9assembler_Node *__pyx_v_theNode;
  __pyx_t_9assembler_Node *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createNode", 0);

  /* "assembler.pyx":177
 *     Create and return a new node.
 *     """
 *     cdef Node* theNode = <Node*>(malloc(sizeof(Node)))             # <<<<<<<<<<<<<<
 * 
 *     if theNode == NULL:
 */
  __pyx_v_theNode = ((__pyx_t_9assembler_Node *)malloc((sizeof(__pyx_t_9assembler_Node))));

  /* "assembler.pyx":179
 *     cdef Node* theNode = <Node*>(malloc(sizeof(Node)))
 * 
 *     if theNode == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Could not allocate node")
 * 
 */
  __pyx_t_1 = ((__pyx_v_theNode == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":180
 * 
 *     if theNode == NULL:
 *         logger.error("Could not allocate node")             # <<<<<<<<<<<<<<
 * 
 *     # Need to allocate kmerSize + 1 to store the null terminating character
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":183
 * 
 *     # Need to allocate kmerSize + 1 to store the null terminating character
 *     theNode.edges[0] = NULL             # <<<<<<<<<<<<<<
 *     theNode.edges[1] = NULL
 *     theNode.edges[2] = NULL
 */
  (__pyx_v_theNode->edges[0]) = NULL;

  /* "assembler.pyx":184
 *     # Need to allocate kmerSize + 1 to store the null terminating character
 *     theNode.edges[0] = NULL
 *     theNode.edges[1] = NULL             # <<<<<<<<<<<<<<
 *     theNode.edges[2] = NULL
 *     theNode.edges[3] = NULL
 */
  (__pyx_v_theNode->edges[1]) = NULL;

  /* "assembler.pyx":185
 *     theNode.edges[0] = NULL
 *     theNode.edges[1] = NULL
 *     theNode.edges[2] = NULL             # <<<<<<<<<<<<<<
 *     theNode.edges[3] = NULL
 * 
 */
  (__pyx_v_theNode->edges[2]) = NULL;

  /* "assembler.pyx":186
 *     theNode.edges[1] = NULL
 *     theNode.edges[2] = NULL
 *     theNode.edges[3] = NULL             # <<<<<<<<<<<<<<
 * 
 *     theNode.sequence = sequence
 */
  (__pyx_v_theNode->edges[3]) = NULL;

  /* "assembler.pyx":188
 *     theNode.edges[3] = NULL
 * 
 *     theNode.sequence = sequence             # <<<<<<<<<<<<<<
 *     theNode.weight = weight
 *     theNode.colours = colour
 */
  __pyx_v_theNode->sequence = __pyx_v_sequence;

  /* "assembler.pyx":189
 * 
 *     theNode.sequence = sequence
 *     theNode.weight = weight             # <<<<<<<<<<<<<<
 *     theNode.colours = colour
 *     theNode.dfsColour = 'N'
 */
  __pyx_v_theNode->weight = __pyx_v_weight;

  /* "assembler.pyx":190
 *     theNode.sequence = sequence
 *     theNode.weight = weight
 *     theNode.colours = colour             # <<<<<<<<<<<<<<
 *     theNode.dfsColour = 'N'
 *     theNode.kmerSize = kmerSize
 */
  __pyx_v_theNode->colours = __pyx_v_colour;

  /* "assembler.pyx":191
 *     theNode.weight = weight
 *     theNode.colours = colour
 *     theNode.dfsColour = 'N'             # <<<<<<<<<<<<<<
 *     theNode.kmerSize = kmerSize
 *     theNode.position = position
 */
  __pyx_v_theNode->dfsColour = 'N';

  /* "assembler.pyx":192
 *     theNode.colours = colour
 *     theNode.dfsColour = 'N'
 *     theNode.kmerSize = kmerSize             # <<<<<<<<<<<<<<
 *     theNode.position = position
 *     theNode.nEdges = 0
 */
  __pyx_v_theNode->kmerSize = __pyx_v_kmerSize;

  /* "assembler.pyx":193
 *     theNode.dfsColour = 'N'
 *     theNode.kmerSize = kmerSize
 *     theNode.position = position             # <<<<<<<<<<<<<<
 *     theNode.nEdges = 0
 * 
 */
  __pyx_v_theNode->position = __pyx_v_position;

  /* "assembler.pyx":194
 *     theNode.kmerSize = kmerSize
 *     theNode.position = position
 *     theNode.nEdges = 0             # <<<<<<<<<<<<<<
 * 
 *     return theNode
 */
  __pyx_v_theNode->nEdges = 0;

  /* "assembler.pyx":196
 *     theNode.nEdges = 0
 * 
 *     return theNode             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_theNode;
  goto __pyx_L0;

  /* "assembler.pyx":173
 * ###################################################################################################
 * 
 * cdef Node* createNode(char* sequence, int colour, int position, int kmerSize, double weight):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a new node.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_WriteUnraisable("assembler.createNode", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":200
 * ###################################################################################################
 * 
 * cdef void* destroyNode(Node* theNode):             # <<<<<<<<<<<<<<
 *     """
 *     free all memory associated with a Node struct. The Node takes ownership
 */

static void *__pyx_f_9assembler_destroyNode(__pyx_t_9assembler_Node *__pyx_v_theNode) {
  int __pyx_v_i;
  void *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("destroyNode", 0);

  /* "assembler.pyx":206
 *     """
 *     # Edges belong to the node, so destroy these now.
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 * 
 *     for i in range(theNode.nEdges):
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":208
 *     cdef int i = 0
 * 
 *     for i in range(theNode.nEdges):             # <<<<<<<<<<<<<<
 *         destroyEdge(theNode.edges[i])
 * 
 */
  __pyx_t_1 = __pyx_v_theNode->nEdges;
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":209
 * 
 *     for i in range(theNode.nEdges):
 *         destroyEdge(theNode.edges[i])             # <<<<<<<<<<<<<<
 * 
 *     free(theNode)
 */
    __pyx_f_9assembler_destroyEdge((__pyx_v_theNode->edges[__pyx_v_i]));
  }

  /* "assembler.pyx":211
 *         destroyEdge(theNode.edges[i])
 * 
 *     free(theNode)             # <<<<<<<<<<<<<<
 *     theNode = NULL
 * 
 */
  free(__pyx_v_theNode);

  /* "assembler.pyx":212
 * 
 *     free(theNode)
 *     theNode = NULL             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_v_theNode = NULL;

  /* "assembler.pyx":200
 * ###################################################################################################
 * 
 * cdef void* destroyNode(Node* theNode):             # <<<<<<<<<<<<<<
 *     """
 *     free all memory associated with a Node struct. The Node takes ownership
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":216
 * ###################################################################################################
 * 
 * cdef inline int Node_Equal(Node* thisNode, Node* otherNode):             # <<<<<<<<<<<<<<
 *     """
 *     Two nodes are equal if and only if their sequencese are equal.
 */

static CYTHON_INLINE int __pyx_f_9assembler_Node_Equal(__pyx_t_9assembler_Node *__pyx_v_thisNode, __pyx_t_9assembler_Node *__pyx_v_otherNode) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("Node_Equal", 0);

  /* "assembler.pyx":220
 *     Two nodes are equal if and only if their sequencese are equal.
 *     """
 *     if thisNode.kmerSize != otherNode.kmerSize:             # <<<<<<<<<<<<<<
 *         return 0
 *     else:
 */
  __pyx_t_1 = ((__pyx_v_thisNode->kmerSize != __pyx_v_otherNode->kmerSize) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":221
 *     """
 *     if thisNode.kmerSize != otherNode.kmerSize:
 *         return 0             # <<<<<<<<<<<<<<
 *     else:
 *         return (strncmp(thisNode.sequence, otherNode.sequence, thisNode.kmerSize) == 0)
 */
    __pyx_r = 0;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":223
 *         return 0
 *     else:
 *         return (strncmp(thisNode.sequence, otherNode.sequence, thisNode.kmerSize) == 0)             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = (strncmp(__pyx_v_thisNode->sequence, __pyx_v_otherNode->sequence, __pyx_v_thisNode->kmerSize) == 0);
    goto __pyx_L0;
  }

  /* "assembler.pyx":216
 * ###################################################################################################
 * 
 * cdef inline int Node_Equal(Node* thisNode, Node* otherNode):             # <<<<<<<<<<<<<<
 *     """
 *     Two nodes are equal if and only if their sequencese are equal.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":227
 * ###################################################################################################
 * 
 * cdef inline void Node_AddEdge(Node* theNode, Edge* theEdge):             # <<<<<<<<<<<<<<
 *     """
 *     Add the specified edge to the specified node.
 */

static CYTHON_INLINE void __pyx_f_9assembler_Node_AddEdge(__pyx_t_9assembler_Node *__pyx_v_theNode, __pyx_t_9assembler_Edge *__pyx_v_theEdge) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("Node_AddEdge", 0);

  /* "assembler.pyx":231
 *     Add the specified edge to the specified node.
 *     """
 *     theNode.edges[theNode.nEdges] = theEdge             # <<<<<<<<<<<<<<
 *     theNode.nEdges += 1
 * 
 */
  (__pyx_v_theNode->edges[__pyx_v_theNode->nEdges]) = __pyx_v_theEdge;

  /* "assembler.pyx":232
 *     """
 *     theNode.edges[theNode.nEdges] = theEdge
 *     theNode.nEdges += 1             # <<<<<<<<<<<<<<
 * 
 *     if theNode.nEdges > 4:
 */
  __pyx_v_theNode->nEdges = (__pyx_v_theNode->nEdges + 1);

  /* "assembler.pyx":234
 *     theNode.nEdges += 1
 * 
 *     if theNode.nEdges > 4:             # <<<<<<<<<<<<<<
 *         logger.error("Node struct cannot have > 4 edges. Now we have %s. This will cause problems" %(theNode.nEdges))
 * 
 */
  __pyx_t_1 = ((__pyx_v_theNode->nEdges > 4) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":235
 * 
 *     if theNode.nEdges > 4:
 *         logger.error("Node struct cannot have > 4 edges. Now we have %s. This will cause problems" %(theNode.nEdges))             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_theNode->nEdges); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Node_struct_cannot_have_4_edges, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":227
 * ###################################################################################################
 * 
 * cdef inline void Node_AddEdge(Node* theNode, Edge* theEdge):             # <<<<<<<<<<<<<<
 *     """
 *     Add the specified edge to the specified node.
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("assembler.Node_AddEdge", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":240
 * 
 * @cython.profile(False)
 * cdef inline char* Node_GetSuffix(Node* theNode):             # <<<<<<<<<<<<<<
 *     """
 *     Return the suffix string of this node. The suffix is simply the last kmerSize-1
 */

static CYTHON_INLINE char *__pyx_f_9assembler_Node_GetSuffix(__pyx_t_9assembler_Node *__pyx_v_theNode) {
  char *__pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Node_GetSuffix", 0);

  /* "assembler.pyx":245
 *     elements of the node sequence.
 *     """
 *     return theNode.sequence + 1             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = (__pyx_v_theNode->sequence + 1);
  goto __pyx_L0;

  /* "assembler.pyx":240
 * 
 * @cython.profile(False)
 * cdef inline char* Node_GetSuffix(Node* theNode):             # <<<<<<<<<<<<<<
 *     """
 *     Return the suffix string of this node. The suffix is simply the last kmerSize-1
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":250
 * 
 * @cython.profile(False)
 * cdef inline char* Node_GetPrefix(Node* theNode):             # <<<<<<<<<<<<<<
 *     """
 *     Return the suffix string of this node. The suffix is simply the first kmerSize-1
 */

static CYTHON_INLINE char *__pyx_f_9assembler_Node_GetPrefix(__pyx_t_9assembler_Node *__pyx_v_theNode) {
  char *__pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("Node_GetPrefix", 0);

  /* "assembler.pyx":255
 *     elements of the node sequence.
 *     """
 *     return theNode.sequence             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_theNode->sequence;
  goto __pyx_L0;

  /* "assembler.pyx":250
 * 
 * @cython.profile(False)
 * cdef inline char* Node_GetPrefix(Node* theNode):             # <<<<<<<<<<<<<<
 *     """
 *     Return the suffix string of this node. The suffix is simply the first kmerSize-1
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":260
 * 
 * @cython.profile(False)
 * cdef inline int nodePosComp(void* x, void* y):             # <<<<<<<<<<<<<<
 *     """
 *     Comparison function for Node structs, for use in qsort, to sort Nodes by their
 */

static CYTHON_INLINE int __pyx_f_9assembler_nodePosComp(void *__pyx_v_x, void *__pyx_v_y) {
  __pyx_t_9assembler_Node **__pyx_v_nodeOne;
  __pyx_t_9assembler_Node **__pyx_v_nodeTwo;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nodePosComp", 0);

  /* "assembler.pyx":265
 *     positions.
 *     """
 *     cdef Node** nodeOne = <Node**>(x)             # <<<<<<<<<<<<<<
 *     cdef Node** nodeTwo = <Node**>(y)
 * 
 */
  __pyx_v_nodeOne = ((__pyx_t_9assembler_Node **)__pyx_v_x);

  /* "assembler.pyx":266
 *     """
 *     cdef Node** nodeOne = <Node**>(x)
 *     cdef Node** nodeTwo = <Node**>(y)             # <<<<<<<<<<<<<<
 * 
 *     # Sort by position
 */
  __pyx_v_nodeTwo = ((__pyx_t_9assembler_Node **)__pyx_v_y);

  /* "assembler.pyx":269
 * 
 *     # Sort by position
 *     return  nodeOne[0].position - nodeTwo[0].position             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = ((__pyx_v_nodeOne[0])->position - (__pyx_v_nodeTwo[0])->position);
  goto __pyx_L0;

  /* "assembler.pyx":260
 * 
 * @cython.profile(False)
 * cdef inline int nodePosComp(void* x, void* y):             # <<<<<<<<<<<<<<
 *     """
 *     Comparison function for Node structs, for use in qsort, to sort Nodes by their
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":274
 * 
 * @cython.profile(False)
 * cdef inline unsigned int hashKmer(char* theKmer, int size):             # <<<<<<<<<<<<<<
 *     """
 *     Return a hash value for the specified kmer.
 */

static CYTHON_INLINE unsigned int __pyx_f_9assembler_hashKmer(char *__pyx_v_theKmer, int __pyx_v_size) {
  int __pyx_v_i;
  unsigned int __pyx_v_hashVal;
  unsigned int __pyx_r;
  __Pyx_RefNannyDeclarations
  long __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("hashKmer", 0);

  /* "assembler.pyx":278
 *     Return a hash value for the specified kmer.
 *     """
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef unsigned int hashVal = 0
 * 
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":279
 *     """
 *     cdef int i = 0
 *     cdef unsigned int hashVal = 0             # <<<<<<<<<<<<<<
 * 
 *     # 1) Sum integers formed by 4-character sub-strings.
 */
  __pyx_v_hashVal = 0;

  /* "assembler.pyx":282
 * 
 *     # 1) Sum integers formed by 4-character sub-strings.
 *     for i in range(0, size-4, 4):             # <<<<<<<<<<<<<<
 *         hashVal += theKmer[i]
 *         hashVal += (theKmer[i + 1] << 8)
 */
  __pyx_t_1 = (__pyx_v_size - 4);
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=4) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":283
 *     # 1) Sum integers formed by 4-character sub-strings.
 *     for i in range(0, size-4, 4):
 *         hashVal += theKmer[i]             # <<<<<<<<<<<<<<
 *         hashVal += (theKmer[i + 1] << 8)
 *         hashVal += (theKmer[i + 2] << 16)
 */
    __pyx_v_hashVal = (__pyx_v_hashVal + (__pyx_v_theKmer[__pyx_v_i]));

    /* "assembler.pyx":284
 *     for i in range(0, size-4, 4):
 *         hashVal += theKmer[i]
 *         hashVal += (theKmer[i + 1] << 8)             # <<<<<<<<<<<<<<
 *         hashVal += (theKmer[i + 2] << 16)
 *         hashVal += (theKmer[i + 3] << 24)
 */
    __pyx_v_hashVal = (__pyx_v_hashVal + ((__pyx_v_theKmer[(__pyx_v_i + 1)]) << 8));

    /* "assembler.pyx":285
 *         hashVal += theKmer[i]
 *         hashVal += (theKmer[i + 1] << 8)
 *         hashVal += (theKmer[i + 2] << 16)             # <<<<<<<<<<<<<<
 *         hashVal += (theKmer[i + 3] << 24)
 * 
 */
    __pyx_v_hashVal = (__pyx_v_hashVal + ((__pyx_v_theKmer[(__pyx_v_i + 2)]) << 16));

    /* "assembler.pyx":286
 *         hashVal += (theKmer[i + 1] << 8)
 *         hashVal += (theKmer[i + 2] << 16)
 *         hashVal += (theKmer[i + 3] << 24)             # <<<<<<<<<<<<<<
 * 
 *     # 2) multiply by 101 and add new value. From Paul Larson (see StackOverflow)
 */
    __pyx_v_hashVal = (__pyx_v_hashVal + ((__pyx_v_theKmer[(__pyx_v_i + 3)]) << 24));
  }

  /* "assembler.pyx":292
 *     #    hashVal = hashVal * 101 + theKmer[i]
 * 
 *     return hashVal             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_hashVal;
  goto __pyx_L0;

  /* "assembler.pyx":274
 * 
 * @cython.profile(False)
 * cdef inline unsigned int hashKmer(char* theKmer, int size):             # <<<<<<<<<<<<<<
 *     """
 *     Return a hash value for the specified kmer.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":296
 * ###################################################################################################
 * 
 * cdef PathStack* createPathStack(int capacity):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a stack for storing Paths.
 */

static __pyx_t_9assembler_PathStack *__pyx_f_9assembler_createPathStack(int __pyx_v_capacity) {
  __pyx_t_9assembler_PathStack *__pyx_v_theStack;
  __pyx_t_9assembler_PathStack *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createPathStack", 0);

  /* "assembler.pyx":300
 *     Create and return a stack for storing Paths.
 *     """
 *     cdef PathStack* theStack = <PathStack*>(malloc(sizeof(PathStack)))             # <<<<<<<<<<<<<<
 * 
 *     if theStack == NULL:
 */
  __pyx_v_theStack = ((__pyx_t_9assembler_PathStack *)malloc((sizeof(__pyx_t_9assembler_PathStack))));

  /* "assembler.pyx":302
 *     cdef PathStack* theStack = <PathStack*>(malloc(sizeof(PathStack)))
 * 
 *     if theStack == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Error. Could not allocate path stack with capacity %s" %(capacity))
 * 
 */
  __pyx_t_1 = ((__pyx_v_theStack == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":303
 * 
 *     if theStack == NULL:
 *         logger.error("Error. Could not allocate path stack with capacity %s" %(capacity))             # <<<<<<<<<<<<<<
 * 
 *     theStack.elements = <Path**>(malloc(sizeof(Path*)*capacity))
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_capacity); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Error_Could_not_allocate_path_st, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":305
 *         logger.error("Error. Could not allocate path stack with capacity %s" %(capacity))
 * 
 *     theStack.elements = <Path**>(malloc(sizeof(Path*)*capacity))             # <<<<<<<<<<<<<<
 * 
 *     if theStack.elements == NULL:
 */
  __pyx_v_theStack->elements = ((__pyx_t_9assembler_Path **)malloc(((sizeof(__pyx_t_9assembler_Path *)) * __pyx_v_capacity)));

  /* "assembler.pyx":307
 *     theStack.elements = <Path**>(malloc(sizeof(Path*)*capacity))
 * 
 *     if theStack.elements == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Error. Could not allocate path stack elements with capacity %s" %(capacity))
 * 
 */
  __pyx_t_1 = ((__pyx_v_theStack->elements == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":308
 * 
 *     if theStack.elements == NULL:
 *         logger.error("Error. Could not allocate path stack elements with capacity %s" %(capacity))             # <<<<<<<<<<<<<<
 * 
 *     theStack.top = -1 # Empty
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_error); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_capacity); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_Error_Could_not_allocate_path_st_2, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "assembler.pyx":310
 *         logger.error("Error. Could not allocate path stack elements with capacity %s" %(capacity))
 * 
 *     theStack.top = -1 # Empty             # <<<<<<<<<<<<<<
 *     theStack.capacity = capacity
 *     return theStack
 */
  __pyx_v_theStack->top = -1;

  /* "assembler.pyx":311
 * 
 *     theStack.top = -1 # Empty
 *     theStack.capacity = capacity             # <<<<<<<<<<<<<<
 *     return theStack
 * 
 */
  __pyx_v_theStack->capacity = __pyx_v_capacity;

  /* "assembler.pyx":312
 *     theStack.top = -1 # Empty
 *     theStack.capacity = capacity
 *     return theStack             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_theStack;
  goto __pyx_L0;

  /* "assembler.pyx":296
 * ###################################################################################################
 * 
 * cdef PathStack* createPathStack(int capacity):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a stack for storing Paths.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("assembler.createPathStack", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":316
 * ###################################################################################################
 * 
 * cdef void destroyPathStack(PathStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Clears up memory in stack. Does not destroy the
 */

static void __pyx_f_9assembler_destroyPathStack(__pyx_t_9assembler_PathStack *__pyx_v_theStack) {
  int __pyx_v_i;
  __Pyx_RefNannyDeclarations
  long __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("destroyPathStack", 0);

  /* "assembler.pyx":321
 *     Paths.
 *     """
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 * 
 *     for i in range(theStack.top + 1):
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":323
 *     cdef int i = 0
 * 
 *     for i in range(theStack.top + 1):             # <<<<<<<<<<<<<<
 *         destroyPath(theStack.elements[i])
 * 
 */
  __pyx_t_1 = (__pyx_v_theStack->top + 1);
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":324
 * 
 *     for i in range(theStack.top + 1):
 *         destroyPath(theStack.elements[i])             # <<<<<<<<<<<<<<
 * 
 *     free(theStack.elements)
 */
    __pyx_f_9assembler_destroyPath((__pyx_v_theStack->elements[__pyx_v_i]));
  }

  /* "assembler.pyx":326
 *         destroyPath(theStack.elements[i])
 * 
 *     free(theStack.elements)             # <<<<<<<<<<<<<<
 *     theStack.elements = NULL
 *     free(theStack)
 */
  free(__pyx_v_theStack->elements);

  /* "assembler.pyx":327
 * 
 *     free(theStack.elements)
 *     theStack.elements = NULL             # <<<<<<<<<<<<<<
 *     free(theStack)
 *     theStack = NULL
 */
  __pyx_v_theStack->elements = NULL;

  /* "assembler.pyx":328
 *     free(theStack.elements)
 *     theStack.elements = NULL
 *     free(theStack)             # <<<<<<<<<<<<<<
 *     theStack = NULL
 * 
 */
  free(__pyx_v_theStack);

  /* "assembler.pyx":329
 *     theStack.elements = NULL
 *     free(theStack)
 *     theStack = NULL             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_v_theStack = NULL;

  /* "assembler.pyx":316
 * ###################################################################################################
 * 
 * cdef void destroyPathStack(PathStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Clears up memory in stack. Does not destroy the
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":334
 * 
 * @cython.profile(False)
 * cdef int PathStack_IsEmpty(PathStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is empty and 0 otherwise.
 */

static int __pyx_f_9assembler_PathStack_IsEmpty(__pyx_t_9assembler_PathStack *__pyx_v_theStack) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("PathStack_IsEmpty", 0);

  /* "assembler.pyx":338
 *     Return 1 if the stack is empty and 0 otherwise.
 *     """
 *     if theStack.top == -1:             # <<<<<<<<<<<<<<
 *         return 1
 *     else:
 */
  __pyx_t_1 = ((__pyx_v_theStack->top == -1) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":339
 *     """
 *     if theStack.top == -1:
 *         return 1             # <<<<<<<<<<<<<<
 *     else:
 *         return 0
 */
    __pyx_r = 1;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":341
 *         return 1
 *     else:
 *         return 0             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = 0;
    goto __pyx_L0;
  }

  /* "assembler.pyx":334
 * 
 * @cython.profile(False)
 * cdef int PathStack_IsEmpty(PathStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is empty and 0 otherwise.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":346
 * 
 * @cython.profile(False)
 * cdef int PathStack_IsFull(PathStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is full and 0 otherwise.
 */

static int __pyx_f_9assembler_PathStack_IsFull(__pyx_t_9assembler_PathStack *__pyx_v_theStack) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("PathStack_IsFull", 0);

  /* "assembler.pyx":350
 *     Return 1 if the stack is full and 0 otherwise.
 *     """
 *     if theStack.top + 1 == theStack.capacity:             # <<<<<<<<<<<<<<
 *         return 1
 *     else:
 */
  __pyx_t_1 = (((__pyx_v_theStack->top + 1) == __pyx_v_theStack->capacity) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":351
 *     """
 *     if theStack.top + 1 == theStack.capacity:
 *         return 1             # <<<<<<<<<<<<<<
 *     else:
 *         return 0
 */
    __pyx_r = 1;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":353
 *         return 1
 *     else:
 *         return 0             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = 0;
    goto __pyx_L0;
  }

  /* "assembler.pyx":346
 * 
 * @cython.profile(False)
 * cdef int PathStack_IsFull(PathStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is full and 0 otherwise.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":357
 * ###################################################################################################
 * 
 * cdef void PathStack_Push(PathStack* theStack, Path* element):             # <<<<<<<<<<<<<<
 *     """
 *     Add a new element to the stack. Elements always go on the top,
 */

static void __pyx_f_9assembler_PathStack_Push(__pyx_t_9assembler_PathStack *__pyx_v_theStack, __pyx_t_9assembler_Path *__pyx_v_element) {
  __pyx_t_9assembler_Path **__pyx_v_temp;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PathStack_Push", 0);

  /* "assembler.pyx":362
 *     i.e. in the highest position. Realloc if necessary.
 *     """
 *     cdef Path** temp = NULL             # <<<<<<<<<<<<<<
 * 
 *     # Need to realloc
 */
  __pyx_v_temp = NULL;

  /* "assembler.pyx":365
 * 
 *     # Need to realloc
 *     if PathStack_IsFull(theStack):             # <<<<<<<<<<<<<<
 *         temp = <Path**>(realloc(theStack.elements, 2*sizeof(Path*)*theStack.capacity))
 * 
 */
  __pyx_t_1 = (__pyx_f_9assembler_PathStack_IsFull(__pyx_v_theStack) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":366
 *     # Need to realloc
 *     if PathStack_IsFull(theStack):
 *         temp = <Path**>(realloc(theStack.elements, 2*sizeof(Path*)*theStack.capacity))             # <<<<<<<<<<<<<<
 * 
 *         if temp == NULL:
 */
    __pyx_v_temp = ((__pyx_t_9assembler_Path **)realloc(__pyx_v_theStack->elements, ((2 * (sizeof(__pyx_t_9assembler_Path *))) * __pyx_v_theStack->capacity)));

    /* "assembler.pyx":368
 *         temp = <Path**>(realloc(theStack.elements, 2*sizeof(Path*)*theStack.capacity))
 * 
 *         if temp == NULL:             # <<<<<<<<<<<<<<
 *             logger.error("Could not re-allocate PathStack")
 *         else:
 */
    __pyx_t_1 = ((__pyx_v_temp == NULL) != 0);
    if (__pyx_t_1) {

      /* "assembler.pyx":369
 * 
 *         if temp == NULL:
 *             logger.error("Could not re-allocate PathStack")             # <<<<<<<<<<<<<<
 *         else:
 *             theStack.elements = temp
 */
      __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      goto __pyx_L4;
    }
    /*else*/ {

      /* "assembler.pyx":371
 *             logger.error("Could not re-allocate PathStack")
 *         else:
 *             theStack.elements = temp             # <<<<<<<<<<<<<<
 *             theStack.capacity *= 2
 * 
 */
      __pyx_v_theStack->elements = __pyx_v_temp;

      /* "assembler.pyx":372
 *         else:
 *             theStack.elements = temp
 *             theStack.capacity *= 2             # <<<<<<<<<<<<<<
 * 
 *     theStack.top += 1
 */
      __pyx_v_theStack->capacity = (__pyx_v_theStack->capacity * 2);
    }
    __pyx_L4:;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":374
 *             theStack.capacity *= 2
 * 
 *     theStack.top += 1             # <<<<<<<<<<<<<<
 *     theStack.elements[theStack.top] = element
 * 
 */
  __pyx_v_theStack->top = (__pyx_v_theStack->top + 1);

  /* "assembler.pyx":375
 * 
 *     theStack.top += 1
 *     theStack.elements[theStack.top] = element             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  (__pyx_v_theStack->elements[__pyx_v_theStack->top]) = __pyx_v_element;

  /* "assembler.pyx":357
 * ###################################################################################################
 * 
 * cdef void PathStack_Push(PathStack* theStack, Path* element):             # <<<<<<<<<<<<<<
 *     """
 *     Add a new element to the stack. Elements always go on the top,
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_WriteUnraisable("assembler.PathStack_Push", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":379
 * ###################################################################################################
 * 
 * cdef Path* PathStack_Pop(PathStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Pop and return the top element from the stack.
 */

static __pyx_t_9assembler_Path *__pyx_f_9assembler_PathStack_Pop(__pyx_t_9assembler_PathStack *__pyx_v_theStack) {
  __pyx_t_9assembler_Path *__pyx_v_thePath;
  __pyx_t_9assembler_Path *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("PathStack_Pop", 0);

  /* "assembler.pyx":383
 *     Pop and return the top element from the stack.
 *     """
 *     cdef Path* thePath = NULL             # <<<<<<<<<<<<<<
 * 
 *     if PathStack_IsEmpty(theStack):
 */
  __pyx_v_thePath = NULL;

  /* "assembler.pyx":385
 *     cdef Path* thePath = NULL
 * 
 *     if PathStack_IsEmpty(theStack):             # <<<<<<<<<<<<<<
 *         return NULL
 *     else:
 */
  __pyx_t_1 = (__pyx_f_9assembler_PathStack_IsEmpty(__pyx_v_theStack) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":386
 * 
 *     if PathStack_IsEmpty(theStack):
 *         return NULL             # <<<<<<<<<<<<<<
 *     else:
 *         thePath = theStack.elements[theStack.top]
 */
    __pyx_r = NULL;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":388
 *         return NULL
 *     else:
 *         thePath = theStack.elements[theStack.top]             # <<<<<<<<<<<<<<
 *         theStack.top -= 1
 *         return thePath
 */
    __pyx_v_thePath = (__pyx_v_theStack->elements[__pyx_v_theStack->top]);

    /* "assembler.pyx":389
 *     else:
 *         thePath = theStack.elements[theStack.top]
 *         theStack.top -= 1             # <<<<<<<<<<<<<<
 *         return thePath
 * 
 */
    __pyx_v_theStack->top = (__pyx_v_theStack->top - 1);

    /* "assembler.pyx":390
 *         thePath = theStack.elements[theStack.top]
 *         theStack.top -= 1
 *         return thePath             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = __pyx_v_thePath;
    goto __pyx_L0;
  }

  /* "assembler.pyx":379
 * ###################################################################################################
 * 
 * cdef Path* PathStack_Pop(PathStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Pop and return the top element from the stack.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":394
 * ###################################################################################################
 * 
 * cdef NodeStack* createNodeStack(int capacity):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a stack for storing nodes.
 */

static __pyx_t_9assembler_NodeStack *__pyx_f_9assembler_createNodeStack(int __pyx_v_capacity) {
  __pyx_t_9assembler_NodeStack *__pyx_v_theStack;
  __pyx_t_9assembler_NodeStack *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createNodeStack", 0);

  /* "assembler.pyx":398
 *     Create and return a stack for storing nodes.
 *     """
 *     cdef NodeStack* theStack = <NodeStack*>(malloc(sizeof(NodeStack)))             # <<<<<<<<<<<<<<
 * 
 *     if theStack == NULL:
 */
  __pyx_v_theStack = ((__pyx_t_9assembler_NodeStack *)malloc((sizeof(__pyx_t_9assembler_NodeStack))));

  /* "assembler.pyx":400
 *     cdef NodeStack* theStack = <NodeStack*>(malloc(sizeof(NodeStack)))
 * 
 *     if theStack == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Error. Could not allocate node stack with capacity %s" %(capacity))
 * 
 */
  __pyx_t_1 = ((__pyx_v_theStack == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":401
 * 
 *     if theStack == NULL:
 *         logger.error("Error. Could not allocate node stack with capacity %s" %(capacity))             # <<<<<<<<<<<<<<
 * 
 *     theStack.elements = <Node**>(malloc(sizeof(Node*)*capacity))
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_capacity); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Error_Could_not_allocate_node_st, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":403
 *         logger.error("Error. Could not allocate node stack with capacity %s" %(capacity))
 * 
 *     theStack.elements = <Node**>(malloc(sizeof(Node*)*capacity))             # <<<<<<<<<<<<<<
 * 
 *     if theStack.elements == NULL:
 */
  __pyx_v_theStack->elements = ((__pyx_t_9assembler_Node **)malloc(((sizeof(__pyx_t_9assembler_Node *)) * __pyx_v_capacity)));

  /* "assembler.pyx":405
 *     theStack.elements = <Node**>(malloc(sizeof(Node*)*capacity))
 * 
 *     if theStack.elements == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Error. Could not allocate node stack elements with capacity %s" %(capacity))
 * 
 */
  __pyx_t_1 = ((__pyx_v_theStack->elements == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":406
 * 
 *     if theStack.elements == NULL:
 *         logger.error("Error. Could not allocate node stack elements with capacity %s" %(capacity))             # <<<<<<<<<<<<<<
 * 
 *     theStack.top = -1 # Empty
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_error); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_capacity); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_Error_Could_not_allocate_node_st_2, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "assembler.pyx":408
 *         logger.error("Error. Could not allocate node stack elements with capacity %s" %(capacity))
 * 
 *     theStack.top = -1 # Empty             # <<<<<<<<<<<<<<
 *     theStack.capacity = capacity
 *     return theStack
 */
  __pyx_v_theStack->top = -1;

  /* "assembler.pyx":409
 * 
 *     theStack.top = -1 # Empty
 *     theStack.capacity = capacity             # <<<<<<<<<<<<<<
 *     return theStack
 * 
 */
  __pyx_v_theStack->capacity = __pyx_v_capacity;

  /* "assembler.pyx":410
 *     theStack.top = -1 # Empty
 *     theStack.capacity = capacity
 *     return theStack             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_theStack;
  goto __pyx_L0;

  /* "assembler.pyx":394
 * ###################################################################################################
 * 
 * cdef NodeStack* createNodeStack(int capacity):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a stack for storing nodes.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("assembler.createNodeStack", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":414
 * ###################################################################################################
 * 
 * cdef void destroyNodeStack(NodeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Clears up memory in stack. Does not destroy the
 */

static void __pyx_f_9assembler_destroyNodeStack(__pyx_t_9assembler_NodeStack *__pyx_v_theStack) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("destroyNodeStack", 0);

  /* "assembler.pyx":419
 *     nodes.
 *     """
 *     free(theStack.elements)             # <<<<<<<<<<<<<<
 *     theStack.elements = NULL
 *     free(theStack)
 */
  free(__pyx_v_theStack->elements);

  /* "assembler.pyx":420
 *     """
 *     free(theStack.elements)
 *     theStack.elements = NULL             # <<<<<<<<<<<<<<
 *     free(theStack)
 *     theStack = NULL
 */
  __pyx_v_theStack->elements = NULL;

  /* "assembler.pyx":421
 *     free(theStack.elements)
 *     theStack.elements = NULL
 *     free(theStack)             # <<<<<<<<<<<<<<
 *     theStack = NULL
 * 
 */
  free(__pyx_v_theStack);

  /* "assembler.pyx":422
 *     theStack.elements = NULL
 *     free(theStack)
 *     theStack = NULL             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_v_theStack = NULL;

  /* "assembler.pyx":414
 * ###################################################################################################
 * 
 * cdef void destroyNodeStack(NodeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Clears up memory in stack. Does not destroy the
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":427
 * 
 * @cython.profile(False)
 * cdef int NodeStack_IsEmpty(NodeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is empty and 0 otherwise.
 */

static int __pyx_f_9assembler_NodeStack_IsEmpty(__pyx_t_9assembler_NodeStack *__pyx_v_theStack) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("NodeStack_IsEmpty", 0);

  /* "assembler.pyx":431
 *     Return 1 if the stack is empty and 0 otherwise.
 *     """
 *     if theStack.top == -1:             # <<<<<<<<<<<<<<
 *         return 1
 *     else:
 */
  __pyx_t_1 = ((__pyx_v_theStack->top == -1) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":432
 *     """
 *     if theStack.top == -1:
 *         return 1             # <<<<<<<<<<<<<<
 *     else:
 *         return 0
 */
    __pyx_r = 1;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":434
 *         return 1
 *     else:
 *         return 0             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = 0;
    goto __pyx_L0;
  }

  /* "assembler.pyx":427
 * 
 * @cython.profile(False)
 * cdef int NodeStack_IsEmpty(NodeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is empty and 0 otherwise.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":439
 * 
 * @cython.profile(False)
 * cdef int NodeStack_IsFull(NodeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is full and 0 otherwise.
 */

static int __pyx_f_9assembler_NodeStack_IsFull(__pyx_t_9assembler_NodeStack *__pyx_v_theStack) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("NodeStack_IsFull", 0);

  /* "assembler.pyx":443
 *     Return 1 if the stack is full and 0 otherwise.
 *     """
 *     if theStack.top + 1 == theStack.capacity:             # <<<<<<<<<<<<<<
 *         return 1
 *     else:
 */
  __pyx_t_1 = (((__pyx_v_theStack->top + 1) == __pyx_v_theStack->capacity) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":444
 *     """
 *     if theStack.top + 1 == theStack.capacity:
 *         return 1             # <<<<<<<<<<<<<<
 *     else:
 *         return 0
 */
    __pyx_r = 1;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":446
 *         return 1
 *     else:
 *         return 0             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = 0;
    goto __pyx_L0;
  }

  /* "assembler.pyx":439
 * 
 * @cython.profile(False)
 * cdef int NodeStack_IsFull(NodeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is full and 0 otherwise.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":450
 * ###################################################################################################
 * 
 * cdef void NodeStack_Push(NodeStack* theStack, Node* element):             # <<<<<<<<<<<<<<
 *     """
 *     Add a new element to the stack. Elements always go on the top,
 */

static void __pyx_f_9assembler_NodeStack_Push(__pyx_t_9assembler_NodeStack *__pyx_v_theStack, __pyx_t_9assembler_Node *__pyx_v_element) {
  __pyx_t_9assembler_Node **__pyx_v_temp;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("NodeStack_Push", 0);

  /* "assembler.pyx":455
 *     i.e. in the highest position. Realloc if necessary.
 *     """
 *     cdef Node** temp = NULL             # <<<<<<<<<<<<<<
 * 
 *     # Need to realloc
 */
  __pyx_v_temp = NULL;

  /* "assembler.pyx":458
 * 
 *     # Need to realloc
 *     if NodeStack_IsFull(theStack):             # <<<<<<<<<<<<<<
 *         temp = <Node**>(realloc(theStack.elements, 2*sizeof(Node*)*theStack.capacity))
 * 
 */
  __pyx_t_1 = (__pyx_f_9assembler_NodeStack_IsFull(__pyx_v_theStack) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":459
 *     # Need to realloc
 *     if NodeStack_IsFull(theStack):
 *         temp = <Node**>(realloc(theStack.elements, 2*sizeof(Node*)*theStack.capacity))             # <<<<<<<<<<<<<<
 * 
 *         if temp == NULL:
 */
    __pyx_v_temp = ((__pyx_t_9assembler_Node **)realloc(__pyx_v_theStack->elements, ((2 * (sizeof(__pyx_t_9assembler_Node *))) * __pyx_v_theStack->capacity)));

    /* "assembler.pyx":461
 *         temp = <Node**>(realloc(theStack.elements, 2*sizeof(Node*)*theStack.capacity))
 * 
 *         if temp == NULL:             # <<<<<<<<<<<<<<
 *             logger.error("Could not re-allocate NodeStack")
 *         else:
 */
    __pyx_t_1 = ((__pyx_v_temp == NULL) != 0);
    if (__pyx_t_1) {

      /* "assembler.pyx":462
 * 
 *         if temp == NULL:
 *             logger.error("Could not re-allocate NodeStack")             # <<<<<<<<<<<<<<
 *         else:
 *             theStack.elements = temp
 */
      __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      goto __pyx_L4;
    }
    /*else*/ {

      /* "assembler.pyx":464
 *             logger.error("Could not re-allocate NodeStack")
 *         else:
 *             theStack.elements = temp             # <<<<<<<<<<<<<<
 *             theStack.capacity *= 2
 * 
 */
      __pyx_v_theStack->elements = __pyx_v_temp;

      /* "assembler.pyx":465
 *         else:
 *             theStack.elements = temp
 *             theStack.capacity *= 2             # <<<<<<<<<<<<<<
 * 
 *     theStack.top += 1
 */
      __pyx_v_theStack->capacity = (__pyx_v_theStack->capacity * 2);
    }
    __pyx_L4:;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":467
 *             theStack.capacity *= 2
 * 
 *     theStack.top += 1             # <<<<<<<<<<<<<<
 *     theStack.elements[theStack.top] = element
 * 
 */
  __pyx_v_theStack->top = (__pyx_v_theStack->top + 1);

  /* "assembler.pyx":468
 * 
 *     theStack.top += 1
 *     theStack.elements[theStack.top] = element             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  (__pyx_v_theStack->elements[__pyx_v_theStack->top]) = __pyx_v_element;

  /* "assembler.pyx":450
 * ###################################################################################################
 * 
 * cdef void NodeStack_Push(NodeStack* theStack, Node* element):             # <<<<<<<<<<<<<<
 *     """
 *     Add a new element to the stack. Elements always go on the top,
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_WriteUnraisable("assembler.NodeStack_Push", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":472
 * ###################################################################################################
 * 
 * cdef Node* NodeStack_Pop(NodeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Pop and return the top element from the stack.
 */

static __pyx_t_9assembler_Node *__pyx_f_9assembler_NodeStack_Pop(__pyx_t_9assembler_NodeStack *__pyx_v_theStack) {
  __pyx_t_9assembler_Node *__pyx_v_theNode;
  __pyx_t_9assembler_Node *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("NodeStack_Pop", 0);

  /* "assembler.pyx":476
 *     Pop and return the top element from the stack.
 *     """
 *     cdef Node* theNode = NULL             # <<<<<<<<<<<<<<
 * 
 *     if NodeStack_IsEmpty(theStack):
 */
  __pyx_v_theNode = NULL;

  /* "assembler.pyx":478
 *     cdef Node* theNode = NULL
 * 
 *     if NodeStack_IsEmpty(theStack):             # <<<<<<<<<<<<<<
 *         return NULL
 *     else:
 */
  __pyx_t_1 = (__pyx_f_9assembler_NodeStack_IsEmpty(__pyx_v_theStack) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":479
 * 
 *     if NodeStack_IsEmpty(theStack):
 *         return NULL             # <<<<<<<<<<<<<<
 *     else:
 *         theNode = theStack.elements[theStack.top]
 */
    __pyx_r = NULL;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":481
 *         return NULL
 *     else:
 *         theNode = theStack.elements[theStack.top]             # <<<<<<<<<<<<<<
 *         theStack.top -= 1
 *         return theNode
 */
    __pyx_v_theNode = (__pyx_v_theStack->elements[__pyx_v_theStack->top]);

    /* "assembler.pyx":482
 *     else:
 *         theNode = theStack.elements[theStack.top]
 *         theStack.top -= 1             # <<<<<<<<<<<<<<
 *         return theNode
 * 
 */
    __pyx_v_theStack->top = (__pyx_v_theStack->top - 1);

    /* "assembler.pyx":483
 *         theNode = theStack.elements[theStack.top]
 *         theStack.top -= 1
 *         return theNode             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = __pyx_v_theNode;
    goto __pyx_L0;
  }

  /* "assembler.pyx":472
 * ###################################################################################################
 * 
 * cdef Node* NodeStack_Pop(NodeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Pop and return the top element from the stack.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":501
 * ###################################################################################################
 * 
 * cdef Edge* createEdge(Node* startNode, Node* endNode, double weight):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a new edge.
 */

static __pyx_t_9assembler_Edge *__pyx_f_9assembler_createEdge(__pyx_t_9assembler_Node *__pyx_v_startNode, __pyx_t_9assembler_Node *__pyx_v_endNode, double __pyx_v_weight) {
  __pyx_t_9assembler_Edge *__pyx_v_theEdge;
  __pyx_t_9assembler_Edge *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createEdge", 0);

  /* "assembler.pyx":505
 *     Create and return a new edge.
 *     """
 *     cdef Edge* theEdge = <Edge*>(malloc(sizeof(Edge)))             # <<<<<<<<<<<<<<
 * 
 *     if theEdge == NULL:
 */
  __pyx_v_theEdge = ((__pyx_t_9assembler_Edge *)malloc((sizeof(__pyx_t_9assembler_Edge))));

  /* "assembler.pyx":507
 *     cdef Edge* theEdge = <Edge*>(malloc(sizeof(Edge)))
 * 
 *     if theEdge == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Error. Could not allocate edge")
 * 
 */
  __pyx_t_1 = ((__pyx_v_theEdge == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":508
 * 
 *     if theEdge == NULL:
 *         logger.error("Error. Could not allocate edge")             # <<<<<<<<<<<<<<
 * 
 *     theEdge.startNode = startNode
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":510
 *         logger.error("Error. Could not allocate edge")
 * 
 *     theEdge.startNode = startNode             # <<<<<<<<<<<<<<
 *     theEdge.endNode = endNode
 *     theEdge.weight = weight
 */
  __pyx_v_theEdge->startNode = __pyx_v_startNode;

  /* "assembler.pyx":511
 * 
 *     theEdge.startNode = startNode
 *     theEdge.endNode = endNode             # <<<<<<<<<<<<<<
 *     theEdge.weight = weight
 * 
 */
  __pyx_v_theEdge->endNode = __pyx_v_endNode;

  /* "assembler.pyx":512
 *     theEdge.startNode = startNode
 *     theEdge.endNode = endNode
 *     theEdge.weight = weight             # <<<<<<<<<<<<<<
 * 
 *     return theEdge
 */
  __pyx_v_theEdge->weight = __pyx_v_weight;

  /* "assembler.pyx":514
 *     theEdge.weight = weight
 * 
 *     return theEdge             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_theEdge;
  goto __pyx_L0;

  /* "assembler.pyx":501
 * ###################################################################################################
 * 
 * cdef Edge* createEdge(Node* startNode, Node* endNode, double weight):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a new edge.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_WriteUnraisable("assembler.createEdge", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":518
 * ###################################################################################################
 * 
 * cdef void destroyEdge(Edge* theEdge):             # <<<<<<<<<<<<<<
 *     """
 *     free memory used by Edge struct.
 */

static void __pyx_f_9assembler_destroyEdge(__pyx_t_9assembler_Edge *__pyx_v_theEdge) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("destroyEdge", 0);

  /* "assembler.pyx":522
 *     free memory used by Edge struct.
 *     """
 *     free(theEdge)             # <<<<<<<<<<<<<<
 *     theEdge = NULL
 * 
 */
  free(__pyx_v_theEdge);

  /* "assembler.pyx":523
 *     """
 *     free(theEdge)
 *     theEdge = NULL             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_v_theEdge = NULL;

  /* "assembler.pyx":518
 * ###################################################################################################
 * 
 * cdef void destroyEdge(Edge* theEdge):             # <<<<<<<<<<<<<<
 *     """
 *     free memory used by Edge struct.
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":527
 * ###################################################################################################
 * 
 * cdef EdgeStack* createEdgeStack(int capacity):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a stack for storing Edges.
 */

static __pyx_t_9assembler_EdgeStack *__pyx_f_9assembler_createEdgeStack(int __pyx_v_capacity) {
  __pyx_t_9assembler_EdgeStack *__pyx_v_theStack;
  __pyx_t_9assembler_EdgeStack *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createEdgeStack", 0);

  /* "assembler.pyx":531
 *     Create and return a stack for storing Edges.
 *     """
 *     cdef EdgeStack* theStack = <EdgeStack*>(malloc(sizeof(EdgeStack)))             # <<<<<<<<<<<<<<
 * 
 *     if theStack == NULL:
 */
  __pyx_v_theStack = ((__pyx_t_9assembler_EdgeStack *)malloc((sizeof(__pyx_t_9assembler_EdgeStack))));

  /* "assembler.pyx":533
 *     cdef EdgeStack* theStack = <EdgeStack*>(malloc(sizeof(EdgeStack)))
 * 
 *     if theStack == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Error. Could not allocate edge stack with capacity %s" %(capacity))
 * 
 */
  __pyx_t_1 = ((__pyx_v_theStack == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":534
 * 
 *     if theStack == NULL:
 *         logger.error("Error. Could not allocate edge stack with capacity %s" %(capacity))             # <<<<<<<<<<<<<<
 * 
 *     theStack.elements = <Edge**>(malloc(sizeof(Edge*)*capacity))
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_capacity); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Error_Could_not_allocate_edge_st, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":536
 *         logger.error("Error. Could not allocate edge stack with capacity %s" %(capacity))
 * 
 *     theStack.elements = <Edge**>(malloc(sizeof(Edge*)*capacity))             # <<<<<<<<<<<<<<
 * 
 *     if theStack.elements == NULL:
 */
  __pyx_v_theStack->elements = ((__pyx_t_9assembler_Edge **)malloc(((sizeof(__pyx_t_9assembler_Edge *)) * __pyx_v_capacity)));

  /* "assembler.pyx":538
 *     theStack.elements = <Edge**>(malloc(sizeof(Edge*)*capacity))
 * 
 *     if theStack.elements == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Error. Could not allocate edge stack elements with capacity %s" %(capacity))
 * 
 */
  __pyx_t_1 = ((__pyx_v_theStack->elements == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":539
 * 
 *     if theStack.elements == NULL:
 *         logger.error("Error. Could not allocate edge stack elements with capacity %s" %(capacity))             # <<<<<<<<<<<<<<
 * 
 *     theStack.top = -1 # Empty
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_error); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_capacity); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_Error_Could_not_allocate_edge_st_2, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "assembler.pyx":541
 *         logger.error("Error. Could not allocate edge stack elements with capacity %s" %(capacity))
 * 
 *     theStack.top = -1 # Empty             # <<<<<<<<<<<<<<
 *     theStack.capacity = capacity
 *     return theStack
 */
  __pyx_v_theStack->top = -1;

  /* "assembler.pyx":542
 * 
 *     theStack.top = -1 # Empty
 *     theStack.capacity = capacity             # <<<<<<<<<<<<<<
 *     return theStack
 * 
 */
  __pyx_v_theStack->capacity = __pyx_v_capacity;

  /* "assembler.pyx":543
 *     theStack.top = -1 # Empty
 *     theStack.capacity = capacity
 *     return theStack             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_theStack;
  goto __pyx_L0;

  /* "assembler.pyx":527
 * ###################################################################################################
 * 
 * cdef EdgeStack* createEdgeStack(int capacity):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a stack for storing Edges.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("assembler.createEdgeStack", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":547
 * ###################################################################################################
 * 
 * cdef void destroyEdgeStack(EdgeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Clears up memory in stack. Does not destroy the
 */

static void __pyx_f_9assembler_destroyEdgeStack(__pyx_t_9assembler_EdgeStack *__pyx_v_theStack) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("destroyEdgeStack", 0);

  /* "assembler.pyx":552
 *     Edges.
 *     """
 *     free(theStack.elements)             # <<<<<<<<<<<<<<
 *     theStack.elements = NULL
 *     free(theStack)
 */
  free(__pyx_v_theStack->elements);

  /* "assembler.pyx":553
 *     """
 *     free(theStack.elements)
 *     theStack.elements = NULL             # <<<<<<<<<<<<<<
 *     free(theStack)
 *     theStack = NULL
 */
  __pyx_v_theStack->elements = NULL;

  /* "assembler.pyx":554
 *     free(theStack.elements)
 *     theStack.elements = NULL
 *     free(theStack)             # <<<<<<<<<<<<<<
 *     theStack = NULL
 * 
 */
  free(__pyx_v_theStack);

  /* "assembler.pyx":555
 *     theStack.elements = NULL
 *     free(theStack)
 *     theStack = NULL             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_v_theStack = NULL;

  /* "assembler.pyx":547
 * ###################################################################################################
 * 
 * cdef void destroyEdgeStack(EdgeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Clears up memory in stack. Does not destroy the
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":560
 * 
 * @cython.profile(False)
 * cdef int EdgeStack_IsEmpty(EdgeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is empty and 0 otherwise.
 */

static int __pyx_f_9assembler_EdgeStack_IsEmpty(__pyx_t_9assembler_EdgeStack *__pyx_v_theStack) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("EdgeStack_IsEmpty", 0);

  /* "assembler.pyx":564
 *     Return 1 if the stack is empty and 0 otherwise.
 *     """
 *     if theStack.top == -1:             # <<<<<<<<<<<<<<
 *         return 1
 *     else:
 */
  __pyx_t_1 = ((__pyx_v_theStack->top == -1) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":565
 *     """
 *     if theStack.top == -1:
 *         return 1             # <<<<<<<<<<<<<<
 *     else:
 *         return 0
 */
    __pyx_r = 1;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":567
 *         return 1
 *     else:
 *         return 0             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = 0;
    goto __pyx_L0;
  }

  /* "assembler.pyx":560
 * 
 * @cython.profile(False)
 * cdef int EdgeStack_IsEmpty(EdgeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is empty and 0 otherwise.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":572
 * 
 * @cython.profile(False)
 * cdef int EdgeStack_IsFull(EdgeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is full and 0 otherwise.
 */

static int __pyx_f_9assembler_EdgeStack_IsFull(__pyx_t_9assembler_EdgeStack *__pyx_v_theStack) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("EdgeStack_IsFull", 0);

  /* "assembler.pyx":576
 *     Return 1 if the stack is full and 0 otherwise.
 *     """
 *     if theStack.top == theStack.capacity - 1:             # <<<<<<<<<<<<<<
 *         return 1
 *     else:
 */
  __pyx_t_1 = ((__pyx_v_theStack->top == (__pyx_v_theStack->capacity - 1)) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":577
 *     """
 *     if theStack.top == theStack.capacity - 1:
 *         return 1             # <<<<<<<<<<<<<<
 *     else:
 *         return 0
 */
    __pyx_r = 1;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":579
 *         return 1
 *     else:
 *         return 0             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = 0;
    goto __pyx_L0;
  }

  /* "assembler.pyx":572
 * 
 * @cython.profile(False)
 * cdef int EdgeStack_IsFull(EdgeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Return 1 if the stack is full and 0 otherwise.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":583
 * ###################################################################################################
 * 
 * cdef void EdgeStack_Push(EdgeStack* theStack, Edge* element):             # <<<<<<<<<<<<<<
 *     """
 *     Add a new element to the stack. Elements always go on the top,
 */

static void __pyx_f_9assembler_EdgeStack_Push(__pyx_t_9assembler_EdgeStack *__pyx_v_theStack, __pyx_t_9assembler_Edge *__pyx_v_element) {
  __pyx_t_9assembler_Edge **__pyx_v_temp;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("EdgeStack_Push", 0);

  /* "assembler.pyx":588
 *     i.e. in the highest position. Realloc if necessary.
 *     """
 *     cdef Edge** temp = NULL             # <<<<<<<<<<<<<<
 * 
 *     # Need to realloc
 */
  __pyx_v_temp = NULL;

  /* "assembler.pyx":591
 * 
 *     # Need to realloc
 *     if EdgeStack_IsFull(theStack):             # <<<<<<<<<<<<<<
 *         temp = <Edge**>(realloc(theStack.elements, 2*sizeof(Edge*)*theStack.capacity))
 * 
 */
  __pyx_t_1 = (__pyx_f_9assembler_EdgeStack_IsFull(__pyx_v_theStack) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":592
 *     # Need to realloc
 *     if EdgeStack_IsFull(theStack):
 *         temp = <Edge**>(realloc(theStack.elements, 2*sizeof(Edge*)*theStack.capacity))             # <<<<<<<<<<<<<<
 * 
 *         if temp == NULL:
 */
    __pyx_v_temp = ((__pyx_t_9assembler_Edge **)realloc(__pyx_v_theStack->elements, ((2 * (sizeof(__pyx_t_9assembler_Edge *))) * __pyx_v_theStack->capacity)));

    /* "assembler.pyx":594
 *         temp = <Edge**>(realloc(theStack.elements, 2*sizeof(Edge*)*theStack.capacity))
 * 
 *         if temp == NULL:             # <<<<<<<<<<<<<<
 *             raise StandardError, "Could not re-allocate EdgeStack"
 *         else:
 */
    __pyx_t_1 = ((__pyx_v_temp == NULL) != 0);
    if (__pyx_t_1) {

      /* "assembler.pyx":595
 * 
 *         if temp == NULL:
 *             raise StandardError, "Could not re-allocate EdgeStack"             # <<<<<<<<<<<<<<
 *         else:
 *             theStack.elements = temp
 */
      __Pyx_Raise(__pyx_builtin_StandardError, __pyx_kp_s_Could_not_re_allocate_EdgeStack, 0, 0);
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 595; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    /*else*/ {

      /* "assembler.pyx":597
 *             raise StandardError, "Could not re-allocate EdgeStack"
 *         else:
 *             theStack.elements = temp             # <<<<<<<<<<<<<<
 *             theStack.capacity *= 2
 * 
 */
      __pyx_v_theStack->elements = __pyx_v_temp;

      /* "assembler.pyx":598
 *         else:
 *             theStack.elements = temp
 *             theStack.capacity *= 2             # <<<<<<<<<<<<<<
 * 
 *     theStack.top += 1
 */
      __pyx_v_theStack->capacity = (__pyx_v_theStack->capacity * 2);
    }
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":600
 *             theStack.capacity *= 2
 * 
 *     theStack.top += 1             # <<<<<<<<<<<<<<
 *     theStack.elements[theStack.top] = element
 * 
 */
  __pyx_v_theStack->top = (__pyx_v_theStack->top + 1);

  /* "assembler.pyx":601
 * 
 *     theStack.top += 1
 *     theStack.elements[theStack.top] = element             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  (__pyx_v_theStack->elements[__pyx_v_theStack->top]) = __pyx_v_element;

  /* "assembler.pyx":583
 * ###################################################################################################
 * 
 * cdef void EdgeStack_Push(EdgeStack* theStack, Edge* element):             # <<<<<<<<<<<<<<
 *     """
 *     Add a new element to the stack. Elements always go on the top,
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("assembler.EdgeStack_Push", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":605
 * ###################################################################################################
 * 
 * cdef Edge* EdgeStack_Pop(EdgeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Pop and return the top element from the stack.
 */

static __pyx_t_9assembler_Edge *__pyx_f_9assembler_EdgeStack_Pop(__pyx_t_9assembler_EdgeStack *__pyx_v_theStack) {
  __pyx_t_9assembler_Edge *__pyx_v_theEdge;
  __pyx_t_9assembler_Edge *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("EdgeStack_Pop", 0);

  /* "assembler.pyx":609
 *     Pop and return the top element from the stack.
 *     """
 *     cdef Edge* theEdge = NULL             # <<<<<<<<<<<<<<
 * 
 *     if EdgeStack_IsEmpty(theStack):
 */
  __pyx_v_theEdge = NULL;

  /* "assembler.pyx":611
 *     cdef Edge* theEdge = NULL
 * 
 *     if EdgeStack_IsEmpty(theStack):             # <<<<<<<<<<<<<<
 *         return NULL
 *     else:
 */
  __pyx_t_1 = (__pyx_f_9assembler_EdgeStack_IsEmpty(__pyx_v_theStack) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":612
 * 
 *     if EdgeStack_IsEmpty(theStack):
 *         return NULL             # <<<<<<<<<<<<<<
 *     else:
 *         theEdge = theStack.elements[theStack.top]
 */
    __pyx_r = NULL;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":614
 *         return NULL
 *     else:
 *         theEdge = theStack.elements[theStack.top]             # <<<<<<<<<<<<<<
 *         theStack.top -= 1
 *         return theEdge
 */
    __pyx_v_theEdge = (__pyx_v_theStack->elements[__pyx_v_theStack->top]);

    /* "assembler.pyx":615
 *     else:
 *         theEdge = theStack.elements[theStack.top]
 *         theStack.top -= 1             # <<<<<<<<<<<<<<
 *         return theEdge
 * 
 */
    __pyx_v_theStack->top = (__pyx_v_theStack->top - 1);

    /* "assembler.pyx":616
 *         theEdge = theStack.elements[theStack.top]
 *         theStack.top -= 1
 *         return theEdge             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = __pyx_v_theEdge;
    goto __pyx_L0;
  }

  /* "assembler.pyx":605
 * ###################################################################################################
 * 
 * cdef Edge* EdgeStack_Pop(EdgeStack* theStack):             # <<<<<<<<<<<<<<
 *     """
 *     Pop and return the top element from the stack.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":620
 * ###################################################################################################
 * 
 * cdef NodeDict* createNodeDict(int nBuckets):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a dictionary of kmer/void pointers.
 */

static __pyx_t_9assembler_NodeDict *__pyx_f_9assembler_createNodeDict(int __pyx_v_nBuckets) {
  __pyx_t_9assembler_NodeDict *__pyx_v_theDict;
  int __pyx_v_i;
  __pyx_t_9assembler_NodeDict *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createNodeDict", 0);

  /* "assembler.pyx":624
 *     Create and return a dictionary of kmer/void pointers.
 *     """
 *     cdef NodeDict* theDict = <NodeDict*>(malloc(sizeof(NodeDict)))             # <<<<<<<<<<<<<<
 * 
 *     if theDict == NULL:
 */
  __pyx_v_theDict = ((__pyx_t_9assembler_NodeDict *)malloc((sizeof(__pyx_t_9assembler_NodeDict))));

  /* "assembler.pyx":626
 *     cdef NodeDict* theDict = <NodeDict*>(malloc(sizeof(NodeDict)))
 * 
 *     if theDict == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Error. Could not NodeDict")
 * 
 */
  __pyx_t_1 = ((__pyx_v_theDict == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":627
 * 
 *     if theDict == NULL:
 *         logger.error("Error. Could not NodeDict")             # <<<<<<<<<<<<<<
 * 
 *     theDict.buckets = <Node***>(malloc(nBuckets*sizeof(Node**)))
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":629
 *         logger.error("Error. Could not NodeDict")
 * 
 *     theDict.buckets = <Node***>(malloc(nBuckets*sizeof(Node**)))             # <<<<<<<<<<<<<<
 * 
 *     if theDict.buckets == NULL:
 */
  __pyx_v_theDict->buckets = ((__pyx_t_9assembler_Node ***)malloc((__pyx_v_nBuckets * (sizeof(__pyx_t_9assembler_Node **)))));

  /* "assembler.pyx":631
 *     theDict.buckets = <Node***>(malloc(nBuckets*sizeof(Node**)))
 * 
 *     if theDict.buckets == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Error. Could not NodeDict.buckets of size %s" %(nBuckets))
 * 
 */
  __pyx_t_1 = ((__pyx_v_theDict->buckets == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":632
 * 
 *     if theDict.buckets == NULL:
 *         logger.error("Error. Could not NodeDict.buckets of size %s" %(nBuckets))             # <<<<<<<<<<<<<<
 * 
 *     theDict.bucketSize = <int*>(malloc(nBuckets*sizeof(int)))
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_nBuckets); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Error_Could_not_NodeDict_buckets, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "assembler.pyx":634
 *         logger.error("Error. Could not NodeDict.buckets of size %s" %(nBuckets))
 * 
 *     theDict.bucketSize = <int*>(malloc(nBuckets*sizeof(int)))             # <<<<<<<<<<<<<<
 * 
 *     if theDict.bucketSize == NULL:
 */
  __pyx_v_theDict->bucketSize = ((int *)malloc((__pyx_v_nBuckets * (sizeof(int)))));

  /* "assembler.pyx":636
 *     theDict.bucketSize = <int*>(malloc(nBuckets*sizeof(int)))
 * 
 *     if theDict.bucketSize == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Error. Could not NodeDict.bucketSize of size %s" %(nBuckets))
 * 
 */
  __pyx_t_1 = ((__pyx_v_theDict->bucketSize == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":637
 * 
 *     if theDict.bucketSize == NULL:
 *         logger.error("Error. Could not NodeDict.bucketSize of size %s" %(nBuckets))             # <<<<<<<<<<<<<<
 * 
 *     theDict.nBuckets = nBuckets
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_error); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_nBuckets); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_Error_Could_not_NodeDict_bucketS, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "assembler.pyx":639
 *         logger.error("Error. Could not NodeDict.bucketSize of size %s" %(nBuckets))
 * 
 *     theDict.nBuckets = nBuckets             # <<<<<<<<<<<<<<
 * 
 *     cdef int i = 0
 */
  __pyx_v_theDict->nBuckets = __pyx_v_nBuckets;

  /* "assembler.pyx":641
 *     theDict.nBuckets = nBuckets
 * 
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 * 
 *     for i in range(nBuckets):
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":643
 *     cdef int i = 0
 * 
 *     for i in range(nBuckets):             # <<<<<<<<<<<<<<
 *         theDict.buckets[i] = NULL
 *         theDict.bucketSize[i] = 0
 */
  __pyx_t_5 = __pyx_v_nBuckets;
  for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
    __pyx_v_i = __pyx_t_6;

    /* "assembler.pyx":644
 * 
 *     for i in range(nBuckets):
 *         theDict.buckets[i] = NULL             # <<<<<<<<<<<<<<
 *         theDict.bucketSize[i] = 0
 * 
 */
    (__pyx_v_theDict->buckets[__pyx_v_i]) = NULL;

    /* "assembler.pyx":645
 *     for i in range(nBuckets):
 *         theDict.buckets[i] = NULL
 *         theDict.bucketSize[i] = 0             # <<<<<<<<<<<<<<
 * 
 *     return theDict
 */
    (__pyx_v_theDict->bucketSize[__pyx_v_i]) = 0;
  }

  /* "assembler.pyx":647
 *         theDict.bucketSize[i] = 0
 * 
 *     return theDict             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_theDict;
  goto __pyx_L0;

  /* "assembler.pyx":620
 * ###################################################################################################
 * 
 * cdef NodeDict* createNodeDict(int nBuckets):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a dictionary of kmer/void pointers.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("assembler.createNodeDict", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":651
 * ###################################################################################################
 * 
 * cdef void destroyNodeDict(NodeDict* theDict):             # <<<<<<<<<<<<<<
 *     """
 *     free memory used by NodeDict.
 */

static void __pyx_f_9assembler_destroyNodeDict(__pyx_t_9assembler_NodeDict *__pyx_v_theDict) {
  int __pyx_v_i;
  CYTHON_UNUSED int __pyx_v_j;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("destroyNodeDict", 0);

  /* "assembler.pyx":655
 *     free memory used by NodeDict.
 *     """
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef int j = 0
 * 
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":656
 *     """
 *     cdef int i = 0
 *     cdef int j = 0             # <<<<<<<<<<<<<<
 * 
 *     for i in range(theDict.nBuckets):
 */
  __pyx_v_j = 0;

  /* "assembler.pyx":658
 *     cdef int j = 0
 * 
 *     for i in range(theDict.nBuckets):             # <<<<<<<<<<<<<<
 *         free(theDict.buckets[i])
 * 
 */
  __pyx_t_1 = __pyx_v_theDict->nBuckets;
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":659
 * 
 *     for i in range(theDict.nBuckets):
 *         free(theDict.buckets[i])             # <<<<<<<<<<<<<<
 * 
 *     free(theDict.buckets)
 */
    free((__pyx_v_theDict->buckets[__pyx_v_i]));
  }

  /* "assembler.pyx":661
 *         free(theDict.buckets[i])
 * 
 *     free(theDict.buckets)             # <<<<<<<<<<<<<<
 *     free(theDict.bucketSize)
 *     free(theDict)
 */
  free(__pyx_v_theDict->buckets);

  /* "assembler.pyx":662
 * 
 *     free(theDict.buckets)
 *     free(theDict.bucketSize)             # <<<<<<<<<<<<<<
 *     free(theDict)
 *     theDict = NULL
 */
  free(__pyx_v_theDict->bucketSize);

  /* "assembler.pyx":663
 *     free(theDict.buckets)
 *     free(theDict.bucketSize)
 *     free(theDict)             # <<<<<<<<<<<<<<
 *     theDict = NULL
 * 
 */
  free(__pyx_v_theDict);

  /* "assembler.pyx":664
 *     free(theDict.bucketSize)
 *     free(theDict)
 *     theDict = NULL             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_v_theDict = NULL;

  /* "assembler.pyx":651
 * ###################################################################################################
 * 
 * cdef void destroyNodeDict(NodeDict* theDict):             # <<<<<<<<<<<<<<
 *     """
 *     free memory used by NodeDict.
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":668
 * ###################################################################################################
 * 
 * cdef int NodeDict_FindOrInsert(NodeDict* theDict, Node** theNode, int keyLen, Node** nodeForUpdating):             # <<<<<<<<<<<<<<
 *     """
 *     Either return the element which is associated with the specified key, or
 */

static int __pyx_f_9assembler_NodeDict_FindOrInsert(__pyx_t_9assembler_NodeDict *__pyx_v_theDict, __pyx_t_9assembler_Node **__pyx_v_theNode, int __pyx_v_keyLen, __pyx_t_9assembler_Node **__pyx_v_nodeForUpdating) {
  int __pyx_v_hashValue;
  int __pyx_v_bucketSize;
  int __pyx_v_i;
  int __pyx_v_initialBucketSize;
  __pyx_t_9assembler_Node *__pyx_v_testNode;
  __pyx_t_9assembler_Node *__pyx_v_newNode;
  int __pyx_v_oldBucketSize;
  int __pyx_v_newBucketSize;
  __pyx_t_9assembler_Node **__pyx_v_temp;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("NodeDict_FindOrInsert", 0);

  /* "assembler.pyx":674
 *     and 1 if it was.
 *     """
 *     cdef int hashValue = hashKmer(theNode[0].sequence, keyLen) % theDict.nBuckets             # <<<<<<<<<<<<<<
 *     cdef int bucketSize = 0
 *     cdef int i = 0
 */
  __pyx_v_hashValue = (__pyx_f_9assembler_hashKmer((__pyx_v_theNode[0])->sequence, __pyx_v_keyLen) % __pyx_v_theDict->nBuckets);

  /* "assembler.pyx":675
 *     """
 *     cdef int hashValue = hashKmer(theNode[0].sequence, keyLen) % theDict.nBuckets
 *     cdef int bucketSize = 0             # <<<<<<<<<<<<<<
 *     cdef int i = 0
 *     cdef int initialBucketSize = 5
 */
  __pyx_v_bucketSize = 0;

  /* "assembler.pyx":676
 *     cdef int hashValue = hashKmer(theNode[0].sequence, keyLen) % theDict.nBuckets
 *     cdef int bucketSize = 0
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef int initialBucketSize = 5
 *     cdef Node* testNode = NULL
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":677
 *     cdef int bucketSize = 0
 *     cdef int i = 0
 *     cdef int initialBucketSize = 5             # <<<<<<<<<<<<<<
 *     cdef Node* testNode = NULL
 *     cdef Node* newNode = NULL
 */
  __pyx_v_initialBucketSize = 5;

  /* "assembler.pyx":678
 *     cdef int i = 0
 *     cdef int initialBucketSize = 5
 *     cdef Node* testNode = NULL             # <<<<<<<<<<<<<<
 *     cdef Node* newNode = NULL
 * 
 */
  __pyx_v_testNode = NULL;

  /* "assembler.pyx":679
 *     cdef int initialBucketSize = 5
 *     cdef Node* testNode = NULL
 *     cdef Node* newNode = NULL             # <<<<<<<<<<<<<<
 * 
 *     # Need to allocate new bucket
 */
  __pyx_v_newNode = NULL;

  /* "assembler.pyx":682
 * 
 *     # Need to allocate new bucket
 *     if theDict.buckets[hashValue] == NULL:             # <<<<<<<<<<<<<<
 *         theDict.buckets[hashValue] = <Node**>(malloc(initialBucketSize*sizeof(Node*)))
 * 
 */
  __pyx_t_1 = (((__pyx_v_theDict->buckets[__pyx_v_hashValue]) == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":683
 *     # Need to allocate new bucket
 *     if theDict.buckets[hashValue] == NULL:
 *         theDict.buckets[hashValue] = <Node**>(malloc(initialBucketSize*sizeof(Node*)))             # <<<<<<<<<<<<<<
 * 
 *         if theDict.buckets[hashValue] == NULL:
 */
    (__pyx_v_theDict->buckets[__pyx_v_hashValue]) = ((__pyx_t_9assembler_Node **)malloc((__pyx_v_initialBucketSize * (sizeof(__pyx_t_9assembler_Node *)))));

    /* "assembler.pyx":685
 *         theDict.buckets[hashValue] = <Node**>(malloc(initialBucketSize*sizeof(Node*)))
 * 
 *         if theDict.buckets[hashValue] == NULL:             # <<<<<<<<<<<<<<
 *             logger.error("Could not allocate hash table bucket with size %s" %(initialBucketSize))
 * 
 */
    __pyx_t_1 = (((__pyx_v_theDict->buckets[__pyx_v_hashValue]) == NULL) != 0);
    if (__pyx_t_1) {

      /* "assembler.pyx":686
 * 
 *         if theDict.buckets[hashValue] == NULL:
 *             logger.error("Could not allocate hash table bucket with size %s" %(initialBucketSize))             # <<<<<<<<<<<<<<
 * 
 *         # Always set to NULL first
 */
      __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 686; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 686; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_initialBucketSize); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 686; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Could_not_allocate_hash_table_bu, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 686; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 686; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 686; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      goto __pyx_L4;
    }
    __pyx_L4:;

    /* "assembler.pyx":689
 * 
 *         # Always set to NULL first
 *         for i in range(initialBucketSize):             # <<<<<<<<<<<<<<
 *             theDict.buckets[hashValue][i] = NULL
 * 
 */
    __pyx_t_5 = __pyx_v_initialBucketSize;
    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
      __pyx_v_i = __pyx_t_6;

      /* "assembler.pyx":690
 *         # Always set to NULL first
 *         for i in range(initialBucketSize):
 *             theDict.buckets[hashValue][i] = NULL             # <<<<<<<<<<<<<<
 * 
 *         newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)
 */
      ((__pyx_v_theDict->buckets[__pyx_v_hashValue])[__pyx_v_i]) = NULL;
    }

    /* "assembler.pyx":692
 *             theDict.buckets[hashValue][i] = NULL
 * 
 *         newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)             # <<<<<<<<<<<<<<
 *         theDict.buckets[hashValue][0] = newNode
 *         theDict.bucketSize[hashValue] = initialBucketSize
 */
    __pyx_v_newNode = __pyx_f_9assembler_createNode((__pyx_v_theNode[0])->sequence, (__pyx_v_theNode[0])->colours, (__pyx_v_theNode[0])->position, (__pyx_v_theNode[0])->kmerSize, (__pyx_v_theNode[0])->weight);

    /* "assembler.pyx":693
 * 
 *         newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)
 *         theDict.buckets[hashValue][0] = newNode             # <<<<<<<<<<<<<<
 *         theDict.bucketSize[hashValue] = initialBucketSize
 *         theNode[0] = newNode
 */
    ((__pyx_v_theDict->buckets[__pyx_v_hashValue])[0]) = __pyx_v_newNode;

    /* "assembler.pyx":694
 *         newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)
 *         theDict.buckets[hashValue][0] = newNode
 *         theDict.bucketSize[hashValue] = initialBucketSize             # <<<<<<<<<<<<<<
 *         theNode[0] = newNode
 *         return 0
 */
    (__pyx_v_theDict->bucketSize[__pyx_v_hashValue]) = __pyx_v_initialBucketSize;

    /* "assembler.pyx":695
 *         theDict.buckets[hashValue][0] = newNode
 *         theDict.bucketSize[hashValue] = initialBucketSize
 *         theNode[0] = newNode             # <<<<<<<<<<<<<<
 *         return 0
 * 
 */
    (__pyx_v_theNode[0]) = __pyx_v_newNode;

    /* "assembler.pyx":696
 *         theDict.bucketSize[hashValue] = initialBucketSize
 *         theNode[0] = newNode
 *         return 0             # <<<<<<<<<<<<<<
 * 
 *     # Bucket is there. Check all elements in bucket for match.
 */
    __pyx_r = 0;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":700
 *     # Bucket is there. Check all elements in bucket for match.
 *     else:
 *         bucketSize = theDict.bucketSize[hashValue]             # <<<<<<<<<<<<<<
 * 
 *         for i in range(bucketSize):
 */
    __pyx_v_bucketSize = (__pyx_v_theDict->bucketSize[__pyx_v_hashValue]);

    /* "assembler.pyx":702
 *         bucketSize = theDict.bucketSize[hashValue]
 * 
 *         for i in range(bucketSize):             # <<<<<<<<<<<<<<
 * 
 *             # Found empty slot. Insert new element
 */
    __pyx_t_5 = __pyx_v_bucketSize;
    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
      __pyx_v_i = __pyx_t_6;

      /* "assembler.pyx":705
 * 
 *             # Found empty slot. Insert new element
 *             if theDict.buckets[hashValue][i] == NULL:             # <<<<<<<<<<<<<<
 *                 newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)
 *                 theDict.buckets[hashValue][i] = newNode
 */
      __pyx_t_1 = ((((__pyx_v_theDict->buckets[__pyx_v_hashValue])[__pyx_v_i]) == NULL) != 0);
      if (__pyx_t_1) {

        /* "assembler.pyx":706
 *             # Found empty slot. Insert new element
 *             if theDict.buckets[hashValue][i] == NULL:
 *                 newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)             # <<<<<<<<<<<<<<
 *                 theDict.buckets[hashValue][i] = newNode
 *                 theNode[0] = newNode
 */
        __pyx_v_newNode = __pyx_f_9assembler_createNode((__pyx_v_theNode[0])->sequence, (__pyx_v_theNode[0])->colours, (__pyx_v_theNode[0])->position, (__pyx_v_theNode[0])->kmerSize, (__pyx_v_theNode[0])->weight);

        /* "assembler.pyx":707
 *             if theDict.buckets[hashValue][i] == NULL:
 *                 newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)
 *                 theDict.buckets[hashValue][i] = newNode             # <<<<<<<<<<<<<<
 *                 theNode[0] = newNode
 *                 return 0
 */
        ((__pyx_v_theDict->buckets[__pyx_v_hashValue])[__pyx_v_i]) = __pyx_v_newNode;

        /* "assembler.pyx":708
 *                 newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)
 *                 theDict.buckets[hashValue][i] = newNode
 *                 theNode[0] = newNode             # <<<<<<<<<<<<<<
 *                 return 0
 * 
 */
        (__pyx_v_theNode[0]) = __pyx_v_newNode;

        /* "assembler.pyx":709
 *                 theDict.buckets[hashValue][i] = newNode
 *                 theNode[0] = newNode
 *                 return 0             # <<<<<<<<<<<<<<
 * 
 *             # Check for match
 */
        __pyx_r = 0;
        goto __pyx_L0;
      }
      /*else*/ {

        /* "assembler.pyx":714
 *             else:
 *                 # Match. Return this element.
 *                 testNode = theDict.buckets[hashValue][i]             # <<<<<<<<<<<<<<
 *                 if theNode[0] == testNode or strncmp(theNode[0].sequence, testNode.sequence, keyLen) == 0:
 *                     nodeForUpdating[0] = testNode
 */
        __pyx_v_testNode = ((__pyx_v_theDict->buckets[__pyx_v_hashValue])[__pyx_v_i]);

        /* "assembler.pyx":715
 *                 # Match. Return this element.
 *                 testNode = theDict.buckets[hashValue][i]
 *                 if theNode[0] == testNode or strncmp(theNode[0].sequence, testNode.sequence, keyLen) == 0:             # <<<<<<<<<<<<<<
 *                     nodeForUpdating[0] = testNode
 *                     return 1
 */
        __pyx_t_1 = (((__pyx_v_theNode[0]) == __pyx_v_testNode) != 0);
        if (!__pyx_t_1) {
          __pyx_t_7 = ((strncmp((__pyx_v_theNode[0])->sequence, __pyx_v_testNode->sequence, __pyx_v_keyLen) == 0) != 0);
          __pyx_t_8 = __pyx_t_7;
        } else {
          __pyx_t_8 = __pyx_t_1;
        }
        if (__pyx_t_8) {

          /* "assembler.pyx":716
 *                 testNode = theDict.buckets[hashValue][i]
 *                 if theNode[0] == testNode or strncmp(theNode[0].sequence, testNode.sequence, keyLen) == 0:
 *                     nodeForUpdating[0] = testNode             # <<<<<<<<<<<<<<
 *                     return 1
 * 
 */
          (__pyx_v_nodeForUpdating[0]) = __pyx_v_testNode;

          /* "assembler.pyx":717
 *                 if theNode[0] == testNode or strncmp(theNode[0].sequence, testNode.sequence, keyLen) == 0:
 *                     nodeForUpdating[0] = testNode
 *                     return 1             # <<<<<<<<<<<<<<
 * 
 *     # If we get here, then we found no empty slots, and no matches. So we need to
 */
          __pyx_r = 1;
          goto __pyx_L0;
        }
      }
    }
  }

  /* "assembler.pyx":722
 *     # allocate more space in the relevant bucket and then insert the key/value pair
 *     # in the next available space..
 *     cdef int oldBucketSize = theDict.bucketSize[hashValue]             # <<<<<<<<<<<<<<
 *     cdef int newBucketSize = 2*oldBucketSize
 *     cdef Node** temp = <Node**>(realloc(theDict.buckets[hashValue], sizeof(Node*)*newBucketSize))
 */
  __pyx_v_oldBucketSize = (__pyx_v_theDict->bucketSize[__pyx_v_hashValue]);

  /* "assembler.pyx":723
 *     # in the next available space..
 *     cdef int oldBucketSize = theDict.bucketSize[hashValue]
 *     cdef int newBucketSize = 2*oldBucketSize             # <<<<<<<<<<<<<<
 *     cdef Node** temp = <Node**>(realloc(theDict.buckets[hashValue], sizeof(Node*)*newBucketSize))
 * 
 */
  __pyx_v_newBucketSize = (2 * __pyx_v_oldBucketSize);

  /* "assembler.pyx":724
 *     cdef int oldBucketSize = theDict.bucketSize[hashValue]
 *     cdef int newBucketSize = 2*oldBucketSize
 *     cdef Node** temp = <Node**>(realloc(theDict.buckets[hashValue], sizeof(Node*)*newBucketSize))             # <<<<<<<<<<<<<<
 * 
 *     if temp == NULL:
 */
  __pyx_v_temp = ((__pyx_t_9assembler_Node **)realloc((__pyx_v_theDict->buckets[__pyx_v_hashValue]), ((sizeof(__pyx_t_9assembler_Node *)) * __pyx_v_newBucketSize)));

  /* "assembler.pyx":726
 *     cdef Node** temp = <Node**>(realloc(theDict.buckets[hashValue], sizeof(Node*)*newBucketSize))
 * 
 *     if temp == NULL:             # <<<<<<<<<<<<<<
 *         raise StandardError, "Could not re-allocate bucket"
 *     else:
 */
  __pyx_t_8 = ((__pyx_v_temp == NULL) != 0);
  if (__pyx_t_8) {

    /* "assembler.pyx":727
 * 
 *     if temp == NULL:
 *         raise StandardError, "Could not re-allocate bucket"             # <<<<<<<<<<<<<<
 *     else:
 *         # Set new entries to NULL
 */
    __Pyx_Raise(__pyx_builtin_StandardError, __pyx_kp_s_Could_not_re_allocate_bucket, 0, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 727; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  /*else*/ {

    /* "assembler.pyx":730
 *     else:
 *         # Set new entries to NULL
 *         for i in range(oldBucketSize, newBucketSize):             # <<<<<<<<<<<<<<
 *             temp[i] = NULL
 * 
 */
    __pyx_t_5 = __pyx_v_newBucketSize;
    for (__pyx_t_6 = __pyx_v_oldBucketSize; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
      __pyx_v_i = __pyx_t_6;

      /* "assembler.pyx":731
 *         # Set new entries to NULL
 *         for i in range(oldBucketSize, newBucketSize):
 *             temp[i] = NULL             # <<<<<<<<<<<<<<
 * 
 *         newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)
 */
      (__pyx_v_temp[__pyx_v_i]) = NULL;
    }

    /* "assembler.pyx":733
 *             temp[i] = NULL
 * 
 *         newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)             # <<<<<<<<<<<<<<
 *         theDict.bucketSize[hashValue] = newBucketSize
 *         theDict.buckets[hashValue] = temp
 */
    __pyx_v_newNode = __pyx_f_9assembler_createNode((__pyx_v_theNode[0])->sequence, (__pyx_v_theNode[0])->colours, (__pyx_v_theNode[0])->position, (__pyx_v_theNode[0])->kmerSize, (__pyx_v_theNode[0])->weight);

    /* "assembler.pyx":734
 * 
 *         newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)
 *         theDict.bucketSize[hashValue] = newBucketSize             # <<<<<<<<<<<<<<
 *         theDict.buckets[hashValue] = temp
 *         theDict.buckets[hashValue][oldBucketSize] = newNode
 */
    (__pyx_v_theDict->bucketSize[__pyx_v_hashValue]) = __pyx_v_newBucketSize;

    /* "assembler.pyx":735
 *         newNode = createNode(theNode[0].sequence, theNode[0].colours, theNode[0].position, theNode[0].kmerSize, theNode[0].weight)
 *         theDict.bucketSize[hashValue] = newBucketSize
 *         theDict.buckets[hashValue] = temp             # <<<<<<<<<<<<<<
 *         theDict.buckets[hashValue][oldBucketSize] = newNode
 *         theNode[0] = newNode
 */
    (__pyx_v_theDict->buckets[__pyx_v_hashValue]) = __pyx_v_temp;

    /* "assembler.pyx":736
 *         theDict.bucketSize[hashValue] = newBucketSize
 *         theDict.buckets[hashValue] = temp
 *         theDict.buckets[hashValue][oldBucketSize] = newNode             # <<<<<<<<<<<<<<
 *         theNode[0] = newNode
 * 
 */
    ((__pyx_v_theDict->buckets[__pyx_v_hashValue])[__pyx_v_oldBucketSize]) = __pyx_v_newNode;

    /* "assembler.pyx":737
 *         theDict.buckets[hashValue] = temp
 *         theDict.buckets[hashValue][oldBucketSize] = newNode
 *         theNode[0] = newNode             # <<<<<<<<<<<<<<
 * 
 *     return 0
 */
    (__pyx_v_theNode[0]) = __pyx_v_newNode;
  }

  /* "assembler.pyx":739
 *         theNode[0] = newNode
 * 
 *     return 0             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = 0;
  goto __pyx_L0;

  /* "assembler.pyx":668
 * ###################################################################################################
 * 
 * cdef int NodeDict_FindOrInsert(NodeDict* theDict, Node** theNode, int keyLen, Node** nodeForUpdating):             # <<<<<<<<<<<<<<
 *     """
 *     Either return the element which is associated with the specified key, or
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("assembler.NodeDict_FindOrInsert", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":743
 * ###################################################################################################
 * 
 * cdef DeBruijnGraph* createDeBruijnGraph(int kmerSize, int nBuckets):             # <<<<<<<<<<<<<<
 *     """
 *     Allocate memory for graph data.
 */

static __pyx_t_9assembler_DeBruijnGraph *__pyx_f_9assembler_createDeBruijnGraph(int __pyx_v_kmerSize, int __pyx_v_nBuckets) {
  __pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph;
  __pyx_t_9assembler_DeBruijnGraph *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createDeBruijnGraph", 0);

  /* "assembler.pyx":747
 *     Allocate memory for graph data.
 *     """
 *     cdef DeBruijnGraph* theGraph = <DeBruijnGraph*>(malloc(sizeof(DeBruijnGraph)))             # <<<<<<<<<<<<<<
 * 
 *     if theGraph == NULL:
 */
  __pyx_v_theGraph = ((__pyx_t_9assembler_DeBruijnGraph *)malloc((sizeof(__pyx_t_9assembler_DeBruijnGraph))));

  /* "assembler.pyx":749
 *     cdef DeBruijnGraph* theGraph = <DeBruijnGraph*>(malloc(sizeof(DeBruijnGraph)))
 * 
 *     if theGraph == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Could not allocate memory for DeBruijnGraph")
 * 
 */
  __pyx_t_1 = ((__pyx_v_theGraph == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":750
 * 
 *     if theGraph == NULL:
 *         logger.error("Could not allocate memory for DeBruijnGraph")             # <<<<<<<<<<<<<<
 * 
 *     theGraph.kmerSize = kmerSize
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 750; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_error); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 750; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 750; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":752
 *         logger.error("Could not allocate memory for DeBruijnGraph")
 * 
 *     theGraph.kmerSize = kmerSize             # <<<<<<<<<<<<<<
 *     theGraph.allNodes = createNodeStack(nBuckets)
 *     theGraph.nodes = createNodeDict(nBuckets)
 */
  __pyx_v_theGraph->kmerSize = __pyx_v_kmerSize;

  /* "assembler.pyx":753
 * 
 *     theGraph.kmerSize = kmerSize
 *     theGraph.allNodes = createNodeStack(nBuckets)             # <<<<<<<<<<<<<<
 *     theGraph.nodes = createNodeDict(nBuckets)
 * 
 */
  __pyx_v_theGraph->allNodes = __pyx_f_9assembler_createNodeStack(__pyx_v_nBuckets);

  /* "assembler.pyx":754
 *     theGraph.kmerSize = kmerSize
 *     theGraph.allNodes = createNodeStack(nBuckets)
 *     theGraph.nodes = createNodeDict(nBuckets)             # <<<<<<<<<<<<<<
 * 
 *     return theGraph
 */
  __pyx_v_theGraph->nodes = __pyx_f_9assembler_createNodeDict(__pyx_v_nBuckets);

  /* "assembler.pyx":756
 *     theGraph.nodes = createNodeDict(nBuckets)
 * 
 *     return theGraph             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_theGraph;
  goto __pyx_L0;

  /* "assembler.pyx":743
 * ###################################################################################################
 * 
 * cdef DeBruijnGraph* createDeBruijnGraph(int kmerSize, int nBuckets):             # <<<<<<<<<<<<<<
 *     """
 *     Allocate memory for graph data.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_WriteUnraisable("assembler.createDeBruijnGraph", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":760
 * ###################################################################################################
 * 
 * cdef void destroyDeBruijnGraph(DeBruijnGraph* theGraph):             # <<<<<<<<<<<<<<
 *     """
 *     Free memory used by graph.
 */

static void __pyx_f_9assembler_destroyDeBruijnGraph(__pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph) {
  int __pyx_v_i;
  __Pyx_RefNannyDeclarations
  long __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("destroyDeBruijnGraph", 0);

  /* "assembler.pyx":764
 *     Free memory used by graph.
 *     """
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 * 
 *     # Destroy all nodes
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":767
 * 
 *     # Destroy all nodes
 *     for i in range(theGraph.allNodes.top + 1):             # <<<<<<<<<<<<<<
 *         destroyNode(theGraph.allNodes.elements[i])
 * 
 */
  __pyx_t_1 = (__pyx_v_theGraph->allNodes->top + 1);
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":768
 *     # Destroy all nodes
 *     for i in range(theGraph.allNodes.top + 1):
 *         destroyNode(theGraph.allNodes.elements[i])             # <<<<<<<<<<<<<<
 * 
 *     # These only hold pointers to memory which will be
 */
    __pyx_f_9assembler_destroyNode((__pyx_v_theGraph->allNodes->elements[__pyx_v_i]));
  }

  /* "assembler.pyx":772
 *     # These only hold pointers to memory which will be
 *     # freed elsewhere.
 *     destroyNodeStack(theGraph.allNodes)             # <<<<<<<<<<<<<<
 *     destroyNodeDict(theGraph.nodes)
 *     free(theGraph)
 */
  __pyx_f_9assembler_destroyNodeStack(__pyx_v_theGraph->allNodes);

  /* "assembler.pyx":773
 *     # freed elsewhere.
 *     destroyNodeStack(theGraph.allNodes)
 *     destroyNodeDict(theGraph.nodes)             # <<<<<<<<<<<<<<
 *     free(theGraph)
 * 
 */
  __pyx_f_9assembler_destroyNodeDict(__pyx_v_theGraph->nodes);

  /* "assembler.pyx":774
 *     destroyNodeStack(theGraph.allNodes)
 *     destroyNodeDict(theGraph.nodes)
 *     free(theGraph)             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  free(__pyx_v_theGraph);

  /* "assembler.pyx":760
 * ###################################################################################################
 * 
 * cdef void destroyDeBruijnGraph(DeBruijnGraph* theGraph):             # <<<<<<<<<<<<<<
 *     """
 *     Free memory used by graph.
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":778
 * ###################################################################################################
 * 
 * cdef int DeBruijnGraph_InsertOrUpdateNode(DeBruijnGraph* theGraph, Node** theNode):             # <<<<<<<<<<<<<<
 *     """
 *     Check if a node is already present. If it is, update it, otherwise
 */

static int __pyx_f_9assembler_DeBruijnGraph_InsertOrUpdateNode(__pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph, __pyx_t_9assembler_Node **__pyx_v_theNode) {
  __pyx_t_9assembler_Node *__pyx_v_nodeForUpdating;
  int __pyx_v_foundNode;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("DeBruijnGraph_InsertOrUpdateNode", 0);

  /* "assembler.pyx":783
 *     insert it. Return 1 if the node was inserted and 0 if it was updated.
 *     """
 *     cdef Node* nodeForUpdating = NULL             # <<<<<<<<<<<<<<
 *     cdef int foundNode = NodeDict_FindOrInsert(theGraph.nodes, theNode, theGraph.kmerSize, &nodeForUpdating)
 * 
 */
  __pyx_v_nodeForUpdating = NULL;

  /* "assembler.pyx":784
 *     """
 *     cdef Node* nodeForUpdating = NULL
 *     cdef int foundNode = NodeDict_FindOrInsert(theGraph.nodes, theNode, theGraph.kmerSize, &nodeForUpdating)             # <<<<<<<<<<<<<<
 * 
 *     # Need to create a new node, copying values from theNode
 */
  __pyx_v_foundNode = __pyx_f_9assembler_NodeDict_FindOrInsert(__pyx_v_theGraph->nodes, __pyx_v_theNode, __pyx_v_theGraph->kmerSize, (&__pyx_v_nodeForUpdating));

  /* "assembler.pyx":787
 * 
 *     # Need to create a new node, copying values from theNode
 *     if not foundNode:             # <<<<<<<<<<<<<<
 *         NodeStack_Push(theGraph.allNodes, theNode[0])
 *         return 1
 */
  __pyx_t_1 = ((!(__pyx_v_foundNode != 0)) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":788
 *     # Need to create a new node, copying values from theNode
 *     if not foundNode:
 *         NodeStack_Push(theGraph.allNodes, theNode[0])             # <<<<<<<<<<<<<<
 *         return 1
 * 
 */
    __pyx_f_9assembler_NodeStack_Push(__pyx_v_theGraph->allNodes, (__pyx_v_theNode[0]));

    /* "assembler.pyx":789
 *     if not foundNode:
 *         NodeStack_Push(theGraph.allNodes, theNode[0])
 *         return 1             # <<<<<<<<<<<<<<
 * 
 *     # Update existing node
 */
    __pyx_r = 1;
    goto __pyx_L0;
  }
  /*else*/ {

    /* "assembler.pyx":794
 *     else:
 *         # Update colours of nodes already in graph.
 *         nodeForUpdating.colours |= theNode[0].colours             # <<<<<<<<<<<<<<
 *         nodeForUpdating.weight += theNode[0].weight
 *         theNode[0] = nodeForUpdating
 */
    __pyx_v_nodeForUpdating->colours = (__pyx_v_nodeForUpdating->colours | (__pyx_v_theNode[0])->colours);

    /* "assembler.pyx":795
 *         # Update colours of nodes already in graph.
 *         nodeForUpdating.colours |= theNode[0].colours
 *         nodeForUpdating.weight += theNode[0].weight             # <<<<<<<<<<<<<<
 *         theNode[0] = nodeForUpdating
 *         return 0
 */
    __pyx_v_nodeForUpdating->weight = (__pyx_v_nodeForUpdating->weight + (__pyx_v_theNode[0])->weight);

    /* "assembler.pyx":796
 *         nodeForUpdating.colours |= theNode[0].colours
 *         nodeForUpdating.weight += theNode[0].weight
 *         theNode[0] = nodeForUpdating             # <<<<<<<<<<<<<<
 *         return 0
 * 
 */
    (__pyx_v_theNode[0]) = __pyx_v_nodeForUpdating;

    /* "assembler.pyx":797
 *         nodeForUpdating.weight += theNode[0].weight
 *         theNode[0] = nodeForUpdating
 *         return 0             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_r = 0;
    goto __pyx_L0;
  }

  /* "assembler.pyx":778
 * ###################################################################################################
 * 
 * cdef int DeBruijnGraph_InsertOrUpdateNode(DeBruijnGraph* theGraph, Node** theNode):             # <<<<<<<<<<<<<<
 *     """
 *     Check if a node is already present. If it is, update it, otherwise
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":801
 * ###################################################################################################
 * 
 * cdef void DeBruijnGraph_AddEdge(DeBruijnGraph* theGraph, Node* startNode, Node* endNode, double weight):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

static void __pyx_f_9assembler_DeBruijnGraph_AddEdge(__pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph, __pyx_t_9assembler_Node *__pyx_v_startNode, __pyx_t_9assembler_Node *__pyx_v_endNode, double __pyx_v_weight) {
  CYTHON_UNUSED double __pyx_v_oldWeight;
  CYTHON_UNUSED int __pyx_v_startNodeWasInserted;
  CYTHON_UNUSED int __pyx_v_endNodeWasInserted;
  __pyx_t_9assembler_Edge *__pyx_v_newEdge;
  int __pyx_v_i;
  __Pyx_RefNannyDeclarations
  double __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("DeBruijnGraph_AddEdge", 0);

  /* "assembler.pyx":804
 *     """
 *     """
 *     cdef double oldWeight = startNode.weight             # <<<<<<<<<<<<<<
 *     cdef int startNodeWasInserted = DeBruijnGraph_InsertOrUpdateNode(theGraph, &startNode)
 *     cdef int endNodeWasInserted = DeBruijnGraph_InsertOrUpdateNode(theGraph, &endNode)
 */
  __pyx_t_1 = __pyx_v_startNode->weight;
  __pyx_v_oldWeight = __pyx_t_1;

  /* "assembler.pyx":805
 *     """
 *     cdef double oldWeight = startNode.weight
 *     cdef int startNodeWasInserted = DeBruijnGraph_InsertOrUpdateNode(theGraph, &startNode)             # <<<<<<<<<<<<<<
 *     cdef int endNodeWasInserted = DeBruijnGraph_InsertOrUpdateNode(theGraph, &endNode)
 *     cdef Edge* newEdge = NULL
 */
  __pyx_v_startNodeWasInserted = __pyx_f_9assembler_DeBruijnGraph_InsertOrUpdateNode(__pyx_v_theGraph, (&__pyx_v_startNode));

  /* "assembler.pyx":806
 *     cdef double oldWeight = startNode.weight
 *     cdef int startNodeWasInserted = DeBruijnGraph_InsertOrUpdateNode(theGraph, &startNode)
 *     cdef int endNodeWasInserted = DeBruijnGraph_InsertOrUpdateNode(theGraph, &endNode)             # <<<<<<<<<<<<<<
 *     cdef Edge* newEdge = NULL
 * 
 */
  __pyx_v_endNodeWasInserted = __pyx_f_9assembler_DeBruijnGraph_InsertOrUpdateNode(__pyx_v_theGraph, (&__pyx_v_endNode));

  /* "assembler.pyx":807
 *     cdef int startNodeWasInserted = DeBruijnGraph_InsertOrUpdateNode(theGraph, &startNode)
 *     cdef int endNodeWasInserted = DeBruijnGraph_InsertOrUpdateNode(theGraph, &endNode)
 *     cdef Edge* newEdge = NULL             # <<<<<<<<<<<<<<
 * 
 *     cdef int i = 0
 */
  __pyx_v_newEdge = NULL;

  /* "assembler.pyx":809
 *     cdef Edge* newEdge = NULL
 * 
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 * 
 *     # Check all outgoing edges from startNode. If it has none, then make one for this edge. Otherwise,
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":813
 *     # Check all outgoing edges from startNode. If it has none, then make one for this edge. Otherwise,
 *     # check all existing edges for a match, and update accordingly.
 *     for i in range(4):             # <<<<<<<<<<<<<<
 *         if startNode.edges[i] == NULL:
 *             newEdge = createEdge(startNode, endNode, weight)
 */
  for (__pyx_t_2 = 0; __pyx_t_2 < 4; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":814
 *     # check all existing edges for a match, and update accordingly.
 *     for i in range(4):
 *         if startNode.edges[i] == NULL:             # <<<<<<<<<<<<<<
 *             newEdge = createEdge(startNode, endNode, weight)
 *             Node_AddEdge(startNode, newEdge)
 */
    __pyx_t_3 = (((__pyx_v_startNode->edges[__pyx_v_i]) == NULL) != 0);
    if (__pyx_t_3) {

      /* "assembler.pyx":815
 *     for i in range(4):
 *         if startNode.edges[i] == NULL:
 *             newEdge = createEdge(startNode, endNode, weight)             # <<<<<<<<<<<<<<
 *             Node_AddEdge(startNode, newEdge)
 *             break
 */
      __pyx_v_newEdge = __pyx_f_9assembler_createEdge(__pyx_v_startNode, __pyx_v_endNode, __pyx_v_weight);

      /* "assembler.pyx":816
 *         if startNode.edges[i] == NULL:
 *             newEdge = createEdge(startNode, endNode, weight)
 *             Node_AddEdge(startNode, newEdge)             # <<<<<<<<<<<<<<
 *             break
 *         elif startNode.edges[i].endNode == endNode:
 */
      __pyx_f_9assembler_Node_AddEdge(__pyx_v_startNode, __pyx_v_newEdge);

      /* "assembler.pyx":817
 *             newEdge = createEdge(startNode, endNode, weight)
 *             Node_AddEdge(startNode, newEdge)
 *             break             # <<<<<<<<<<<<<<
 *         elif startNode.edges[i].endNode == endNode:
 *             startNode.edges[i].weight += weight
 */
      goto __pyx_L4_break;
    }

    /* "assembler.pyx":818
 *             Node_AddEdge(startNode, newEdge)
 *             break
 *         elif startNode.edges[i].endNode == endNode:             # <<<<<<<<<<<<<<
 *             startNode.edges[i].weight += weight
 *             break
 */
    __pyx_t_3 = (((__pyx_v_startNode->edges[__pyx_v_i])->endNode == __pyx_v_endNode) != 0);
    if (__pyx_t_3) {

      /* "assembler.pyx":819
 *             break
 *         elif startNode.edges[i].endNode == endNode:
 *             startNode.edges[i].weight += weight             # <<<<<<<<<<<<<<
 *             break
 *         else:
 */
      __pyx_t_4 = __pyx_v_i;
      (__pyx_v_startNode->edges[__pyx_t_4])->weight = ((__pyx_v_startNode->edges[__pyx_t_4])->weight + __pyx_v_weight);

      /* "assembler.pyx":820
 *         elif startNode.edges[i].endNode == endNode:
 *             startNode.edges[i].weight += weight
 *             break             # <<<<<<<<<<<<<<
 *         else:
 *             continue
 */
      goto __pyx_L4_break;
    }
    /*else*/ {

      /* "assembler.pyx":822
 *             break
 *         else:
 *             continue             # <<<<<<<<<<<<<<
 *     else:
 *         pass # This only happens when there are Ns in the sequence.
 */
      goto __pyx_L3_continue;
    }
    __pyx_L3_continue:;
  }
  /*else*/ {
  }
  __pyx_L4_break:;

  /* "assembler.pyx":801
 * ###################################################################################################
 * 
 * cdef void DeBruijnGraph_AddEdge(DeBruijnGraph* theGraph, Node* startNode, Node* endNode, double weight):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":831
 * ###################################################################################################
 * 
 * cdef int dfsVisit(Node* theNode, double minWeight):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

static int __pyx_f_9assembler_dfsVisit(__pyx_t_9assembler_Node *__pyx_v_theNode, double __pyx_v_minWeight) {
  int __pyx_v_nEdges;
  int __pyx_v_i;
  __pyx_t_9assembler_Node *__pyx_v_nextNode;
  __pyx_t_9assembler_Edge *__pyx_v_edge;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  __pyx_t_9assembler_Node *__pyx_t_6;
  __Pyx_RefNannySetupContext("dfsVisit", 0);

  /* "assembler.pyx":834
 *     """
 *     """
 *     cdef int nEdges = theNode.nEdges             # <<<<<<<<<<<<<<
 *     cdef int i = 0
 *     cdef Node* nextNode = NULL
 */
  __pyx_t_1 = __pyx_v_theNode->nEdges;
  __pyx_v_nEdges = __pyx_t_1;

  /* "assembler.pyx":835
 *     """
 *     cdef int nEdges = theNode.nEdges
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef Node* nextNode = NULL
 *     cdef Edge* edge = NULL
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":836
 *     cdef int nEdges = theNode.nEdges
 *     cdef int i = 0
 *     cdef Node* nextNode = NULL             # <<<<<<<<<<<<<<
 *     cdef Edge* edge = NULL
 * 
 */
  __pyx_v_nextNode = NULL;

  /* "assembler.pyx":837
 *     cdef int i = 0
 *     cdef Node* nextNode = NULL
 *     cdef Edge* edge = NULL             # <<<<<<<<<<<<<<
 * 
 *     theNode.dfsColour = 'g'
 */
  __pyx_v_edge = NULL;

  /* "assembler.pyx":839
 *     cdef Edge* edge = NULL
 * 
 *     theNode.dfsColour = 'g'             # <<<<<<<<<<<<<<
 * 
 *     for i in range(nEdges):
 */
  __pyx_v_theNode->dfsColour = 'g';

  /* "assembler.pyx":841
 *     theNode.dfsColour = 'g'
 * 
 *     for i in range(nEdges):             # <<<<<<<<<<<<<<
 *         edge = theNode.edges[i]
 * 
 */
  __pyx_t_1 = __pyx_v_nEdges;
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":842
 * 
 *     for i in range(nEdges):
 *         edge = theNode.edges[i]             # <<<<<<<<<<<<<<
 * 
 *         # Ignore low-weight edges that are only in reads
 */
    __pyx_v_edge = (__pyx_v_theNode->edges[__pyx_v_i]);

    /* "assembler.pyx":845
 * 
 *         # Ignore low-weight edges that are only in reads
 *         if edge.endNode.colours == READ and edge.weight < minWeight:             # <<<<<<<<<<<<<<
 *             continue
 * 
 */
    __pyx_t_3 = ((__pyx_v_edge->endNode->colours == __pyx_v_9assembler_READ) != 0);
    if (__pyx_t_3) {
      __pyx_t_4 = ((__pyx_v_edge->weight < __pyx_v_minWeight) != 0);
      __pyx_t_5 = __pyx_t_4;
    } else {
      __pyx_t_5 = __pyx_t_3;
    }
    if (__pyx_t_5) {

      /* "assembler.pyx":846
 *         # Ignore low-weight edges that are only in reads
 *         if edge.endNode.colours == READ and edge.weight < minWeight:
 *             continue             # <<<<<<<<<<<<<<
 * 
 *         nextNode = edge.endNode
 */
      goto __pyx_L3_continue;
    }

    /* "assembler.pyx":848
 *             continue
 * 
 *         nextNode = edge.endNode             # <<<<<<<<<<<<<<
 * 
 *         if nextNode.dfsColour == 'w':
 */
    __pyx_t_6 = __pyx_v_edge->endNode;
    __pyx_v_nextNode = __pyx_t_6;

    /* "assembler.pyx":858
 *             else:
 *                 continue
 *         elif nextNode.dfsColour == 'g':             # <<<<<<<<<<<<<<
 *             # Found cycle
 *             #logger.debug("Found cycle. From %s to %s" %(theNode.position, nextNode.position))
 */
    switch (__pyx_v_nextNode->dfsColour) {

      /* "assembler.pyx":850
 *         nextNode = edge.endNode
 * 
 *         if nextNode.dfsColour == 'w':             # <<<<<<<<<<<<<<
 * 
 *             # Found cycle in this path
 */
      case 'w':

      /* "assembler.pyx":853
 * 
 *             # Found cycle in this path
 *             if dfsVisit(nextNode, minWeight) == 1:             # <<<<<<<<<<<<<<
 *                 return 1
 *             # This path ok. Go to next edge
 */
      __pyx_t_5 = ((__pyx_f_9assembler_dfsVisit(__pyx_v_nextNode, __pyx_v_minWeight) == 1) != 0);
      if (__pyx_t_5) {

        /* "assembler.pyx":854
 *             # Found cycle in this path
 *             if dfsVisit(nextNode, minWeight) == 1:
 *                 return 1             # <<<<<<<<<<<<<<
 *             # This path ok. Go to next edge
 *             else:
 */
        __pyx_r = 1;
        goto __pyx_L0;
      }
      /*else*/ {

        /* "assembler.pyx":857
 *             # This path ok. Go to next edge
 *             else:
 *                 continue             # <<<<<<<<<<<<<<
 *         elif nextNode.dfsColour == 'g':
 *             # Found cycle
 */
        goto __pyx_L3_continue;
      }
      break;

      /* "assembler.pyx":858
 *             else:
 *                 continue
 *         elif nextNode.dfsColour == 'g':             # <<<<<<<<<<<<<<
 *             # Found cycle
 *             #logger.debug("Found cycle. From %s to %s" %(theNode.position, nextNode.position))
 */
      case 'g':

      /* "assembler.pyx":861
 *             # Found cycle
 *             #logger.debug("Found cycle. From %s to %s" %(theNode.position, nextNode.position))
 *             return 1             # <<<<<<<<<<<<<<
 * 
 *         # Black node. Already explored past this node. Go to next edge.
 */
      __pyx_r = 1;
      goto __pyx_L0;
      break;
      default:

      /* "assembler.pyx":865
 *         # Black node. Already explored past this node. Go to next edge.
 *         else:
 *             continue             # <<<<<<<<<<<<<<
 * 
 *     # No cycles in any path reachable from this node.
 */
      goto __pyx_L3_continue;
      break;
    }
    __pyx_L3_continue:;
  }

  /* "assembler.pyx":868
 * 
 *     # No cycles in any path reachable from this node.
 *     theNode.dfsColour = 'b'             # <<<<<<<<<<<<<<
 *     return 0
 * 
 */
  __pyx_v_theNode->dfsColour = 'b';

  /* "assembler.pyx":869
 *     # No cycles in any path reachable from this node.
 *     theNode.dfsColour = 'b'
 *     return 0             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = 0;
  goto __pyx_L0;

  /* "assembler.pyx":831
 * ###################################################################################################
 * 
 * cdef int dfsVisit(Node* theNode, double minWeight):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":873
 * ###################################################################################################
 * 
 * cdef int detectCyclesInGraph_Recursive(DeBruijnGraph* theGraph, double minWeight):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

static int __pyx_f_9assembler_detectCyclesInGraph_Recursive(__pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph, double __pyx_v_minWeight) {
  __pyx_t_9assembler_Node **__pyx_v_allNodes;
  __pyx_t_9assembler_Node *__pyx_v_thisNode;
  CYTHON_UNUSED __pyx_t_9assembler_Node *__pyx_v_nextNode;
  int __pyx_v_i;
  CYTHON_UNUSED int __pyx_v_j;
  int __pyx_v_nNodes;
  int __pyx_v_foundCycle;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __pyx_t_9assembler_Node **__pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("detectCyclesInGraph_Recursive", 0);

  /* "assembler.pyx":876
 *     """
 *     """
 *     cdef Node** allNodes = theGraph.allNodes.elements             # <<<<<<<<<<<<<<
 *     cdef Node* thisNode = NULL
 *     cdef Node* nextNode = NULL
 */
  __pyx_t_1 = __pyx_v_theGraph->allNodes->elements;
  __pyx_v_allNodes = __pyx_t_1;

  /* "assembler.pyx":877
 *     """
 *     cdef Node** allNodes = theGraph.allNodes.elements
 *     cdef Node* thisNode = NULL             # <<<<<<<<<<<<<<
 *     cdef Node* nextNode = NULL
 *     cdef int i = 0
 */
  __pyx_v_thisNode = NULL;

  /* "assembler.pyx":878
 *     cdef Node** allNodes = theGraph.allNodes.elements
 *     cdef Node* thisNode = NULL
 *     cdef Node* nextNode = NULL             # <<<<<<<<<<<<<<
 *     cdef int i = 0
 *     cdef int j = 0
 */
  __pyx_v_nextNode = NULL;

  /* "assembler.pyx":879
 *     cdef Node* thisNode = NULL
 *     cdef Node* nextNode = NULL
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef int j = 0
 *     cdef int nNodes = theGraph.allNodes.top + 1
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":880
 *     cdef Node* nextNode = NULL
 *     cdef int i = 0
 *     cdef int j = 0             # <<<<<<<<<<<<<<
 *     cdef int nNodes = theGraph.allNodes.top + 1
 *     cdef int foundCycle = 0
 */
  __pyx_v_j = 0;

  /* "assembler.pyx":881
 *     cdef int i = 0
 *     cdef int j = 0
 *     cdef int nNodes = theGraph.allNodes.top + 1             # <<<<<<<<<<<<<<
 *     cdef int foundCycle = 0
 * 
 */
  __pyx_v_nNodes = (__pyx_v_theGraph->allNodes->top + 1);

  /* "assembler.pyx":882
 *     cdef int j = 0
 *     cdef int nNodes = theGraph.allNodes.top + 1
 *     cdef int foundCycle = 0             # <<<<<<<<<<<<<<
 * 
 *     for i in range(nNodes):
 */
  __pyx_v_foundCycle = 0;

  /* "assembler.pyx":884
 *     cdef int foundCycle = 0
 * 
 *     for i in range(nNodes):             # <<<<<<<<<<<<<<
 *         thisNode = allNodes[i]
 *         thisNode.dfsColour = 'w'
 */
  __pyx_t_2 = __pyx_v_nNodes;
  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
    __pyx_v_i = __pyx_t_3;

    /* "assembler.pyx":885
 * 
 *     for i in range(nNodes):
 *         thisNode = allNodes[i]             # <<<<<<<<<<<<<<
 *         thisNode.dfsColour = 'w'
 * 
 */
    __pyx_v_thisNode = (__pyx_v_allNodes[__pyx_v_i]);

    /* "assembler.pyx":886
 *     for i in range(nNodes):
 *         thisNode = allNodes[i]
 *         thisNode.dfsColour = 'w'             # <<<<<<<<<<<<<<
 * 
 *     for i in range(nNodes):
 */
    __pyx_v_thisNode->dfsColour = 'w';
  }

  /* "assembler.pyx":888
 *         thisNode.dfsColour = 'w'
 * 
 *     for i in range(nNodes):             # <<<<<<<<<<<<<<
 *         thisNode = allNodes[i]
 * 
 */
  __pyx_t_2 = __pyx_v_nNodes;
  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
    __pyx_v_i = __pyx_t_3;

    /* "assembler.pyx":889
 * 
 *     for i in range(nNodes):
 *         thisNode = allNodes[i]             # <<<<<<<<<<<<<<
 * 
 *         if thisNode.dfsColour == 'w':
 */
    __pyx_v_thisNode = (__pyx_v_allNodes[__pyx_v_i]);

    /* "assembler.pyx":891
 *         thisNode = allNodes[i]
 * 
 *         if thisNode.dfsColour == 'w':             # <<<<<<<<<<<<<<
 *             # Found cycle
 *             foundCycle = dfsVisit(thisNode, minWeight)
 */
    __pyx_t_4 = ((__pyx_v_thisNode->dfsColour == 'w') != 0);
    if (__pyx_t_4) {

      /* "assembler.pyx":893
 *         if thisNode.dfsColour == 'w':
 *             # Found cycle
 *             foundCycle = dfsVisit(thisNode, minWeight)             # <<<<<<<<<<<<<<
 * 
 *             if foundCycle == 1:
 */
      __pyx_v_foundCycle = __pyx_f_9assembler_dfsVisit(__pyx_v_thisNode, __pyx_v_minWeight);

      /* "assembler.pyx":895
 *             foundCycle = dfsVisit(thisNode, minWeight)
 * 
 *             if foundCycle == 1:             # <<<<<<<<<<<<<<
 *                 return True
 * 
 */
      __pyx_t_4 = ((__pyx_v_foundCycle == 1) != 0);
      if (__pyx_t_4) {

        /* "assembler.pyx":896
 * 
 *             if foundCycle == 1:
 *                 return True             # <<<<<<<<<<<<<<
 * 
 *     return False
 */
        __pyx_r = 1;
        goto __pyx_L0;
      }
      goto __pyx_L7;
    }
    __pyx_L7:;
  }

  /* "assembler.pyx":898
 *                 return True
 * 
 *     return False             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = 0;
  goto __pyx_L0;

  /* "assembler.pyx":873
 * ###################################################################################################
 * 
 * cdef int detectCyclesInGraph_Recursive(DeBruijnGraph* theGraph, double minWeight):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":902
 * ###################################################################################################
 * 
 * cdef int detectCyclesInGraph(DeBruijnGraph* theGraph, double minWeight):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

static int __pyx_f_9assembler_detectCyclesInGraph(__pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph, CYTHON_UNUSED double __pyx_v_minWeight) {
  __pyx_t_9assembler_Node *__pyx_v_thisNode;
  __pyx_t_9assembler_Node *__pyx_v_nextNode;
  __pyx_t_9assembler_Edge *__pyx_v_edge;
  int __pyx_v_i;
  int __pyx_v_j;
  int __pyx_v_nEdges;
  int __pyx_v_nNodes;
  __pyx_t_9assembler_Node **__pyx_v_allNodes;
  int __pyx_v_nFilledBuckets;
  int __pyx_v_nEntriesThisBucket;
  __pyx_t_9assembler_Node *__pyx_v_sourceNode;
  __pyx_t_9assembler_Node *__pyx_v_endNode;
  __pyx_t_9assembler_NodeStack *__pyx_v_theStack;
  CYTHON_UNUSED int __pyx_v_reachedEnd;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __pyx_t_9assembler_Node **__pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  __pyx_t_9assembler_Node *__pyx_t_12;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("detectCyclesInGraph", 0);

  /* "assembler.pyx":908
 *     cdef Node* nextNode
 *     cdef Edge* edge
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef int j = 0
 *     cdef int nEdges = 0
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":909
 *     cdef Edge* edge
 *     cdef int i = 0
 *     cdef int j = 0             # <<<<<<<<<<<<<<
 *     cdef int nEdges = 0
 *     cdef int nNodes = theGraph.allNodes.top + 1
 */
  __pyx_v_j = 0;

  /* "assembler.pyx":910
 *     cdef int i = 0
 *     cdef int j = 0
 *     cdef int nEdges = 0             # <<<<<<<<<<<<<<
 *     cdef int nNodes = theGraph.allNodes.top + 1
 *     cdef Node** allNodes = theGraph.allNodes.elements
 */
  __pyx_v_nEdges = 0;

  /* "assembler.pyx":911
 *     cdef int j = 0
 *     cdef int nEdges = 0
 *     cdef int nNodes = theGraph.allNodes.top + 1             # <<<<<<<<<<<<<<
 *     cdef Node** allNodes = theGraph.allNodes.elements
 * 
 */
  __pyx_v_nNodes = (__pyx_v_theGraph->allNodes->top + 1);

  /* "assembler.pyx":912
 *     cdef int nEdges = 0
 *     cdef int nNodes = theGraph.allNodes.top + 1
 *     cdef Node** allNodes = theGraph.allNodes.elements             # <<<<<<<<<<<<<<
 * 
 *     cdef int nFilledBuckets = 0
 */
  __pyx_t_1 = __pyx_v_theGraph->allNodes->elements;
  __pyx_v_allNodes = __pyx_t_1;

  /* "assembler.pyx":914
 *     cdef Node** allNodes = theGraph.allNodes.elements
 * 
 *     cdef int nFilledBuckets = 0             # <<<<<<<<<<<<<<
 *     cdef int nEntriesThisBucket = 0
 * 
 */
  __pyx_v_nFilledBuckets = 0;

  /* "assembler.pyx":915
 * 
 *     cdef int nFilledBuckets = 0
 *     cdef int nEntriesThisBucket = 0             # <<<<<<<<<<<<<<
 * 
 *     for i in range(theGraph.nodes.nBuckets):
 */
  __pyx_v_nEntriesThisBucket = 0;

  /* "assembler.pyx":917
 *     cdef int nEntriesThisBucket = 0
 * 
 *     for i in range(theGraph.nodes.nBuckets):             # <<<<<<<<<<<<<<
 *         if theGraph.nodes.buckets[i] != NULL:
 *             nFilledBuckets += 1
 */
  __pyx_t_2 = __pyx_v_theGraph->nodes->nBuckets;
  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
    __pyx_v_i = __pyx_t_3;

    /* "assembler.pyx":918
 * 
 *     for i in range(theGraph.nodes.nBuckets):
 *         if theGraph.nodes.buckets[i] != NULL:             # <<<<<<<<<<<<<<
 *             nFilledBuckets += 1
 *             for j in range(theGraph.nodes.bucketSize[i]):
 */
    __pyx_t_4 = (((__pyx_v_theGraph->nodes->buckets[__pyx_v_i]) != NULL) != 0);
    if (__pyx_t_4) {

      /* "assembler.pyx":919
 *     for i in range(theGraph.nodes.nBuckets):
 *         if theGraph.nodes.buckets[i] != NULL:
 *             nFilledBuckets += 1             # <<<<<<<<<<<<<<
 *             for j in range(theGraph.nodes.bucketSize[i]):
 *                 if theGraph.nodes.buckets[i][j] != NULL:
 */
      __pyx_v_nFilledBuckets = (__pyx_v_nFilledBuckets + 1);

      /* "assembler.pyx":920
 *         if theGraph.nodes.buckets[i] != NULL:
 *             nFilledBuckets += 1
 *             for j in range(theGraph.nodes.bucketSize[i]):             # <<<<<<<<<<<<<<
 *                 if theGraph.nodes.buckets[i][j] != NULL:
 *                     nEntriesThisBucket += 1
 */
      __pyx_t_5 = (__pyx_v_theGraph->nodes->bucketSize[__pyx_v_i]);
      for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
        __pyx_v_j = __pyx_t_6;

        /* "assembler.pyx":921
 *             nFilledBuckets += 1
 *             for j in range(theGraph.nodes.bucketSize[i]):
 *                 if theGraph.nodes.buckets[i][j] != NULL:             # <<<<<<<<<<<<<<
 *                     nEntriesThisBucket += 1
 *                 else:
 */
        __pyx_t_4 = ((((__pyx_v_theGraph->nodes->buckets[__pyx_v_i])[__pyx_v_j]) != NULL) != 0);
        if (__pyx_t_4) {

          /* "assembler.pyx":922
 *             for j in range(theGraph.nodes.bucketSize[i]):
 *                 if theGraph.nodes.buckets[i][j] != NULL:
 *                     nEntriesThisBucket += 1             # <<<<<<<<<<<<<<
 *                 else:
 *                     break
 */
          __pyx_v_nEntriesThisBucket = (__pyx_v_nEntriesThisBucket + 1);
          goto __pyx_L8;
        }
        /*else*/ {

          /* "assembler.pyx":924
 *                     nEntriesThisBucket += 1
 *                 else:
 *                     break             # <<<<<<<<<<<<<<
 * 
 *     logger.debug("nNodes = %s. nFilledBuckets = %s. mean entries/bucket = %s" %(nNodes, nFilledBuckets, float(nEntriesThisBucket)/nFilledBuckets))
 */
          goto __pyx_L7_break;
        }
        __pyx_L8:;
      }
      __pyx_L7_break:;
      goto __pyx_L5;
    }
    __pyx_L5:;
  }

  /* "assembler.pyx":926
 *                     break
 * 
 *     logger.debug("nNodes = %s. nFilledBuckets = %s. mean entries/bucket = %s" %(nNodes, nFilledBuckets, float(nEntriesThisBucket)/nFilledBuckets))             # <<<<<<<<<<<<<<
 *     qsort(allNodes, nNodes, sizeof(Node*), nodePosComp)
 * 
 */
  __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_debug); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_nNodes); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_9 = __Pyx_PyInt_From_int(__pyx_v_nFilledBuckets); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_9);
  __pyx_t_10 = PyFloat_FromDouble((((double)__pyx_v_nEntriesThisBucket) / ((double)__pyx_v_nFilledBuckets))); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_10);
  __pyx_t_11 = PyTuple_New(3); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_11);
  PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_7);
  __Pyx_GIVEREF(__pyx_t_7);
  PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_t_9);
  __Pyx_GIVEREF(__pyx_t_9);
  PyTuple_SET_ITEM(__pyx_t_11, 2, __pyx_t_10);
  __Pyx_GIVEREF(__pyx_t_10);
  __pyx_t_7 = 0;
  __pyx_t_9 = 0;
  __pyx_t_10 = 0;
  __pyx_t_10 = __Pyx_PyString_Format(__pyx_kp_s_nNodes_s_nFilledBuckets_s_mean_e, __pyx_t_11); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_10);
  __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
  __pyx_t_11 = PyTuple_New(1); if (unlikely(!__pyx_t_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_11);
  PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_10);
  __Pyx_GIVEREF(__pyx_t_10);
  __pyx_t_10 = 0;
  __pyx_t_10 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_11, NULL); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_10);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;

  /* "assembler.pyx":927
 * 
 *     logger.debug("nNodes = %s. nFilledBuckets = %s. mean entries/bucket = %s" %(nNodes, nFilledBuckets, float(nEntriesThisBucket)/nFilledBuckets))
 *     qsort(allNodes, nNodes, sizeof(Node*), nodePosComp)             # <<<<<<<<<<<<<<
 * 
 *     for i in range(nNodes):
 */
  qsort(__pyx_v_allNodes, __pyx_v_nNodes, (sizeof(__pyx_t_9assembler_Node *)), __pyx_f_9assembler_nodePosComp);

  /* "assembler.pyx":929
 *     qsort(allNodes, nNodes, sizeof(Node*), nodePosComp)
 * 
 *     for i in range(nNodes):             # <<<<<<<<<<<<<<
 *         thisNode = allNodes[i]
 *         thisNode.dfsColour = 'w'
 */
  __pyx_t_2 = __pyx_v_nNodes;
  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
    __pyx_v_i = __pyx_t_3;

    /* "assembler.pyx":930
 * 
 *     for i in range(nNodes):
 *         thisNode = allNodes[i]             # <<<<<<<<<<<<<<
 *         thisNode.dfsColour = 'w'
 * 
 */
    __pyx_v_thisNode = (__pyx_v_allNodes[__pyx_v_i]);

    /* "assembler.pyx":931
 *     for i in range(nNodes):
 *         thisNode = allNodes[i]
 *         thisNode.dfsColour = 'w'             # <<<<<<<<<<<<<<
 * 
 *     cdef Node* sourceNode = allNodes[0]
 */
    __pyx_v_thisNode->dfsColour = 'w';
  }

  /* "assembler.pyx":933
 *         thisNode.dfsColour = 'w'
 * 
 *     cdef Node* sourceNode = allNodes[0]             # <<<<<<<<<<<<<<
 *     cdef Node* endNode = allNodes[nNodes-1]
 *     cdef NodeStack* theStack = createNodeStack(nNodes)
 */
  __pyx_v_sourceNode = (__pyx_v_allNodes[0]);

  /* "assembler.pyx":934
 * 
 *     cdef Node* sourceNode = allNodes[0]
 *     cdef Node* endNode = allNodes[nNodes-1]             # <<<<<<<<<<<<<<
 *     cdef NodeStack* theStack = createNodeStack(nNodes)
 *     cdef int reachedEnd = False
 */
  __pyx_v_endNode = (__pyx_v_allNodes[(__pyx_v_nNodes - 1)]);

  /* "assembler.pyx":935
 *     cdef Node* sourceNode = allNodes[0]
 *     cdef Node* endNode = allNodes[nNodes-1]
 *     cdef NodeStack* theStack = createNodeStack(nNodes)             # <<<<<<<<<<<<<<
 *     cdef int reachedEnd = False
 * 
 */
  __pyx_v_theStack = __pyx_f_9assembler_createNodeStack(__pyx_v_nNodes);

  /* "assembler.pyx":936
 *     cdef Node* endNode = allNodes[nNodes-1]
 *     cdef NodeStack* theStack = createNodeStack(nNodes)
 *     cdef int reachedEnd = False             # <<<<<<<<<<<<<<
 * 
 *     NodeStack_Push(theStack, sourceNode)
 */
  __pyx_v_reachedEnd = 0;

  /* "assembler.pyx":938
 *     cdef int reachedEnd = False
 * 
 *     NodeStack_Push(theStack, sourceNode)             # <<<<<<<<<<<<<<
 * 
 *     while not NodeStack_IsEmpty(theStack):
 */
  __pyx_f_9assembler_NodeStack_Push(__pyx_v_theStack, __pyx_v_sourceNode);

  /* "assembler.pyx":940
 *     NodeStack_Push(theStack, sourceNode)
 * 
 *     while not NodeStack_IsEmpty(theStack):             # <<<<<<<<<<<<<<
 * 
 *         thisNode = NodeStack_Pop(theStack)
 */
  while (1) {
    __pyx_t_4 = ((!(__pyx_f_9assembler_NodeStack_IsEmpty(__pyx_v_theStack) != 0)) != 0);
    if (!__pyx_t_4) break;

    /* "assembler.pyx":942
 *     while not NodeStack_IsEmpty(theStack):
 * 
 *         thisNode = NodeStack_Pop(theStack)             # <<<<<<<<<<<<<<
 * 
 *         if thisNode.dfsColour == 'w':
 */
    __pyx_v_thisNode = __pyx_f_9assembler_NodeStack_Pop(__pyx_v_theStack);

    /* "assembler.pyx":946
 *         if thisNode.dfsColour == 'w':
 *             thisNode.dfsColour = 'g'
 *         elif thisNode.dfsColour == 'g':             # <<<<<<<<<<<<<<
 *             thisNode.dfsColour == 'b'
 *         else:
 */
    switch (__pyx_v_thisNode->dfsColour) {

      /* "assembler.pyx":944
 *         thisNode = NodeStack_Pop(theStack)
 * 
 *         if thisNode.dfsColour == 'w':             # <<<<<<<<<<<<<<
 *             thisNode.dfsColour = 'g'
 *         elif thisNode.dfsColour == 'g':
 */
      case 'w':

      /* "assembler.pyx":945
 * 
 *         if thisNode.dfsColour == 'w':
 *             thisNode.dfsColour = 'g'             # <<<<<<<<<<<<<<
 *         elif thisNode.dfsColour == 'g':
 *             thisNode.dfsColour == 'b'
 */
      __pyx_v_thisNode->dfsColour = 'g';
      break;

      /* "assembler.pyx":946
 *         if thisNode.dfsColour == 'w':
 *             thisNode.dfsColour = 'g'
 *         elif thisNode.dfsColour == 'g':             # <<<<<<<<<<<<<<
 *             thisNode.dfsColour == 'b'
 *         else:
 */
      case 'g':

      /* "assembler.pyx":947
 *             thisNode.dfsColour = 'g'
 *         elif thisNode.dfsColour == 'g':
 *             thisNode.dfsColour == 'b'             # <<<<<<<<<<<<<<
 *         else:
 *             pass
 */
      (__pyx_v_thisNode->dfsColour == 'b');
      break;
      default:
      break;
    }

    /* "assembler.pyx":952
 * 
 * 
 *         nEdges = thisNode.nEdges             # <<<<<<<<<<<<<<
 * 
 *         for i in range(nEdges):
 */
    __pyx_t_2 = __pyx_v_thisNode->nEdges;
    __pyx_v_nEdges = __pyx_t_2;

    /* "assembler.pyx":954
 *         nEdges = thisNode.nEdges
 * 
 *         for i in range(nEdges):             # <<<<<<<<<<<<<<
 *             edge = thisNode.edges[i]
 *             nextNode = edge.endNode
 */
    __pyx_t_2 = __pyx_v_nEdges;
    for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
      __pyx_v_i = __pyx_t_3;

      /* "assembler.pyx":955
 * 
 *         for i in range(nEdges):
 *             edge = thisNode.edges[i]             # <<<<<<<<<<<<<<
 *             nextNode = edge.endNode
 * 
 */
      __pyx_v_edge = (__pyx_v_thisNode->edges[__pyx_v_i]);

      /* "assembler.pyx":956
 *         for i in range(nEdges):
 *             edge = thisNode.edges[i]
 *             nextNode = edge.endNode             # <<<<<<<<<<<<<<
 * 
 *             # TODO: temp hack. Replace with Nodes_Equal later
 */
      __pyx_t_12 = __pyx_v_edge->endNode;
      __pyx_v_nextNode = __pyx_t_12;

      /* "assembler.pyx":959
 * 
 *             # TODO: temp hack. Replace with Nodes_Equal later
 *             if Node_Equal(nextNode, endNode):             # <<<<<<<<<<<<<<
 *                 reachedEnd = True
 * 
 */
      __pyx_t_4 = (__pyx_f_9assembler_Node_Equal(__pyx_v_nextNode, __pyx_v_endNode) != 0);
      if (__pyx_t_4) {

        /* "assembler.pyx":960
 *             # TODO: temp hack. Replace with Nodes_Equal later
 *             if Node_Equal(nextNode, endNode):
 *                 reachedEnd = True             # <<<<<<<<<<<<<<
 * 
 *             if nextNode.dfsColour == 'w':
 */
        __pyx_v_reachedEnd = 1;
        goto __pyx_L15;
      }
      __pyx_L15:;

      /* "assembler.pyx":966
 * 
 *             # Found a cycle
 *             elif nextNode.dfsColour == 'g':             # <<<<<<<<<<<<<<
 *                 destroyNodeStack(theStack)
 *                 return True
 */
      switch (__pyx_v_nextNode->dfsColour) {

        /* "assembler.pyx":962
 *                 reachedEnd = True
 * 
 *             if nextNode.dfsColour == 'w':             # <<<<<<<<<<<<<<
 *                 NodeStack_Push(theStack, nextNode)
 * 
 */
        case 'w':

        /* "assembler.pyx":963
 * 
 *             if nextNode.dfsColour == 'w':
 *                 NodeStack_Push(theStack, nextNode)             # <<<<<<<<<<<<<<
 * 
 *             # Found a cycle
 */
        __pyx_f_9assembler_NodeStack_Push(__pyx_v_theStack, __pyx_v_nextNode);
        break;

        /* "assembler.pyx":966
 * 
 *             # Found a cycle
 *             elif nextNode.dfsColour == 'g':             # <<<<<<<<<<<<<<
 *                 destroyNodeStack(theStack)
 *                 return True
 */
        case 'g':

        /* "assembler.pyx":967
 *             # Found a cycle
 *             elif nextNode.dfsColour == 'g':
 *                 destroyNodeStack(theStack)             # <<<<<<<<<<<<<<
 *                 return True
 * 
 */
        __pyx_f_9assembler_destroyNodeStack(__pyx_v_theStack);

        /* "assembler.pyx":968
 *             elif nextNode.dfsColour == 'g':
 *                 destroyNodeStack(theStack)
 *                 return True             # <<<<<<<<<<<<<<
 * 
 *             else:
 */
        __pyx_r = 1;
        goto __pyx_L0;
        break;
        default:
        break;
      }
    }
  }

  /* "assembler.pyx":973
 *                 pass
 * 
 *     destroyNodeStack(theStack)             # <<<<<<<<<<<<<<
 *     return False
 * 
 */
  __pyx_f_9assembler_destroyNodeStack(__pyx_v_theStack);

  /* "assembler.pyx":974
 * 
 *     destroyNodeStack(theStack)
 *     return False             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = 0;
  goto __pyx_L0;

  /* "assembler.pyx":902
 * ###################################################################################################
 * 
 * cdef int detectCyclesInGraph(DeBruijnGraph* theGraph, double minWeight):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_WriteUnraisable("assembler.detectCyclesInGraph", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":978
 * ###################################################################################################
 * 
 * cdef char* createSequenceFromPath(Path* thePath):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a string representation of the sequence of a specific path
 */

static char *__pyx_f_9assembler_createSequenceFromPath(__pyx_t_9assembler_Path *__pyx_v_thePath) {
  int __pyx_v_nNodes;
  char *__pyx_v_theString;
  int __pyx_v_i;
  char *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("createSequenceFromPath", 0);

  /* "assembler.pyx":983
 *     through the graph.
 *     """
 *     cdef int nNodes = thePath.nNodes             # <<<<<<<<<<<<<<
 *     cdef char* theString = <char*>(malloc( (nNodes+1)*sizeof(char)))
 * 
 */
  __pyx_t_1 = __pyx_v_thePath->nNodes;
  __pyx_v_nNodes = __pyx_t_1;

  /* "assembler.pyx":984
 *     """
 *     cdef int nNodes = thePath.nNodes
 *     cdef char* theString = <char*>(malloc( (nNodes+1)*sizeof(char)))             # <<<<<<<<<<<<<<
 * 
 *     if theString == NULL:
 */
  __pyx_v_theString = ((char *)malloc(((__pyx_v_nNodes + 1) * (sizeof(char)))));

  /* "assembler.pyx":986
 *     cdef char* theString = <char*>(malloc( (nNodes+1)*sizeof(char)))
 * 
 *     if theString == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Could not allocate memory for string of size %s" %(nNodes+1))
 * 
 */
  __pyx_t_2 = ((__pyx_v_theString == NULL) != 0);
  if (__pyx_t_2) {

    /* "assembler.pyx":987
 * 
 *     if theString == NULL:
 *         logger.error("Could not allocate memory for string of size %s" %(nNodes+1))             # <<<<<<<<<<<<<<
 * 
 *     cdef int i = 0
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_error); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyInt_From_long((__pyx_v_nNodes + 1)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Could_not_allocate_memory_for_st, __pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_5);
    __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":989
 *         logger.error("Could not allocate memory for string of size %s" %(nNodes+1))
 * 
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 * 
 *     for i in range(nNodes):
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":991
 *     cdef int i = 0
 * 
 *     for i in range(nNodes):             # <<<<<<<<<<<<<<
 *         theString[i] = thePath.nodes.elements[i].sequence[0]
 * 
 */
  __pyx_t_1 = __pyx_v_nNodes;
  for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_1; __pyx_t_6+=1) {
    __pyx_v_i = __pyx_t_6;

    /* "assembler.pyx":992
 * 
 *     for i in range(nNodes):
 *         theString[i] = thePath.nodes.elements[i].sequence[0]             # <<<<<<<<<<<<<<
 * 
 *     theString[nNodes] = 0
 */
    (__pyx_v_theString[__pyx_v_i]) = ((__pyx_v_thePath->nodes->elements[__pyx_v_i])->sequence[0]);
  }

  /* "assembler.pyx":994
 *         theString[i] = thePath.nodes.elements[i].sequence[0]
 * 
 *     theString[nNodes] = 0             # <<<<<<<<<<<<<<
 *     return theString
 * 
 */
  (__pyx_v_theString[__pyx_v_nNodes]) = 0;

  /* "assembler.pyx":995
 * 
 *     theString[nNodes] = 0
 *     return theString             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_theString;
  goto __pyx_L0;

  /* "assembler.pyx":978
 * ###################################################################################################
 * 
 * cdef char* createSequenceFromPath(Path* thePath):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a string representation of the sequence of a specific path
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_WriteUnraisable("assembler.createSequenceFromPath", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":999
 * ###################################################################################################
 * 
 * cdef int checkPathForCycles(Path* thePath):             # <<<<<<<<<<<<<<
 *     """
 *     Check if this path contains a cycle.
 */

static int __pyx_f_9assembler_checkPathForCycles(__pyx_t_9assembler_Path *__pyx_v_thePath) {
  int __pyx_v_nNodes;
  int __pyx_v_i;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  __Pyx_RefNannySetupContext("checkPathForCycles", 0);

  /* "assembler.pyx":1003
 *     Check if this path contains a cycle.
 *     """
 *     cdef int nNodes = thePath.nNodes             # <<<<<<<<<<<<<<
 *     cdef int i = 0
 * 
 */
  __pyx_t_1 = __pyx_v_thePath->nNodes;
  __pyx_v_nNodes = __pyx_t_1;

  /* "assembler.pyx":1004
 *     """
 *     cdef int nNodes = thePath.nNodes
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 * 
 *     #logger.debug("Checking path with %s nodes for cycles" %(nNodes))
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":1009
 * 
 *     # Set all dfs colours to white
 *     for i in range(nNodes):             # <<<<<<<<<<<<<<
 *         thePath.nodes.elements[i].dfsColour = 'w'
 * 
 */
  __pyx_t_1 = __pyx_v_nNodes;
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":1010
 *     # Set all dfs colours to white
 *     for i in range(nNodes):
 *         thePath.nodes.elements[i].dfsColour = 'w'             # <<<<<<<<<<<<<<
 * 
 *     # Check all nodes in order. If we see the same node twice, then
 */
    (__pyx_v_thePath->nodes->elements[__pyx_v_i])->dfsColour = 'w';
  }

  /* "assembler.pyx":1015
 *     # there is a cycle. If we get to the end without seeing any nodes twice,
 *     # then no cycle.
 *     for i in range(nNodes):             # <<<<<<<<<<<<<<
 *         if thePath.nodes.elements[i].dfsColour == 'w':
 *             thePath.nodes.elements[i].dfsColour = 'g'
 */
  __pyx_t_1 = __pyx_v_nNodes;
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":1016
 *     # then no cycle.
 *     for i in range(nNodes):
 *         if thePath.nodes.elements[i].dfsColour == 'w':             # <<<<<<<<<<<<<<
 *             thePath.nodes.elements[i].dfsColour = 'g'
 *         else:
 */
    __pyx_t_3 = (((__pyx_v_thePath->nodes->elements[__pyx_v_i])->dfsColour == 'w') != 0);
    if (__pyx_t_3) {

      /* "assembler.pyx":1017
 *     for i in range(nNodes):
 *         if thePath.nodes.elements[i].dfsColour == 'w':
 *             thePath.nodes.elements[i].dfsColour = 'g'             # <<<<<<<<<<<<<<
 *         else:
 *             #logger.debug("Found cycle")
 */
      (__pyx_v_thePath->nodes->elements[__pyx_v_i])->dfsColour = 'g';
      goto __pyx_L7;
    }
    /*else*/ {

      /* "assembler.pyx":1020
 *         else:
 *             #logger.debug("Found cycle")
 *             return 1             # <<<<<<<<<<<<<<
 * 
 *     #logger.debug("No cycles")
 */
      __pyx_r = 1;
      goto __pyx_L0;
    }
    __pyx_L7:;
  }

  /* "assembler.pyx":1023
 * 
 *     #logger.debug("No cycles")
 *     return 0             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = 0;
  goto __pyx_L0;

  /* "assembler.pyx":999
 * ###################################################################################################
 * 
 * cdef int checkPathForCycles(Path* thePath):             # <<<<<<<<<<<<<<
 *     """
 *     Check if this path contains a cycle.
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":1027
 * ###################################################################################################
 * 
 * cdef PathStack* getVariantPathsThroughGraphFromNode(DeBruijnGraph* theGraph, Path* thePath, double minWeight):             # <<<<<<<<<<<<<<
 *     """
 *     Check all valid paths through the graph starting at the last node in "thePath". If any path
 */

static __pyx_t_9assembler_PathStack *__pyx_f_9assembler_getVariantPathsThroughGraphFromNode(__pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph, __pyx_t_9assembler_Path *__pyx_v_thePath, double __pyx_v_minWeight) {
  __pyx_t_9assembler_PathStack *__pyx_v_thePathStack;
  __pyx_t_9assembler_PathStack *__pyx_v_finishedPaths;
  __pyx_t_9assembler_Path *__pyx_v_pathSoFar;
  __pyx_t_9assembler_Node *__pyx_v_endSoFar;
  __pyx_t_9assembler_Node *__pyx_v_newEnd;
  __pyx_t_9assembler_Edge *__pyx_v_theEdge;
  int __pyx_v_nEdgesThisNode;
  int __pyx_v_i;
  int __pyx_v_j;
  int __pyx_v_hasCycle;
  __pyx_t_9assembler_Path *__pyx_v_newPath;
  __pyx_t_9assembler_PathStack *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  __pyx_t_9assembler_Node *__pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  double __pyx_t_10;
  __Pyx_RefNannySetupContext("getVariantPathsThroughGraphFromNode", 0);

  /* "assembler.pyx":1033
 *     path never returns to the reference, but is sufficiently long, then add this to the list.
 *     """
 *     cdef PathStack* thePathStack = createPathStack(10)             # <<<<<<<<<<<<<<
 *     cdef PathStack* finishedPaths = createPathStack(10)
 *     cdef Path* pathSoFar = NULL
 */
  __pyx_v_thePathStack = __pyx_f_9assembler_createPathStack(10);

  /* "assembler.pyx":1034
 *     """
 *     cdef PathStack* thePathStack = createPathStack(10)
 *     cdef PathStack* finishedPaths = createPathStack(10)             # <<<<<<<<<<<<<<
 *     cdef Path* pathSoFar = NULL
 *     cdef Node* endSoFar = NULL
 */
  __pyx_v_finishedPaths = __pyx_f_9assembler_createPathStack(10);

  /* "assembler.pyx":1035
 *     cdef PathStack* thePathStack = createPathStack(10)
 *     cdef PathStack* finishedPaths = createPathStack(10)
 *     cdef Path* pathSoFar = NULL             # <<<<<<<<<<<<<<
 *     cdef Node* endSoFar = NULL
 *     cdef Node* newEnd = NULL
 */
  __pyx_v_pathSoFar = NULL;

  /* "assembler.pyx":1036
 *     cdef PathStack* finishedPaths = createPathStack(10)
 *     cdef Path* pathSoFar = NULL
 *     cdef Node* endSoFar = NULL             # <<<<<<<<<<<<<<
 *     cdef Node* newEnd = NULL
 *     cdef Edge* theEdge = NULL
 */
  __pyx_v_endSoFar = NULL;

  /* "assembler.pyx":1037
 *     cdef Path* pathSoFar = NULL
 *     cdef Node* endSoFar = NULL
 *     cdef Node* newEnd = NULL             # <<<<<<<<<<<<<<
 *     cdef Edge* theEdge = NULL
 *     cdef int nEdgesThisNode = 0
 */
  __pyx_v_newEnd = NULL;

  /* "assembler.pyx":1038
 *     cdef Node* endSoFar = NULL
 *     cdef Node* newEnd = NULL
 *     cdef Edge* theEdge = NULL             # <<<<<<<<<<<<<<
 *     cdef int nEdgesThisNode = 0
 *     cdef int i = 0
 */
  __pyx_v_theEdge = NULL;

  /* "assembler.pyx":1039
 *     cdef Node* newEnd = NULL
 *     cdef Edge* theEdge = NULL
 *     cdef int nEdgesThisNode = 0             # <<<<<<<<<<<<<<
 *     cdef int i = 0
 *     cdef int j = 0
 */
  __pyx_v_nEdgesThisNode = 0;

  /* "assembler.pyx":1040
 *     cdef Edge* theEdge = NULL
 *     cdef int nEdgesThisNode = 0
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef int j = 0
 *     cdef int hasCycle = 0
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":1041
 *     cdef int nEdgesThisNode = 0
 *     cdef int i = 0
 *     cdef int j = 0             # <<<<<<<<<<<<<<
 *     cdef int hasCycle = 0
 * 
 */
  __pyx_v_j = 0;

  /* "assembler.pyx":1042
 *     cdef int i = 0
 *     cdef int j = 0
 *     cdef int hasCycle = 0             # <<<<<<<<<<<<<<
 * 
 *     PathStack_Push(thePathStack, thePath)
 */
  __pyx_v_hasCycle = 0;

  /* "assembler.pyx":1044
 *     cdef int hasCycle = 0
 * 
 *     PathStack_Push(thePathStack, thePath)             # <<<<<<<<<<<<<<
 * 
 *     while not PathStack_IsEmpty(thePathStack):
 */
  __pyx_f_9assembler_PathStack_Push(__pyx_v_thePathStack, __pyx_v_thePath);

  /* "assembler.pyx":1046
 *     PathStack_Push(thePathStack, thePath)
 * 
 *     while not PathStack_IsEmpty(thePathStack):             # <<<<<<<<<<<<<<
 * 
 *         pathSoFar = PathStack_Pop(thePathStack)
 */
  while (1) {
    __pyx_t_1 = ((!(__pyx_f_9assembler_PathStack_IsEmpty(__pyx_v_thePathStack) != 0)) != 0);
    if (!__pyx_t_1) break;

    /* "assembler.pyx":1048
 *     while not PathStack_IsEmpty(thePathStack):
 * 
 *         pathSoFar = PathStack_Pop(thePathStack)             # <<<<<<<<<<<<<<
 *         endSoFar = pathSoFar.nodes.elements[pathSoFar.nNodes-1]
 * 
 */
    __pyx_v_pathSoFar = __pyx_f_9assembler_PathStack_Pop(__pyx_v_thePathStack);

    /* "assembler.pyx":1049
 * 
 *         pathSoFar = PathStack_Pop(thePathStack)
 *         endSoFar = pathSoFar.nodes.elements[pathSoFar.nNodes-1]             # <<<<<<<<<<<<<<
 * 
 *         # TODO: Replace with maxHaplotypes??
 */
    __pyx_v_endSoFar = (__pyx_v_pathSoFar->nodes->elements[(__pyx_v_pathSoFar->nNodes - 1)]);

    /* "assembler.pyx":1052
 * 
 *         # TODO: Replace with maxHaplotypes??
 *         if thePathStack.top + 1 > 20 or finishedPaths.top + 1 > 20:             # <<<<<<<<<<<<<<
 *             #logger.info("Too many paths %s (%s) from this node. Giving up" %(thePathStack.top, finishedPaths.top))
 *             destroyPath(pathSoFar)
 */
    __pyx_t_1 = (((__pyx_v_thePathStack->top + 1) > 20) != 0);
    if (!__pyx_t_1) {
      __pyx_t_2 = (((__pyx_v_finishedPaths->top + 1) > 20) != 0);
      __pyx_t_3 = __pyx_t_2;
    } else {
      __pyx_t_3 = __pyx_t_1;
    }
    if (__pyx_t_3) {

      /* "assembler.pyx":1054
 *         if thePathStack.top + 1 > 20 or finishedPaths.top + 1 > 20:
 *             #logger.info("Too many paths %s (%s) from this node. Giving up" %(thePathStack.top, finishedPaths.top))
 *             destroyPath(pathSoFar)             # <<<<<<<<<<<<<<
 *             destroyPathStack(thePathStack)
 *             destroyPathStack(finishedPaths)
 */
      __pyx_f_9assembler_destroyPath(__pyx_v_pathSoFar);

      /* "assembler.pyx":1055
 *             #logger.info("Too many paths %s (%s) from this node. Giving up" %(thePathStack.top, finishedPaths.top))
 *             destroyPath(pathSoFar)
 *             destroyPathStack(thePathStack)             # <<<<<<<<<<<<<<
 *             destroyPathStack(finishedPaths)
 *             return NULL
 */
      __pyx_f_9assembler_destroyPathStack(__pyx_v_thePathStack);

      /* "assembler.pyx":1056
 *             destroyPath(pathSoFar)
 *             destroyPathStack(thePathStack)
 *             destroyPathStack(finishedPaths)             # <<<<<<<<<<<<<<
 *             return NULL
 * 
 */
      __pyx_f_9assembler_destroyPathStack(__pyx_v_finishedPaths);

      /* "assembler.pyx":1057
 *             destroyPathStack(thePathStack)
 *             destroyPathStack(finishedPaths)
 *             return NULL             # <<<<<<<<<<<<<<
 * 
 *         # At the moment, don't allow any cycles.
 */
      __pyx_r = NULL;
      goto __pyx_L0;
    }

    /* "assembler.pyx":1060
 * 
 *         # At the moment, don't allow any cycles.
 *         hasCycle = checkPathForCycles(pathSoFar)             # <<<<<<<<<<<<<<
 * 
 *         if hasCycle:
 */
    __pyx_v_hasCycle = __pyx_f_9assembler_checkPathForCycles(__pyx_v_pathSoFar);

    /* "assembler.pyx":1062
 *         hasCycle = checkPathForCycles(pathSoFar)
 * 
 *         if hasCycle:             # <<<<<<<<<<<<<<
 *             destroyPath(pathSoFar)
 * 
 */
    __pyx_t_3 = (__pyx_v_hasCycle != 0);
    if (__pyx_t_3) {

      /* "assembler.pyx":1063
 * 
 *         if hasCycle:
 *             destroyPath(pathSoFar)             # <<<<<<<<<<<<<<
 * 
 *         # Got back to ref, this path is done with. This is a bubble.
 */
      __pyx_f_9assembler_destroyPath(__pyx_v_pathSoFar);
      goto __pyx_L6;
    }

    /* "assembler.pyx":1066
 * 
 *         # Got back to ref, this path is done with. This is a bubble.
 *         elif endSoFar.colours == REF_AND_READ:             # <<<<<<<<<<<<<<
 *             pathSoFar.isBubble = 1
 *             PathStack_Push(finishedPaths, pathSoFar)
 */
    __pyx_t_3 = ((__pyx_v_endSoFar->colours == __pyx_v_9assembler_REF_AND_READ) != 0);
    if (__pyx_t_3) {

      /* "assembler.pyx":1067
 *         # Got back to ref, this path is done with. This is a bubble.
 *         elif endSoFar.colours == REF_AND_READ:
 *             pathSoFar.isBubble = 1             # <<<<<<<<<<<<<<
 *             PathStack_Push(finishedPaths, pathSoFar)
 * 
 */
      __pyx_v_pathSoFar->isBubble = 1;

      /* "assembler.pyx":1068
 *         elif endSoFar.colours == REF_AND_READ:
 *             pathSoFar.isBubble = 1
 *             PathStack_Push(finishedPaths, pathSoFar)             # <<<<<<<<<<<<<<
 * 
 *         # No reads here. Not quite sure how this could happen. Went from ref and read to only
 */
      __pyx_f_9assembler_PathStack_Push(__pyx_v_finishedPaths, __pyx_v_pathSoFar);
      goto __pyx_L6;
    }

    /* "assembler.pyx":1072
 *         # No reads here. Not quite sure how this could happen. Went from ref and read to only
 *         # ref.
 *         elif endSoFar.colours == REF:             # <<<<<<<<<<<<<<
 *             destroyPath(pathSoFar)
 * 
 */
    __pyx_t_3 = ((__pyx_v_endSoFar->colours == __pyx_v_9assembler_REF) != 0);
    if (__pyx_t_3) {

      /* "assembler.pyx":1073
 *         # ref.
 *         elif endSoFar.colours == REF:
 *             destroyPath(pathSoFar)             # <<<<<<<<<<<<<<
 * 
 *         # Keep extending path
 */
      __pyx_f_9assembler_destroyPath(__pyx_v_pathSoFar);
      goto __pyx_L6;
    }
    /*else*/ {

      /* "assembler.pyx":1091
 * 
 *                 #else:
 *             nEdgesThisNode = endSoFar.nEdges             # <<<<<<<<<<<<<<
 * 
 *             for i in range(nEdgesThisNode):
 */
      __pyx_t_4 = __pyx_v_endSoFar->nEdges;
      __pyx_v_nEdgesThisNode = __pyx_t_4;

      /* "assembler.pyx":1093
 *             nEdgesThisNode = endSoFar.nEdges
 * 
 *             for i in range(nEdgesThisNode):             # <<<<<<<<<<<<<<
 *                 theEdge = endSoFar.edges[i]
 *                 newEnd = theEdge.endNode
 */
      __pyx_t_4 = __pyx_v_nEdgesThisNode;
      for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
        __pyx_v_i = __pyx_t_5;

        /* "assembler.pyx":1094
 * 
 *             for i in range(nEdgesThisNode):
 *                 theEdge = endSoFar.edges[i]             # <<<<<<<<<<<<<<
 *                 newEnd = theEdge.endNode
 * 
 */
        __pyx_v_theEdge = (__pyx_v_endSoFar->edges[__pyx_v_i]);

        /* "assembler.pyx":1095
 *             for i in range(nEdgesThisNode):
 *                 theEdge = endSoFar.edges[i]
 *                 newEnd = theEdge.endNode             # <<<<<<<<<<<<<<
 * 
 *                 if theEdge.weight >= minWeight or newEnd.colours == REF_AND_READ or newEnd.colours == REF:
 */
        __pyx_t_6 = __pyx_v_theEdge->endNode;
        __pyx_v_newEnd = __pyx_t_6;

        /* "assembler.pyx":1097
 *                 newEnd = theEdge.endNode
 * 
 *                 if theEdge.weight >= minWeight or newEnd.colours == REF_AND_READ or newEnd.colours == REF:             # <<<<<<<<<<<<<<
 *                     newPath = createPath(theGraph.kmerSize)
 * 
 */
        __pyx_t_3 = ((__pyx_v_theEdge->weight >= __pyx_v_minWeight) != 0);
        if (!__pyx_t_3) {
          __pyx_t_1 = ((__pyx_v_newEnd->colours == __pyx_v_9assembler_REF_AND_READ) != 0);
          if (!__pyx_t_1) {
            __pyx_t_2 = ((__pyx_v_newEnd->colours == __pyx_v_9assembler_REF) != 0);
            __pyx_t_7 = __pyx_t_2;
          } else {
            __pyx_t_7 = __pyx_t_1;
          }
          __pyx_t_1 = __pyx_t_7;
        } else {
          __pyx_t_1 = __pyx_t_3;
        }
        if (__pyx_t_1) {

          /* "assembler.pyx":1098
 * 
 *                 if theEdge.weight >= minWeight or newEnd.colours == REF_AND_READ or newEnd.colours == REF:
 *                     newPath = createPath(theGraph.kmerSize)             # <<<<<<<<<<<<<<
 * 
 *                     # Copy old path
 */
          __pyx_v_newPath = __pyx_f_9assembler_createPath(__pyx_v_theGraph->kmerSize);

          /* "assembler.pyx":1101
 * 
 *                     # Copy old path
 *                     for j in range(pathSoFar.nNodes):             # <<<<<<<<<<<<<<
 *                         addNodeToPath(newPath, pathSoFar.nodes.elements[j], 0.0)
 * 
 */
          __pyx_t_8 = __pyx_v_pathSoFar->nNodes;
          for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
            __pyx_v_j = __pyx_t_9;

            /* "assembler.pyx":1102
 *                     # Copy old path
 *                     for j in range(pathSoFar.nNodes):
 *                         addNodeToPath(newPath, pathSoFar.nodes.elements[j], 0.0)             # <<<<<<<<<<<<<<
 * 
 *                     # Weight for this path is weight of existing path + weight of new edge
 */
            __pyx_f_9assembler_addNodeToPath(__pyx_v_newPath, (__pyx_v_pathSoFar->nodes->elements[__pyx_v_j]), 0.0);
          }

          /* "assembler.pyx":1105
 * 
 *                     # Weight for this path is weight of existing path + weight of new edge
 *                     newPath.weight = pathSoFar.weight             # <<<<<<<<<<<<<<
 *                     addNodeToPath(newPath, newEnd, theEdge.weight)
 *                     PathStack_Push(thePathStack, newPath)
 */
          __pyx_t_10 = __pyx_v_pathSoFar->weight;
          __pyx_v_newPath->weight = __pyx_t_10;

          /* "assembler.pyx":1106
 *                     # Weight for this path is weight of existing path + weight of new edge
 *                     newPath.weight = pathSoFar.weight
 *                     addNodeToPath(newPath, newEnd, theEdge.weight)             # <<<<<<<<<<<<<<
 *                     PathStack_Push(thePathStack, newPath)
 * 
 */
          __pyx_f_9assembler_addNodeToPath(__pyx_v_newPath, __pyx_v_newEnd, __pyx_v_theEdge->weight);

          /* "assembler.pyx":1107
 *                     newPath.weight = pathSoFar.weight
 *                     addNodeToPath(newPath, newEnd, theEdge.weight)
 *                     PathStack_Push(thePathStack, newPath)             # <<<<<<<<<<<<<<
 * 
 *             destroyPath(pathSoFar)
 */
          __pyx_f_9assembler_PathStack_Push(__pyx_v_thePathStack, __pyx_v_newPath);
          goto __pyx_L9;
        }
        __pyx_L9:;
      }

      /* "assembler.pyx":1109
 *                     PathStack_Push(thePathStack, newPath)
 * 
 *             destroyPath(pathSoFar)             # <<<<<<<<<<<<<<
 * 
 *     destroyPathStack(thePathStack)
 */
      __pyx_f_9assembler_destroyPath(__pyx_v_pathSoFar);
    }
    __pyx_L6:;
  }

  /* "assembler.pyx":1111
 *             destroyPath(pathSoFar)
 * 
 *     destroyPathStack(thePathStack)             # <<<<<<<<<<<<<<
 *     return finishedPaths
 * 
 */
  __pyx_f_9assembler_destroyPathStack(__pyx_v_thePathStack);

  /* "assembler.pyx":1112
 * 
 *     destroyPathStack(thePathStack)
 *     return finishedPaths             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_finishedPaths;
  goto __pyx_L0;

  /* "assembler.pyx":1027
 * ###################################################################################################
 * 
 * cdef PathStack* getVariantPathsThroughGraphFromNode(DeBruijnGraph* theGraph, Path* thePath, double minWeight):             # <<<<<<<<<<<<<<
 *     """
 *     Check all valid paths through the graph starting at the last node in "thePath". If any path
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":1116
 * ###################################################################################################
 * 
 * cdef list findBubblesInGraph(DeBruijnGraph* theGraph, double minWeight, char* refSeq, char* chrom, int refStart, int refEnd, int assemStart, int assemEnd, int verbosity):             # <<<<<<<<<<<<<<
 *     """
 *     Find and return all bubbles in the graph.
 */

static PyObject *__pyx_f_9assembler_findBubblesInGraph(__pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph, double __pyx_v_minWeight, char *__pyx_v_refSeq, char *__pyx_v_chrom, int __pyx_v_refStart, int __pyx_v_refEnd, int __pyx_v_assemStart, int __pyx_v_assemEnd, int __pyx_v_verbosity) {
  int __pyx_v_nNodes;
  int __pyx_v_nEdgesThisNode;
  int __pyx_v_nBubblePaths;
  CYTHON_UNUSED int __pyx_v_nNodesThisPath;
  int __pyx_v_i;
  int __pyx_v_j;
  __pyx_t_9assembler_Edge *__pyx_v_theEdge;
  __pyx_t_9assembler_Node **__pyx_v_allNodes;
  __pyx_t_9assembler_Node *__pyx_v_theNode;
  __pyx_t_9assembler_PathStack *__pyx_v_bubblePathsThisNode;
  __pyx_t_9assembler_Path *__pyx_v_thePath;
  __pyx_t_9assembler_Path *__pyx_v_theBubblePath;
  PyObject *__pyx_v_variants = 0;
  struct __pyx_obj_7variant_Variant *__pyx_v_theVar = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __pyx_t_9assembler_Node **__pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  int __pyx_t_10;
  int __pyx_t_11;
  int __pyx_t_12;
  int __pyx_t_13;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("findBubblesInGraph", 0);

  /* "assembler.pyx":1125
 *     4) Keep a stack of the current path
 *     """
 *     cdef int nNodes = theGraph.allNodes.top + 1             # <<<<<<<<<<<<<<
 *     cdef int nEdgesThisNode = 0
 *     cdef int nBubblePaths = 0
 */
  __pyx_v_nNodes = (__pyx_v_theGraph->allNodes->top + 1);

  /* "assembler.pyx":1126
 *     """
 *     cdef int nNodes = theGraph.allNodes.top + 1
 *     cdef int nEdgesThisNode = 0             # <<<<<<<<<<<<<<
 *     cdef int nBubblePaths = 0
 *     cdef int nNodesThisPath = 0
 */
  __pyx_v_nEdgesThisNode = 0;

  /* "assembler.pyx":1127
 *     cdef int nNodes = theGraph.allNodes.top + 1
 *     cdef int nEdgesThisNode = 0
 *     cdef int nBubblePaths = 0             # <<<<<<<<<<<<<<
 *     cdef int nNodesThisPath = 0
 *     cdef int i = 0
 */
  __pyx_v_nBubblePaths = 0;

  /* "assembler.pyx":1128
 *     cdef int nEdgesThisNode = 0
 *     cdef int nBubblePaths = 0
 *     cdef int nNodesThisPath = 0             # <<<<<<<<<<<<<<
 *     cdef int i = 0
 *     cdef int j = 0
 */
  __pyx_v_nNodesThisPath = 0;

  /* "assembler.pyx":1129
 *     cdef int nBubblePaths = 0
 *     cdef int nNodesThisPath = 0
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef int j = 0
 *     cdef Edge* theEdge = NULL
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":1130
 *     cdef int nNodesThisPath = 0
 *     cdef int i = 0
 *     cdef int j = 0             # <<<<<<<<<<<<<<
 *     cdef Edge* theEdge = NULL
 *     cdef Node** allNodes = theGraph.allNodes.elements
 */
  __pyx_v_j = 0;

  /* "assembler.pyx":1131
 *     cdef int i = 0
 *     cdef int j = 0
 *     cdef Edge* theEdge = NULL             # <<<<<<<<<<<<<<
 *     cdef Node** allNodes = theGraph.allNodes.elements
 *     cdef Node* theNode = NULL
 */
  __pyx_v_theEdge = NULL;

  /* "assembler.pyx":1132
 *     cdef int j = 0
 *     cdef Edge* theEdge = NULL
 *     cdef Node** allNodes = theGraph.allNodes.elements             # <<<<<<<<<<<<<<
 *     cdef Node* theNode = NULL
 *     cdef PathStack* bubblePathsThisNode = NULL
 */
  __pyx_t_1 = __pyx_v_theGraph->allNodes->elements;
  __pyx_v_allNodes = __pyx_t_1;

  /* "assembler.pyx":1133
 *     cdef Edge* theEdge = NULL
 *     cdef Node** allNodes = theGraph.allNodes.elements
 *     cdef Node* theNode = NULL             # <<<<<<<<<<<<<<
 *     cdef PathStack* bubblePathsThisNode = NULL
 *     cdef Path* thePath = NULL
 */
  __pyx_v_theNode = NULL;

  /* "assembler.pyx":1134
 *     cdef Node** allNodes = theGraph.allNodes.elements
 *     cdef Node* theNode = NULL
 *     cdef PathStack* bubblePathsThisNode = NULL             # <<<<<<<<<<<<<<
 *     cdef Path* thePath = NULL
 *     cdef Path* theBubblePath = NULL
 */
  __pyx_v_bubblePathsThisNode = NULL;

  /* "assembler.pyx":1135
 *     cdef Node* theNode = NULL
 *     cdef PathStack* bubblePathsThisNode = NULL
 *     cdef Path* thePath = NULL             # <<<<<<<<<<<<<<
 *     cdef Path* theBubblePath = NULL
 *     cdef list variants = []
 */
  __pyx_v_thePath = NULL;

  /* "assembler.pyx":1136
 *     cdef PathStack* bubblePathsThisNode = NULL
 *     cdef Path* thePath = NULL
 *     cdef Path* theBubblePath = NULL             # <<<<<<<<<<<<<<
 *     cdef list variants = []
 *     cdef Variant theVar
 */
  __pyx_v_theBubblePath = NULL;

  /* "assembler.pyx":1137
 *     cdef Path* thePath = NULL
 *     cdef Path* theBubblePath = NULL
 *     cdef list variants = []             # <<<<<<<<<<<<<<
 *     cdef Variant theVar
 * 
 */
  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_variants = ((PyObject*)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "assembler.pyx":1140
 *     cdef Variant theVar
 * 
 *     for i in range(nNodes):             # <<<<<<<<<<<<<<
 *         theNode = allNodes[i]
 * 
 */
  __pyx_t_3 = __pyx_v_nNodes;
  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
    __pyx_v_i = __pyx_t_4;

    /* "assembler.pyx":1141
 * 
 *     for i in range(nNodes):
 *         theNode = allNodes[i]             # <<<<<<<<<<<<<<
 * 
 *         # First node which is ref only
 */
    __pyx_v_theNode = (__pyx_v_allNodes[__pyx_v_i]);

    /* "assembler.pyx":1144
 * 
 *         # First node which is ref only
 *         if theNode.colours == REF_AND_READ and theNode.position >= assemStart and theNode.position < assemEnd:             # <<<<<<<<<<<<<<
 *             nEdgesThisNode = theNode.nEdges
 * 
 */
    __pyx_t_5 = ((__pyx_v_theNode->colours == __pyx_v_9assembler_REF_AND_READ) != 0);
    if (__pyx_t_5) {
      __pyx_t_6 = ((__pyx_v_theNode->position >= __pyx_v_assemStart) != 0);
      if (__pyx_t_6) {
        __pyx_t_7 = ((__pyx_v_theNode->position < __pyx_v_assemEnd) != 0);
        __pyx_t_8 = __pyx_t_7;
      } else {
        __pyx_t_8 = __pyx_t_6;
      }
      __pyx_t_6 = __pyx_t_8;
    } else {
      __pyx_t_6 = __pyx_t_5;
    }
    if (__pyx_t_6) {

      /* "assembler.pyx":1145
 *         # First node which is ref only
 *         if theNode.colours == REF_AND_READ and theNode.position >= assemStart and theNode.position < assemEnd:
 *             nEdgesThisNode = theNode.nEdges             # <<<<<<<<<<<<<<
 * 
 *             for j in range(nEdgesThisNode):
 */
      __pyx_t_9 = __pyx_v_theNode->nEdges;
      __pyx_v_nEdgesThisNode = __pyx_t_9;

      /* "assembler.pyx":1147
 *             nEdgesThisNode = theNode.nEdges
 * 
 *             for j in range(nEdgesThisNode):             # <<<<<<<<<<<<<<
 *                 #logger.debug("Node %s has %s edges" %(i, nEdgesThisNode))
 *                 theEdge = theNode.edges[j]
 */
      __pyx_t_9 = __pyx_v_nEdgesThisNode;
      for (__pyx_t_10 = 0; __pyx_t_10 < __pyx_t_9; __pyx_t_10+=1) {
        __pyx_v_j = __pyx_t_10;

        /* "assembler.pyx":1149
 *             for j in range(nEdgesThisNode):
 *                 #logger.debug("Node %s has %s edges" %(i, nEdgesThisNode))
 *                 theEdge = theNode.edges[j]             # <<<<<<<<<<<<<<
 * 
 *                 # New kmer in reads. Start path using a depth-first
 */
        __pyx_v_theEdge = (__pyx_v_theNode->edges[__pyx_v_j]);

        /* "assembler.pyx":1153
 *                 # New kmer in reads. Start path using a depth-first
 *                 # search from this node. Include first node in path.
 *                 if theEdge.endNode.colours == READ:             # <<<<<<<<<<<<<<
 * 
 *                     thePath = createPath(theGraph.kmerSize)
 */
        __pyx_t_6 = ((__pyx_v_theEdge->endNode->colours == __pyx_v_9assembler_READ) != 0);
        if (__pyx_t_6) {

          /* "assembler.pyx":1155
 *                 if theEdge.endNode.colours == READ:
 * 
 *                     thePath = createPath(theGraph.kmerSize)             # <<<<<<<<<<<<<<
 *                     addNodeToPath(thePath, theNode, 0.0)
 *                     addNodeToPath(thePath, theEdge.endNode, 0.0)
 */
          __pyx_v_thePath = __pyx_f_9assembler_createPath(__pyx_v_theGraph->kmerSize);

          /* "assembler.pyx":1156
 * 
 *                     thePath = createPath(theGraph.kmerSize)
 *                     addNodeToPath(thePath, theNode, 0.0)             # <<<<<<<<<<<<<<
 *                     addNodeToPath(thePath, theEdge.endNode, 0.0)
 *                     bubblePathsThisNode = getVariantPathsThroughGraphFromNode(theGraph, thePath, minWeight)
 */
          __pyx_f_9assembler_addNodeToPath(__pyx_v_thePath, __pyx_v_theNode, 0.0);

          /* "assembler.pyx":1157
 *                     thePath = createPath(theGraph.kmerSize)
 *                     addNodeToPath(thePath, theNode, 0.0)
 *                     addNodeToPath(thePath, theEdge.endNode, 0.0)             # <<<<<<<<<<<<<<
 *                     bubblePathsThisNode = getVariantPathsThroughGraphFromNode(theGraph, thePath, minWeight)
 * 
 */
          __pyx_f_9assembler_addNodeToPath(__pyx_v_thePath, __pyx_v_theEdge->endNode, 0.0);

          /* "assembler.pyx":1158
 *                     addNodeToPath(thePath, theNode, 0.0)
 *                     addNodeToPath(thePath, theEdge.endNode, 0.0)
 *                     bubblePathsThisNode = getVariantPathsThroughGraphFromNode(theGraph, thePath, minWeight)             # <<<<<<<<<<<<<<
 * 
 *                     if bubblePathsThisNode != NULL:
 */
          __pyx_v_bubblePathsThisNode = __pyx_f_9assembler_getVariantPathsThroughGraphFromNode(__pyx_v_theGraph, __pyx_v_thePath, __pyx_v_minWeight);

          /* "assembler.pyx":1160
 *                     bubblePathsThisNode = getVariantPathsThroughGraphFromNode(theGraph, thePath, minWeight)
 * 
 *                     if bubblePathsThisNode != NULL:             # <<<<<<<<<<<<<<
 *                         nBubblePaths = bubblePathsThisNode.top + 1
 * 
 */
          __pyx_t_6 = ((__pyx_v_bubblePathsThisNode != NULL) != 0);
          if (__pyx_t_6) {

            /* "assembler.pyx":1161
 * 
 *                     if bubblePathsThisNode != NULL:
 *                         nBubblePaths = bubblePathsThisNode.top + 1             # <<<<<<<<<<<<<<
 * 
 *                         #logger.debug("There are %s bubble paths from node %s and edge %s in region %s:%s-%s" %(nBubblePaths, i, j, chrom, assemStart, assemEnd))
 */
            __pyx_v_nBubblePaths = (__pyx_v_bubblePathsThisNode->top + 1);

            /* "assembler.pyx":1165
 *                         #logger.debug("There are %s bubble paths from node %s and edge %s in region %s:%s-%s" %(nBubblePaths, i, j, chrom, assemStart, assemEnd))
 * 
 *                         for j in range(nBubblePaths):             # <<<<<<<<<<<<<<
 *                             theBubblePath = bubblePathsThisNode.elements[j]
 *                             theVar = extractVarFromBubblePath(theGraph, theBubblePath, refSeq, chrom, refStart, refEnd, verbosity)
 */
            __pyx_t_11 = __pyx_v_nBubblePaths;
            for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_11; __pyx_t_12+=1) {
              __pyx_v_j = __pyx_t_12;

              /* "assembler.pyx":1166
 * 
 *                         for j in range(nBubblePaths):
 *                             theBubblePath = bubblePathsThisNode.elements[j]             # <<<<<<<<<<<<<<
 *                             theVar = extractVarFromBubblePath(theGraph, theBubblePath, refSeq, chrom, refStart, refEnd, verbosity)
 * 
 */
              __pyx_v_theBubblePath = (__pyx_v_bubblePathsThisNode->elements[__pyx_v_j]);

              /* "assembler.pyx":1167
 *                         for j in range(nBubblePaths):
 *                             theBubblePath = bubblePathsThisNode.elements[j]
 *                             theVar = extractVarFromBubblePath(theGraph, theBubblePath, refSeq, chrom, refStart, refEnd, verbosity)             # <<<<<<<<<<<<<<
 * 
 *                             #if verbosity >= 3:
 */
              __pyx_t_2 = ((PyObject *)__pyx_f_9assembler_extractVarFromBubblePath(__pyx_v_theGraph, __pyx_v_theBubblePath, __pyx_v_refSeq, __pyx_v_chrom, __pyx_v_refStart, __pyx_v_refEnd, __pyx_v_verbosity)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
              __Pyx_GOTREF(__pyx_t_2);
              __Pyx_XDECREF_SET(__pyx_v_theVar, ((struct __pyx_obj_7variant_Variant *)__pyx_t_2));
              __pyx_t_2 = 0;

              /* "assembler.pyx":1172
 *                             #    logger.debug("Assembler found variant %s. Path has %s nodes, with total weight %s. Weight per node = %s" %(theVar, thePath.nNodes, thePath.weight, thePath.weight/thePath.nNodes))
 * 
 *                             if theVar is not None:             # <<<<<<<<<<<<<<
 *                                 variants.append(theVar)
 * 
 */
              __pyx_t_6 = (((PyObject *)__pyx_v_theVar) != Py_None);
              __pyx_t_5 = (__pyx_t_6 != 0);
              if (__pyx_t_5) {

                /* "assembler.pyx":1173
 * 
 *                             if theVar is not None:
 *                                 variants.append(theVar)             # <<<<<<<<<<<<<<
 * 
 *                         destroyPathStack(bubblePathsThisNode)
 */
                __pyx_t_13 = __Pyx_PyList_Append(__pyx_v_variants, ((PyObject *)__pyx_v_theVar)); if (unlikely(__pyx_t_13 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
                goto __pyx_L12;
              }
              __pyx_L12:;
            }

            /* "assembler.pyx":1175
 *                                 variants.append(theVar)
 * 
 *                         destroyPathStack(bubblePathsThisNode)             # <<<<<<<<<<<<<<
 * 
 *     return variants
 */
            __pyx_f_9assembler_destroyPathStack(__pyx_v_bubblePathsThisNode);
            goto __pyx_L9;
          }
          __pyx_L9:;
          goto __pyx_L8;
        }
        __pyx_L8:;
      }
      goto __pyx_L5;
    }
    __pyx_L5:;
  }

  /* "assembler.pyx":1177
 *                         destroyPathStack(bubblePathsThisNode)
 * 
 *     return variants             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_variants);
  __pyx_r = __pyx_v_variants;
  goto __pyx_L0;

  /* "assembler.pyx":1116
 * ###################################################################################################
 * 
 * cdef list findBubblesInGraph(DeBruijnGraph* theGraph, double minWeight, char* refSeq, char* chrom, int refStart, int refEnd, int assemStart, int assemEnd, int verbosity):             # <<<<<<<<<<<<<<
 *     """
 *     Find and return all bubbles in the graph.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("assembler.findBubblesInGraph", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_variants);
  __Pyx_XDECREF((PyObject *)__pyx_v_theVar);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":1181
 * ###################################################################################################
 * 
 * cdef void logPath(Path* thePath, char* refSeq, int refStart):             # <<<<<<<<<<<<<<
 *     """
 *     Log a path through the graph.
 */

static void __pyx_f_9assembler_logPath(__pyx_t_9assembler_Path *__pyx_v_thePath, char *__pyx_v_refSeq, int __pyx_v_refStart) {
  int __pyx_v_i;
  int __pyx_v_startPos;
  __pyx_t_9assembler_Node *__pyx_v_theNode;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("logPath", 0);

  /* "assembler.pyx":1185
 *     Log a path through the graph.
 *     """
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef int startPos = thePath.nodes.elements[0].position
 *     cdef Node* theNode
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":1186
 *     """
 *     cdef int i = 0
 *     cdef int startPos = thePath.nodes.elements[0].position             # <<<<<<<<<<<<<<
 *     cdef Node* theNode
 *     logger.debug("Logging path of %s nodes" %(thePath.nNodes))
 */
  __pyx_t_1 = (__pyx_v_thePath->nodes->elements[0])->position;
  __pyx_v_startPos = __pyx_t_1;

  /* "assembler.pyx":1188
 *     cdef int startPos = thePath.nodes.elements[0].position
 *     cdef Node* theNode
 *     logger.debug("Logging path of %s nodes" %(thePath.nNodes))             # <<<<<<<<<<<<<<
 * 
 *     for i in range(thePath.nNodes):
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1188; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_debug); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1188; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_thePath->nNodes); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1188; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Logging_path_of_s_nodes, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1188; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1188; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1188; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "assembler.pyx":1190
 *     logger.debug("Logging path of %s nodes" %(thePath.nNodes))
 * 
 *     for i in range(thePath.nNodes):             # <<<<<<<<<<<<<<
 *         theNode = thePath.nodes.elements[i]
 *         logger.debug("Pos = %s. Seq = %s. RefSeq = %c. Colours = %s. Node weight = %s" %(theNode.position, theNode.sequence[0: theNode.kmerSize], refSeq[startPos + i - refStart], theNode.colours, theNode.weight))
 */
  __pyx_t_1 = __pyx_v_thePath->nNodes;
  for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_1; __pyx_t_5+=1) {
    __pyx_v_i = __pyx_t_5;

    /* "assembler.pyx":1191
 * 
 *     for i in range(thePath.nNodes):
 *         theNode = thePath.nodes.elements[i]             # <<<<<<<<<<<<<<
 *         logger.debug("Pos = %s. Seq = %s. RefSeq = %c. Colours = %s. Node weight = %s" %(theNode.position, theNode.sequence[0: theNode.kmerSize], refSeq[startPos + i - refStart], theNode.colours, theNode.weight))
 * 
 */
    __pyx_v_theNode = (__pyx_v_thePath->nodes->elements[__pyx_v_i]);

    /* "assembler.pyx":1192
 *     for i in range(thePath.nNodes):
 *         theNode = thePath.nodes.elements[i]
 *         logger.debug("Pos = %s. Seq = %s. RefSeq = %c. Colours = %s. Node weight = %s" %(theNode.position, theNode.sequence[0: theNode.kmerSize], refSeq[startPos + i - refStart], theNode.colours, theNode.weight))             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_debug); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_theNode->position); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_theNode->sequence + 0, __pyx_v_theNode->kmerSize - 0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_6 = __Pyx_PyInt_From_char((__pyx_v_refSeq[((__pyx_v_startPos + __pyx_v_i) - __pyx_v_refStart)])); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_theNode->colours); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_8 = PyFloat_FromDouble(__pyx_v_theNode->weight); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = PyTuple_New(5); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_9, 2, __pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_9, 3, __pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_9, 4, __pyx_t_8);
    __Pyx_GIVEREF(__pyx_t_8);
    __pyx_t_4 = 0;
    __pyx_t_3 = 0;
    __pyx_t_6 = 0;
    __pyx_t_7 = 0;
    __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyString_Format(__pyx_kp_s_Pos_s_Seq_s_RefSeq_c_Colours_s_N, __pyx_t_9); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = PyTuple_New(1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_8);
    __Pyx_GIVEREF(__pyx_t_8);
    __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_9, NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }

  /* "assembler.pyx":1181
 * ###################################################################################################
 * 
 * cdef void logPath(Path* thePath, char* refSeq, int refStart):             # <<<<<<<<<<<<<<
 *     """
 *     Log a path through the graph.
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_WriteUnraisable("assembler.logPath", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":1196
 * ###################################################################################################
 * 
 * cdef Variant extractVarFromBubblePath(DeBruijnGraph* theGraph, Path* bubblePath, char* refSeq, char* chrom, int refStart, int refEnd, int verbosity):             # <<<<<<<<<<<<<<
 *     """
 *     Construct and return a representation of the variant implied by this bubble in the graph.
 */

static struct __pyx_obj_7variant_Variant *__pyx_f_9assembler_extractVarFromBubblePath(CYTHON_UNUSED __pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph, __pyx_t_9assembler_Path *__pyx_v_bubblePath, char *__pyx_v_refSeq, char *__pyx_v_chrom, int __pyx_v_refStart, CYTHON_UNUSED int __pyx_v_refEnd, int __pyx_v_verbosity) {
  int __pyx_v_nNodesThisPath;
  __pyx_t_9assembler_Node *__pyx_v_bubbleStart;
  __pyx_t_9assembler_Node *__pyx_v_bubbleEnd;
  int __pyx_v_bubbleStartPos;
  int __pyx_v_bubbleEndPos;
  char *__pyx_v_charReadSeq;
  int __pyx_v_i;
  PyObject *__pyx_v_thisRefSeq = 0;
  PyObject *__pyx_v_thisReadSeq = 0;
  CYTHON_UNUSED int __pyx_v_varLen;
  int __pyx_v_varStartPos;
  struct __pyx_obj_7variant_Variant *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  Py_ssize_t __pyx_t_10;
  int __pyx_t_11;
  int __pyx_t_12;
  Py_ssize_t __pyx_t_13;
  PyObject *__pyx_t_14 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("extractVarFromBubblePath", 0);

  /* "assembler.pyx":1200
 *     Construct and return a representation of the variant implied by this bubble in the graph.
 *     """
 *     cdef int nNodesThisPath = bubblePath.nodes.top + 1             # <<<<<<<<<<<<<<
 *     cdef Node* bubbleStart = bubblePath.nodes.elements[0]
 *     cdef Node* bubbleEnd = bubblePath.nodes.elements[nNodesThisPath-1]
 */
  __pyx_v_nNodesThisPath = (__pyx_v_bubblePath->nodes->top + 1);

  /* "assembler.pyx":1201
 *     """
 *     cdef int nNodesThisPath = bubblePath.nodes.top + 1
 *     cdef Node* bubbleStart = bubblePath.nodes.elements[0]             # <<<<<<<<<<<<<<
 *     cdef Node* bubbleEnd = bubblePath.nodes.elements[nNodesThisPath-1]
 *     cdef Node* theNode
 */
  __pyx_v_bubbleStart = (__pyx_v_bubblePath->nodes->elements[0]);

  /* "assembler.pyx":1202
 *     cdef int nNodesThisPath = bubblePath.nodes.top + 1
 *     cdef Node* bubbleStart = bubblePath.nodes.elements[0]
 *     cdef Node* bubbleEnd = bubblePath.nodes.elements[nNodesThisPath-1]             # <<<<<<<<<<<<<<
 *     cdef Node* theNode
 *     cdef int bubbleStartPos = 0
 */
  __pyx_v_bubbleEnd = (__pyx_v_bubblePath->nodes->elements[(__pyx_v_nNodesThisPath - 1)]);

  /* "assembler.pyx":1204
 *     cdef Node* bubbleEnd = bubblePath.nodes.elements[nNodesThisPath-1]
 *     cdef Node* theNode
 *     cdef int bubbleStartPos = 0             # <<<<<<<<<<<<<<
 *     cdef int bubbleEndPos = 0
 * 
 */
  __pyx_v_bubbleStartPos = 0;

  /* "assembler.pyx":1205
 *     cdef Node* theNode
 *     cdef int bubbleStartPos = 0
 *     cdef int bubbleEndPos = 0             # <<<<<<<<<<<<<<
 * 
 *     # Bubble comes back to reference, so take start and end points on reference
 */
  __pyx_v_bubbleEndPos = 0;

  /* "assembler.pyx":1209
 *     # Bubble comes back to reference, so take start and end points on reference
 *     # from start and end nodes in bubble
 *     if bubblePath.isBubble:             # <<<<<<<<<<<<<<
 *         bubbleStartPos = bubbleStart.position
 *         bubbleEndPos = bubbleEnd.position
 */
  __pyx_t_1 = (__pyx_v_bubblePath->isBubble != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":1210
 *     # from start and end nodes in bubble
 *     if bubblePath.isBubble:
 *         bubbleStartPos = bubbleStart.position             # <<<<<<<<<<<<<<
 *         bubbleEndPos = bubbleEnd.position
 * 
 */
    __pyx_t_2 = __pyx_v_bubbleStart->position;
    __pyx_v_bubbleStartPos = __pyx_t_2;

    /* "assembler.pyx":1211
 *     if bubblePath.isBubble:
 *         bubbleStartPos = bubbleStart.position
 *         bubbleEndPos = bubbleEnd.position             # <<<<<<<<<<<<<<
 * 
 *         if bubbleEndPos < bubbleStartPos:
 */
    __pyx_t_2 = __pyx_v_bubbleEnd->position;
    __pyx_v_bubbleEndPos = __pyx_t_2;

    /* "assembler.pyx":1213
 *         bubbleEndPos = bubbleEnd.position
 * 
 *         if bubbleEndPos < bubbleStartPos:             # <<<<<<<<<<<<<<
 *             #if verbosity >= 3:
 *                 #logger.debug("Found wonky candidate with end pos < start pos. (%s --> %s)" %(bubbleStartPos, bubbleEndPos))
 */
    __pyx_t_1 = ((__pyx_v_bubbleEndPos < __pyx_v_bubbleStartPos) != 0);
    if (__pyx_t_1) {

      /* "assembler.pyx":1217
 *                 #logger.debug("Found wonky candidate with end pos < start pos. (%s --> %s)" %(bubbleStartPos, bubbleEndPos))
 *                 #logPath(bubblePath, refSeq, refStart)
 *             bubbleEndPos = bubbleStartPos + bubblePath.nNodes - 1             # <<<<<<<<<<<<<<
 *             return None
 * 
 */
      __pyx_v_bubbleEndPos = ((__pyx_v_bubbleStartPos + __pyx_v_bubblePath->nNodes) - 1);

      /* "assembler.pyx":1218
 *                 #logPath(bubblePath, refSeq, refStart)
 *             bubbleEndPos = bubbleStartPos + bubblePath.nNodes - 1
 *             return None             # <<<<<<<<<<<<<<
 * 
 *         #logger.debug("Assembled path with %s nodes. Start = %s. End = %s" %(bubblePath.nNodes, bubbleStart.position, bubbleEnd.position))
 */
      __Pyx_XDECREF(((PyObject *)__pyx_r));
      __Pyx_INCREF(Py_None);
      __pyx_r = ((struct __pyx_obj_7variant_Variant *)Py_None);
      goto __pyx_L0;
    }
    goto __pyx_L3;
  }
  /*else*/ {

    /* "assembler.pyx":1226
 *     # start point in ref as insertion point.
 *     else:
 *         bubbleStartPos = bubbleStart.position             # <<<<<<<<<<<<<<
 *         bubbleEndPos = bubbleStartPos
 * 
 */
    __pyx_t_2 = __pyx_v_bubbleStart->position;
    __pyx_v_bubbleStartPos = __pyx_t_2;

    /* "assembler.pyx":1227
 *     else:
 *         bubbleStartPos = bubbleStart.position
 *         bubbleEndPos = bubbleStartPos             # <<<<<<<<<<<<<<
 * 
 *     # TODO: We should be able to deal with these now. Just add nNodes to bubble
 */
    __pyx_v_bubbleEndPos = __pyx_v_bubbleStartPos;
  }
  __pyx_L3:;

  /* "assembler.pyx":1230
 * 
 *     # TODO: We should be able to deal with these now. Just add nNodes to bubble
 *     if bubbleEndPos < bubbleStartPos:             # <<<<<<<<<<<<<<
 *         logger.warning("Found complex variation that Platypus can't deal with yet at %s:%s-%s" %(chrom, min(bubbleStartPos,bubbleEndPos), max(bubbleStartPos,bubbleEndPos)))
 *         return None
 */
  __pyx_t_1 = ((__pyx_v_bubbleEndPos < __pyx_v_bubbleStartPos) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":1231
 *     # TODO: We should be able to deal with these now. Just add nNodes to bubble
 *     if bubbleEndPos < bubbleStartPos:
 *         logger.warning("Found complex variation that Platypus can't deal with yet at %s:%s-%s" %(chrom, min(bubbleStartPos,bubbleEndPos), max(bubbleStartPos,bubbleEndPos)))             # <<<<<<<<<<<<<<
 *         return None
 * 
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_warning); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_chrom); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = __pyx_v_bubbleEndPos;
    __pyx_t_5 = __pyx_v_bubbleStartPos;
    if (((__pyx_t_2 < __pyx_t_5) != 0)) {
      __pyx_t_6 = __pyx_t_2;
    } else {
      __pyx_t_6 = __pyx_t_5;
    }
    __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_t_6); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_6 = __pyx_v_bubbleEndPos;
    __pyx_t_2 = __pyx_v_bubbleStartPos;
    if (((__pyx_t_6 > __pyx_t_2) != 0)) {
      __pyx_t_5 = __pyx_t_6;
    } else {
      __pyx_t_5 = __pyx_t_2;
    }
    __pyx_t_8 = __Pyx_PyInt_From_int(__pyx_t_5); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = PyTuple_New(3); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_9, 2, __pyx_t_8);
    __Pyx_GIVEREF(__pyx_t_8);
    __pyx_t_3 = 0;
    __pyx_t_7 = 0;
    __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyString_Format(__pyx_kp_s_Found_complex_variation_that_Pla, __pyx_t_9); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = PyTuple_New(1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_8);
    __Pyx_GIVEREF(__pyx_t_8);
    __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_9, NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

    /* "assembler.pyx":1232
 *     if bubbleEndPos < bubbleStartPos:
 *         logger.warning("Found complex variation that Platypus can't deal with yet at %s:%s-%s" %(chrom, min(bubbleStartPos,bubbleEndPos), max(bubbleStartPos,bubbleEndPos)))
 *         return None             # <<<<<<<<<<<<<<
 * 
 *     cdef char* charReadSeq = <char*>(malloc(sizeof(char)*(nNodesThisPath+1)))
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __Pyx_INCREF(Py_None);
    __pyx_r = ((struct __pyx_obj_7variant_Variant *)Py_None);
    goto __pyx_L0;
  }

  /* "assembler.pyx":1234
 *         return None
 * 
 *     cdef char* charReadSeq = <char*>(malloc(sizeof(char)*(nNodesThisPath+1)))             # <<<<<<<<<<<<<<
 * 
 *     if charReadSeq == NULL:
 */
  __pyx_v_charReadSeq = ((char *)malloc(((sizeof(char)) * (__pyx_v_nNodesThisPath + 1))));

  /* "assembler.pyx":1236
 *     cdef char* charReadSeq = <char*>(malloc(sizeof(char)*(nNodesThisPath+1)))
 * 
 *     if charReadSeq == NULL:             # <<<<<<<<<<<<<<
 *         logger.error("Could not allocate memory for charReadSeq of size %s" %(nNodesThisPath+1))
 * 
 */
  __pyx_t_1 = ((__pyx_v_charReadSeq == NULL) != 0);
  if (__pyx_t_1) {

    /* "assembler.pyx":1237
 * 
 *     if charReadSeq == NULL:
 *         logger.error("Could not allocate memory for charReadSeq of size %s" %(nNodesThisPath+1))             # <<<<<<<<<<<<<<
 * 
 *     cdef int i = 0
 */
    __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_error); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyInt_From_long((__pyx_v_nNodesThisPath + 1)); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Could_not_allocate_memory_for_ch, __pyx_t_8); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "assembler.pyx":1239
 *         logger.error("Could not allocate memory for charReadSeq of size %s" %(nNodesThisPath+1))
 * 
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 * 
 *     # Create sequence of variant. Remember to add null terminating element
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":1242
 * 
 *     # Create sequence of variant. Remember to add null terminating element
 *     for i in range(nNodesThisPath):             # <<<<<<<<<<<<<<
 *         charReadSeq[i] = bubblePath.nodes.elements[i].sequence[0]
 * 
 */
  __pyx_t_5 = __pyx_v_nNodesThisPath;
  for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
    __pyx_v_i = __pyx_t_6;

    /* "assembler.pyx":1243
 *     # Create sequence of variant. Remember to add null terminating element
 *     for i in range(nNodesThisPath):
 *         charReadSeq[i] = bubblePath.nodes.elements[i].sequence[0]             # <<<<<<<<<<<<<<
 * 
 *     charReadSeq[nNodesThisPath] = 0
 */
    (__pyx_v_charReadSeq[__pyx_v_i]) = ((__pyx_v_bubblePath->nodes->elements[__pyx_v_i])->sequence[0]);
  }

  /* "assembler.pyx":1245
 *         charReadSeq[i] = bubblePath.nodes.elements[i].sequence[0]
 * 
 *     charReadSeq[nNodesThisPath] = 0             # <<<<<<<<<<<<<<
 * 
 *     cdef bytes thisRefSeq = refSeq[bubbleStartPos - refStart: bubbleEndPos - refStart + 1]
 */
  (__pyx_v_charReadSeq[__pyx_v_nNodesThisPath]) = 0;

  /* "assembler.pyx":1247
 *     charReadSeq[nNodesThisPath] = 0
 * 
 *     cdef bytes thisRefSeq = refSeq[bubbleStartPos - refStart: bubbleEndPos - refStart + 1]             # <<<<<<<<<<<<<<
 *     cdef bytes thisReadSeq = charReadSeq
 * 
 */
  __pyx_t_4 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_refSeq + (__pyx_v_bubbleStartPos - __pyx_v_refStart), ((__pyx_v_bubbleEndPos - __pyx_v_refStart) + 1) - (__pyx_v_bubbleStartPos - __pyx_v_refStart)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_v_thisRefSeq = ((PyObject*)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "assembler.pyx":1248
 * 
 *     cdef bytes thisRefSeq = refSeq[bubbleStartPos - refStart: bubbleEndPos - refStart + 1]
 *     cdef bytes thisReadSeq = charReadSeq             # <<<<<<<<<<<<<<
 * 
 *     # The bytes variable holds a copy, so free the original.
 */
  __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_charReadSeq); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_v_thisReadSeq = ((PyObject*)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "assembler.pyx":1251
 * 
 *     # The bytes variable holds a copy, so free the original.
 *     free(charReadSeq)             # <<<<<<<<<<<<<<
 * 
 *     # Push as far to left as possible
 */
  free(__pyx_v_charReadSeq);

  /* "assembler.pyx":1254
 * 
 *     # Push as far to left as possible
 *     while len(thisReadSeq) > 0 and len(thisRefSeq) > 0:             # <<<<<<<<<<<<<<
 * 
 *         if thisRefSeq[-1] == thisReadSeq[-1]:
 */
  while (1) {
    __pyx_t_10 = PyBytes_GET_SIZE(__pyx_v_thisReadSeq); if (unlikely(__pyx_t_10 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1254; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_1 = ((__pyx_t_10 > 0) != 0);
    if (__pyx_t_1) {
      __pyx_t_10 = PyBytes_GET_SIZE(__pyx_v_thisRefSeq); if (unlikely(__pyx_t_10 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1254; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_t_11 = ((__pyx_t_10 > 0) != 0);
      __pyx_t_12 = __pyx_t_11;
    } else {
      __pyx_t_12 = __pyx_t_1;
    }
    if (!__pyx_t_12) break;

    /* "assembler.pyx":1256
 *     while len(thisReadSeq) > 0 and len(thisRefSeq) > 0:
 * 
 *         if thisRefSeq[-1] == thisReadSeq[-1]:             # <<<<<<<<<<<<<<
 *             thisRefSeq = thisRefSeq[:-1]
 *             thisReadSeq = thisReadSeq[:-1]
 */
    __pyx_t_4 = __Pyx_GetItemInt(__pyx_v_thisRefSeq, -1, long, 1, __Pyx_PyInt_From_long, 0, 1, 0); if (unlikely(__pyx_t_4 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1256; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_8 = __Pyx_GetItemInt(__pyx_v_thisReadSeq, -1, long, 1, __Pyx_PyInt_From_long, 0, 1, 0); if (unlikely(__pyx_t_8 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1256; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = PyObject_RichCompare(__pyx_t_4, __pyx_t_8, Py_EQ); __Pyx_XGOTREF(__pyx_t_9); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_12 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_12 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    if (__pyx_t_12) {

      /* "assembler.pyx":1257
 * 
 *         if thisRefSeq[-1] == thisReadSeq[-1]:
 *             thisRefSeq = thisRefSeq[:-1]             # <<<<<<<<<<<<<<
 *             thisReadSeq = thisReadSeq[:-1]
 *         else:
 */
      __pyx_t_9 = __Pyx_PySequence_GetSlice(__pyx_v_thisRefSeq, 0, -1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_DECREF_SET(__pyx_v_thisRefSeq, ((PyObject*)__pyx_t_9));
      __pyx_t_9 = 0;

      /* "assembler.pyx":1258
 *         if thisRefSeq[-1] == thisReadSeq[-1]:
 *             thisRefSeq = thisRefSeq[:-1]
 *             thisReadSeq = thisReadSeq[:-1]             # <<<<<<<<<<<<<<
 *         else:
 *             break
 */
      __pyx_t_9 = __Pyx_PySequence_GetSlice(__pyx_v_thisReadSeq, 0, -1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1258; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_DECREF_SET(__pyx_v_thisReadSeq, ((PyObject*)__pyx_t_9));
      __pyx_t_9 = 0;
      goto __pyx_L11;
    }
    /*else*/ {

      /* "assembler.pyx":1260
 *             thisReadSeq = thisReadSeq[:-1]
 *         else:
 *             break             # <<<<<<<<<<<<<<
 * 
 *     # Trim leading reference sequence
 */
      goto __pyx_L10_break;
    }
    __pyx_L11:;
  }
  __pyx_L10_break:;

  /* "assembler.pyx":1263
 * 
 *     # Trim leading reference sequence
 *     while len(thisReadSeq) > 0 and len(thisRefSeq) > 0:             # <<<<<<<<<<<<<<
 * 
 *         if thisRefSeq[0] == thisReadSeq[0]:
 */
  while (1) {
    __pyx_t_10 = PyBytes_GET_SIZE(__pyx_v_thisReadSeq); if (unlikely(__pyx_t_10 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_12 = ((__pyx_t_10 > 0) != 0);
    if (__pyx_t_12) {
      __pyx_t_10 = PyBytes_GET_SIZE(__pyx_v_thisRefSeq); if (unlikely(__pyx_t_10 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_t_1 = ((__pyx_t_10 > 0) != 0);
      __pyx_t_11 = __pyx_t_1;
    } else {
      __pyx_t_11 = __pyx_t_12;
    }
    if (!__pyx_t_11) break;

    /* "assembler.pyx":1265
 *     while len(thisReadSeq) > 0 and len(thisRefSeq) > 0:
 * 
 *         if thisRefSeq[0] == thisReadSeq[0]:             # <<<<<<<<<<<<<<
 *             bubbleStartPos += 1
 *             thisRefSeq = thisRefSeq[1:]
 */
    __pyx_t_9 = __Pyx_GetItemInt(__pyx_v_thisRefSeq, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1265; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
    __Pyx_GOTREF(__pyx_t_9);
    __pyx_t_8 = __Pyx_GetItemInt(__pyx_v_thisReadSeq, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(__pyx_t_8 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1265; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_4 = PyObject_RichCompare(__pyx_t_9, __pyx_t_8, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_11 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_11 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (__pyx_t_11) {

      /* "assembler.pyx":1266
 * 
 *         if thisRefSeq[0] == thisReadSeq[0]:
 *             bubbleStartPos += 1             # <<<<<<<<<<<<<<
 *             thisRefSeq = thisRefSeq[1:]
 *             thisReadSeq = thisReadSeq[1:]
 */
      __pyx_v_bubbleStartPos = (__pyx_v_bubbleStartPos + 1);

      /* "assembler.pyx":1267
 *         if thisRefSeq[0] == thisReadSeq[0]:
 *             bubbleStartPos += 1
 *             thisRefSeq = thisRefSeq[1:]             # <<<<<<<<<<<<<<
 *             thisReadSeq = thisReadSeq[1:]
 *         else:
 */
      __pyx_t_4 = __Pyx_PySequence_GetSlice(__pyx_v_thisRefSeq, 1, PY_SSIZE_T_MAX); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF_SET(__pyx_v_thisRefSeq, ((PyObject*)__pyx_t_4));
      __pyx_t_4 = 0;

      /* "assembler.pyx":1268
 *             bubbleStartPos += 1
 *             thisRefSeq = thisRefSeq[1:]
 *             thisReadSeq = thisReadSeq[1:]             # <<<<<<<<<<<<<<
 *         else:
 *             break
 */
      __pyx_t_4 = __Pyx_PySequence_GetSlice(__pyx_v_thisReadSeq, 1, PY_SSIZE_T_MAX); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1268; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF_SET(__pyx_v_thisReadSeq, ((PyObject*)__pyx_t_4));
      __pyx_t_4 = 0;
      goto __pyx_L14;
    }
    /*else*/ {

      /* "assembler.pyx":1270
 *             thisReadSeq = thisReadSeq[1:]
 *         else:
 *             break             # <<<<<<<<<<<<<<
 * 
 *     #if verbosity >= 3:
 */
      goto __pyx_L13_break;
    }
    __pyx_L14:;
  }
  __pyx_L13_break:;

  /* "assembler.pyx":1275
 *     #    logger.debug("After trimming, candidate variant is %s:%s-%s %s --> %s" %(chrom, bubbleStartPos, bubbleEndPos, thisRefSeq, thisReadSeq))
 * 
 *     if verbosity >= 3 and abs(len(thisRefSeq) - len(thisReadSeq)) > 100:             # <<<<<<<<<<<<<<
 *         logger.info("Platypus assembler found candidate variant of size %s. %s:%s-%s %s --> %s" %(len(thisReadSeq) - len(thisRefSeq), chrom, bubbleStartPos, bubbleEndPos, thisRefSeq, thisReadSeq))
 * 
 */
  __pyx_t_11 = (__pyx_v_verbosity >= 3);
  if (__pyx_t_11) {
    __pyx_t_10 = PyBytes_GET_SIZE(__pyx_v_thisRefSeq); if (unlikely(__pyx_t_10 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_13 = PyBytes_GET_SIZE(__pyx_v_thisReadSeq); if (unlikely(__pyx_t_13 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_4 = PyInt_FromSsize_t((__pyx_t_10 - __pyx_t_13)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_8 = PyNumber_Absolute(__pyx_t_4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyObject_RichCompare(__pyx_t_8, __pyx_int_100, Py_GT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_12 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_12 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_1 = __pyx_t_12;
  } else {
    __pyx_t_1 = __pyx_t_11;
  }
  if (__pyx_t_1) {

    /* "assembler.pyx":1276
 * 
 *     if verbosity >= 3 and abs(len(thisRefSeq) - len(thisReadSeq)) > 100:
 *         logger.info("Platypus assembler found candidate variant of size %s. %s:%s-%s %s --> %s" %(len(thisReadSeq) - len(thisRefSeq), chrom, bubbleStartPos, bubbleEndPos, thisRefSeq, thisReadSeq))             # <<<<<<<<<<<<<<
 * 
 *     cdef int varLen = len(thisReadSeq) - len(thisRefSeq)
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_info); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_13 = PyBytes_GET_SIZE(__pyx_v_thisReadSeq); if (unlikely(__pyx_t_13 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_10 = PyBytes_GET_SIZE(__pyx_v_thisRefSeq); if (unlikely(__pyx_t_10 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_4 = PyInt_FromSsize_t((__pyx_t_13 - __pyx_t_10)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_9 = __Pyx_PyBytes_FromString(__pyx_v_chrom); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_9);
    __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_bubbleStartPos); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_bubbleEndPos); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_14 = PyTuple_New(6); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_14);
    PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_14, 1, __pyx_t_9);
    __Pyx_GIVEREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_14, 2, __pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_14, 3, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_thisRefSeq);
    PyTuple_SET_ITEM(__pyx_t_14, 4, __pyx_v_thisRefSeq);
    __Pyx_GIVEREF(__pyx_v_thisRefSeq);
    __Pyx_INCREF(__pyx_v_thisReadSeq);
    PyTuple_SET_ITEM(__pyx_t_14, 5, __pyx_v_thisReadSeq);
    __Pyx_GIVEREF(__pyx_v_thisReadSeq);
    __pyx_t_4 = 0;
    __pyx_t_9 = 0;
    __pyx_t_7 = 0;
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_Platypus_assembler_found_candida, __pyx_t_14); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    __pyx_t_14 = PyTuple_New(1); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_14);
    PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_14, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L15;
  }
  __pyx_L15:;

  /* "assembler.pyx":1278
 *         logger.info("Platypus assembler found candidate variant of size %s. %s:%s-%s %s --> %s" %(len(thisReadSeq) - len(thisRefSeq), chrom, bubbleStartPos, bubbleEndPos, thisRefSeq, thisReadSeq))
 * 
 *     cdef int varLen = len(thisReadSeq) - len(thisRefSeq)             # <<<<<<<<<<<<<<
 *     cdef int varStartPos = bubbleStartPos
 * 
 */
  __pyx_t_10 = PyBytes_GET_SIZE(__pyx_v_thisReadSeq); if (unlikely(__pyx_t_10 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_13 = PyBytes_GET_SIZE(__pyx_v_thisRefSeq); if (unlikely(__pyx_t_13 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_varLen = (__pyx_t_10 - __pyx_t_13);

  /* "assembler.pyx":1279
 * 
 *     cdef int varLen = len(thisReadSeq) - len(thisRefSeq)
 *     cdef int varStartPos = bubbleStartPos             # <<<<<<<<<<<<<<
 * 
 *     #if varLen == 0:
 */
  __pyx_v_varStartPos = __pyx_v_bubbleStartPos;

  /* "assembler.pyx":1291
 *     #    logger.debug("Assembler found large variant %s:%s, %s --> %s. Length = %s" %(chrom, varStartPos, thisRefSeq, thisReadSeq, abs(len(thisRefSeq) - len(thisReadSeq))))
 * 
 *     return Variant(chrom, varStartPos, thisRefSeq, thisReadSeq, 0, ASSEMBLER_VAR)             # <<<<<<<<<<<<<<
 * 
 * ####################################################################################################
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_chrom); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_14 = __Pyx_PyInt_From_int(__pyx_v_varStartPos); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_14);
  __pyx_t_8 = __Pyx_PyInt_From_int(__pyx_v_7variant_ASSEMBLER_VAR); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_7 = PyTuple_New(6); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_7);
  PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_14);
  __Pyx_GIVEREF(__pyx_t_14);
  __Pyx_INCREF(__pyx_v_thisRefSeq);
  PyTuple_SET_ITEM(__pyx_t_7, 2, __pyx_v_thisRefSeq);
  __Pyx_GIVEREF(__pyx_v_thisRefSeq);
  __Pyx_INCREF(__pyx_v_thisReadSeq);
  PyTuple_SET_ITEM(__pyx_t_7, 3, __pyx_v_thisReadSeq);
  __Pyx_GIVEREF(__pyx_v_thisReadSeq);
  __Pyx_INCREF(__pyx_int_0);
  PyTuple_SET_ITEM(__pyx_t_7, 4, __pyx_int_0);
  __Pyx_GIVEREF(__pyx_int_0);
  PyTuple_SET_ITEM(__pyx_t_7, 5, __pyx_t_8);
  __Pyx_GIVEREF(__pyx_t_8);
  __pyx_t_3 = 0;
  __pyx_t_14 = 0;
  __pyx_t_8 = 0;
  __pyx_t_8 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7variant_Variant)), __pyx_t_7, NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_r = ((struct __pyx_obj_7variant_Variant *)__pyx_t_8);
  __pyx_t_8 = 0;
  goto __pyx_L0;

  /* "assembler.pyx":1196
 * ###################################################################################################
 * 
 * cdef Variant extractVarFromBubblePath(DeBruijnGraph* theGraph, Path* bubblePath, char* refSeq, char* chrom, int refStart, int refEnd, int verbosity):             # <<<<<<<<<<<<<<
 *     """
 *     Construct and return a representation of the variant implied by this bubble in the graph.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_14);
  __Pyx_AddTraceback("assembler.extractVarFromBubblePath", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_thisRefSeq);
  __Pyx_XDECREF(__pyx_v_thisReadSeq);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":1295
 * ####################################################################################################
 * 
 * cdef void loadReferenceIntoGraph(DeBruijnGraph* theGraph, char* refSeq, int refStart, int kmerSize):             # <<<<<<<<<<<<<<
 *     """
 *     Load k-mers from the specified reference sequence into the
 */

static void __pyx_f_9assembler_loadReferenceIntoGraph(__pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph, char *__pyx_v_refSeq, int __pyx_v_refStart, int __pyx_v_kmerSize) {
  int __pyx_v_i;
  int __pyx_v_lenRef;
  __pyx_t_9assembler_Node __pyx_v_tempStartNode;
  __pyx_t_9assembler_Node __pyx_v_tempEndNode;
  __Pyx_RefNannyDeclarations
  long __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("loadReferenceIntoGraph", 0);

  /* "assembler.pyx":1300
 *     graph.
 *     """
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef int lenRef = strlen(refSeq)
 *     cdef Node tempStartNode
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":1301
 *     """
 *     cdef int i = 0
 *     cdef int lenRef = strlen(refSeq)             # <<<<<<<<<<<<<<
 *     cdef Node tempStartNode
 *     cdef Node tempEndNode
 */
  __pyx_v_lenRef = strlen(__pyx_v_refSeq);

  /* "assembler.pyx":1305
 *     cdef Node tempEndNode
 * 
 *     for i in range( (lenRef-kmerSize) - 1):             # <<<<<<<<<<<<<<
 * 
 *         tempStartNode.sequence = refSeq + i
 */
  __pyx_t_1 = ((__pyx_v_lenRef - __pyx_v_kmerSize) - 1);
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":1307
 *     for i in range( (lenRef-kmerSize) - 1):
 * 
 *         tempStartNode.sequence = refSeq + i             # <<<<<<<<<<<<<<
 *         tempStartNode.kmerSize = kmerSize
 *         tempStartNode.colours = REF
 */
    __pyx_v_tempStartNode.sequence = (__pyx_v_refSeq + __pyx_v_i);

    /* "assembler.pyx":1308
 * 
 *         tempStartNode.sequence = refSeq + i
 *         tempStartNode.kmerSize = kmerSize             # <<<<<<<<<<<<<<
 *         tempStartNode.colours = REF
 *         tempStartNode.position = refStart + i
 */
    __pyx_v_tempStartNode.kmerSize = __pyx_v_kmerSize;

    /* "assembler.pyx":1309
 *         tempStartNode.sequence = refSeq + i
 *         tempStartNode.kmerSize = kmerSize
 *         tempStartNode.colours = REF             # <<<<<<<<<<<<<<
 *         tempStartNode.position = refStart + i
 *         tempStartNode.weight = 1
 */
    __pyx_v_tempStartNode.colours = __pyx_v_9assembler_REF;

    /* "assembler.pyx":1310
 *         tempStartNode.kmerSize = kmerSize
 *         tempStartNode.colours = REF
 *         tempStartNode.position = refStart + i             # <<<<<<<<<<<<<<
 *         tempStartNode.weight = 1
 * 
 */
    __pyx_v_tempStartNode.position = (__pyx_v_refStart + __pyx_v_i);

    /* "assembler.pyx":1311
 *         tempStartNode.colours = REF
 *         tempStartNode.position = refStart + i
 *         tempStartNode.weight = 1             # <<<<<<<<<<<<<<
 * 
 *         tempEndNode.sequence = refSeq + i + 1
 */
    __pyx_v_tempStartNode.weight = 1.0;

    /* "assembler.pyx":1313
 *         tempStartNode.weight = 1
 * 
 *         tempEndNode.sequence = refSeq + i + 1             # <<<<<<<<<<<<<<
 *         tempEndNode.kmerSize = kmerSize
 *         tempEndNode.colours = REF
 */
    __pyx_v_tempEndNode.sequence = ((__pyx_v_refSeq + __pyx_v_i) + 1);

    /* "assembler.pyx":1314
 * 
 *         tempEndNode.sequence = refSeq + i + 1
 *         tempEndNode.kmerSize = kmerSize             # <<<<<<<<<<<<<<
 *         tempEndNode.colours = REF
 *         tempEndNode.position = refStart + i + 1
 */
    __pyx_v_tempEndNode.kmerSize = __pyx_v_kmerSize;

    /* "assembler.pyx":1315
 *         tempEndNode.sequence = refSeq + i + 1
 *         tempEndNode.kmerSize = kmerSize
 *         tempEndNode.colours = REF             # <<<<<<<<<<<<<<
 *         tempEndNode.position = refStart + i + 1
 *         tempEndNode.weight = 1
 */
    __pyx_v_tempEndNode.colours = __pyx_v_9assembler_REF;

    /* "assembler.pyx":1316
 *         tempEndNode.kmerSize = kmerSize
 *         tempEndNode.colours = REF
 *         tempEndNode.position = refStart + i + 1             # <<<<<<<<<<<<<<
 *         tempEndNode.weight = 1
 * 
 */
    __pyx_v_tempEndNode.position = ((__pyx_v_refStart + __pyx_v_i) + 1);

    /* "assembler.pyx":1317
 *         tempEndNode.colours = REF
 *         tempEndNode.position = refStart + i + 1
 *         tempEndNode.weight = 1             # <<<<<<<<<<<<<<
 * 
 *         DeBruijnGraph_AddEdge(theGraph, &tempStartNode, &tempEndNode, 1)
 */
    __pyx_v_tempEndNode.weight = 1.0;

    /* "assembler.pyx":1319
 *         tempEndNode.weight = 1
 * 
 *         DeBruijnGraph_AddEdge(theGraph, &tempStartNode, &tempEndNode, 1)             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
    __pyx_f_9assembler_DeBruijnGraph_AddEdge(__pyx_v_theGraph, (&__pyx_v_tempStartNode), (&__pyx_v_tempEndNode), 1.0);
  }

  /* "assembler.pyx":1295
 * ####################################################################################################
 * 
 * cdef void loadReferenceIntoGraph(DeBruijnGraph* theGraph, char* refSeq, int refStart, int kmerSize):             # <<<<<<<<<<<<<<
 *     """
 *     Load k-mers from the specified reference sequence into the
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":1323
 * ###################################################################################################
 * 
 * cdef char* createReverseComplementSequence(char* theSeq, int seqLen):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a string containing the reverse complement of the specified
 */

static char *__pyx_f_9assembler_createReverseComplementSequence(char *__pyx_v_theSeq, int __pyx_v_seqLen) {
  char *__pyx_v_newSeq;
  int __pyx_v_i;
  char *__pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  __Pyx_RefNannySetupContext("createReverseComplementSequence", 0);

  /* "assembler.pyx":1328
 *     sequence.
 *     """
 *     cdef char* newSeq = <char*>(malloc(sizeof(char)*(seqLen+1)))             # <<<<<<<<<<<<<<
 *     cdef int i = 0
 * 
 */
  __pyx_v_newSeq = ((char *)malloc(((sizeof(char)) * (__pyx_v_seqLen + 1))));

  /* "assembler.pyx":1329
 *     """
 *     cdef char* newSeq = <char*>(malloc(sizeof(char)*(seqLen+1)))
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 * 
 *     for i in range(seqLen):
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":1331
 *     cdef int i = 0
 * 
 *     for i in range(seqLen):             # <<<<<<<<<<<<<<
 *         if theSeq[i] == 'A':
 *             newSeq[seqLen - i - 1] = 'T'
 */
  __pyx_t_1 = __pyx_v_seqLen;
  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
    __pyx_v_i = __pyx_t_2;

    /* "assembler.pyx":1332
 * 
 *     for i in range(seqLen):
 *         if theSeq[i] == 'A':             # <<<<<<<<<<<<<<
 *             newSeq[seqLen - i - 1] = 'T'
 *         elif theSeq[i] == 'T':
 */
    __pyx_t_3 = (((__pyx_v_theSeq[__pyx_v_i]) == 'A') != 0);
    if (__pyx_t_3) {

      /* "assembler.pyx":1333
 *     for i in range(seqLen):
 *         if theSeq[i] == 'A':
 *             newSeq[seqLen - i - 1] = 'T'             # <<<<<<<<<<<<<<
 *         elif theSeq[i] == 'T':
 *             newSeq[seqLen - i - 1] = 'A'
 */
      (__pyx_v_newSeq[((__pyx_v_seqLen - __pyx_v_i) - 1)]) = 'T';
      goto __pyx_L5;
    }

    /* "assembler.pyx":1334
 *         if theSeq[i] == 'A':
 *             newSeq[seqLen - i - 1] = 'T'
 *         elif theSeq[i] == 'T':             # <<<<<<<<<<<<<<
 *             newSeq[seqLen - i - 1] = 'A'
 *         elif theSeq[i] == 'C':
 */
    __pyx_t_3 = (((__pyx_v_theSeq[__pyx_v_i]) == 'T') != 0);
    if (__pyx_t_3) {

      /* "assembler.pyx":1335
 *             newSeq[seqLen - i - 1] = 'T'
 *         elif theSeq[i] == 'T':
 *             newSeq[seqLen - i - 1] = 'A'             # <<<<<<<<<<<<<<
 *         elif theSeq[i] == 'C':
 *             newSeq[seqLen - i - 1] = 'G'
 */
      (__pyx_v_newSeq[((__pyx_v_seqLen - __pyx_v_i) - 1)]) = 'A';
      goto __pyx_L5;
    }

    /* "assembler.pyx":1336
 *         elif theSeq[i] == 'T':
 *             newSeq[seqLen - i - 1] = 'A'
 *         elif theSeq[i] == 'C':             # <<<<<<<<<<<<<<
 *             newSeq[seqLen - i - 1] = 'G'
 *         elif theSeq[i] == 'G':
 */
    __pyx_t_3 = (((__pyx_v_theSeq[__pyx_v_i]) == 'C') != 0);
    if (__pyx_t_3) {

      /* "assembler.pyx":1337
 *             newSeq[seqLen - i - 1] = 'A'
 *         elif theSeq[i] == 'C':
 *             newSeq[seqLen - i - 1] = 'G'             # <<<<<<<<<<<<<<
 *         elif theSeq[i] == 'G':
 *             newSeq[seqLen - i - 1] = 'C'
 */
      (__pyx_v_newSeq[((__pyx_v_seqLen - __pyx_v_i) - 1)]) = 'G';
      goto __pyx_L5;
    }

    /* "assembler.pyx":1338
 *         elif theSeq[i] == 'C':
 *             newSeq[seqLen - i - 1] = 'G'
 *         elif theSeq[i] == 'G':             # <<<<<<<<<<<<<<
 *             newSeq[seqLen - i - 1] = 'C'
 *         else:
 */
    __pyx_t_3 = (((__pyx_v_theSeq[__pyx_v_i]) == 'G') != 0);
    if (__pyx_t_3) {

      /* "assembler.pyx":1339
 *             newSeq[seqLen - i - 1] = 'G'
 *         elif theSeq[i] == 'G':
 *             newSeq[seqLen - i - 1] = 'C'             # <<<<<<<<<<<<<<
 *         else:
 *             newSeq[seqLen - i - 1] = theSeq[i]
 */
      (__pyx_v_newSeq[((__pyx_v_seqLen - __pyx_v_i) - 1)]) = 'C';
      goto __pyx_L5;
    }
    /*else*/ {

      /* "assembler.pyx":1341
 *             newSeq[seqLen - i - 1] = 'C'
 *         else:
 *             newSeq[seqLen - i - 1] = theSeq[i]             # <<<<<<<<<<<<<<
 * 
 *     newSeq[seqLen] = 0
 */
      (__pyx_v_newSeq[((__pyx_v_seqLen - __pyx_v_i) - 1)]) = (__pyx_v_theSeq[__pyx_v_i]);
    }
    __pyx_L5:;
  }

  /* "assembler.pyx":1343
 *             newSeq[seqLen - i - 1] = theSeq[i]
 * 
 *     newSeq[seqLen] = 0             # <<<<<<<<<<<<<<
 *     return newSeq
 * 
 */
  (__pyx_v_newSeq[__pyx_v_seqLen]) = 0;

  /* "assembler.pyx":1344
 * 
 *     newSeq[seqLen] = 0
 *     return newSeq             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_r = __pyx_v_newSeq;
  goto __pyx_L0;

  /* "assembler.pyx":1323
 * ###################################################################################################
 * 
 * cdef char* createReverseComplementSequence(char* theSeq, int seqLen):             # <<<<<<<<<<<<<<
 *     """
 *     Create and return a string containing the reverse complement of the specified
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "assembler.pyx":1348
 * ###################################################################################################
 * 
 * cdef void loadReadIntoGraph(cAlignedRead* theRead, DeBruijnGraph* theGraph, int minQual, int kmerSize):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

static void __pyx_f_9assembler_loadReadIntoGraph(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead, __pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph, int __pyx_v_minQual, int __pyx_v_kmerSize) {
  char *__pyx_v_theSeq;
  char *__pyx_v_theQuals;
  int __pyx_v_length;
  CYTHON_UNUSED int __pyx_v_startPos;
  int __pyx_v_i;
  int __pyx_v_j;
  int __pyx_v_thisMinQual;
  int __pyx_v_NsInKmer;
  __pyx_t_9assembler_Node __pyx_v_tempStartNode;
  __pyx_t_9assembler_Node __pyx_v_tempEndNode;
  __Pyx_RefNannyDeclarations
  char *__pyx_t_1;
  short __pyx_t_2;
  int __pyx_t_3;
  long __pyx_t_4;
  long __pyx_t_5;
  int __pyx_t_6;
  char __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  int __pyx_t_10;
  int __pyx_t_11;
  int __pyx_t_12;
  __Pyx_RefNannySetupContext("loadReadIntoGraph", 0);

  /* "assembler.pyx":1351
 *     """
 *     """
 *     cdef char* theSeq = theRead.seq             # <<<<<<<<<<<<<<
 *     cdef char* theQuals = theRead.qual
 *     cdef int length = theRead.rlen
 */
  __pyx_t_1 = __pyx_v_theRead->seq;
  __pyx_v_theSeq = __pyx_t_1;

  /* "assembler.pyx":1352
 *     """
 *     cdef char* theSeq = theRead.seq
 *     cdef char* theQuals = theRead.qual             # <<<<<<<<<<<<<<
 *     cdef int length = theRead.rlen
 *     cdef int startPos = theRead.pos
 */
  __pyx_t_1 = __pyx_v_theRead->qual;
  __pyx_v_theQuals = __pyx_t_1;

  /* "assembler.pyx":1353
 *     cdef char* theSeq = theRead.seq
 *     cdef char* theQuals = theRead.qual
 *     cdef int length = theRead.rlen             # <<<<<<<<<<<<<<
 *     cdef int startPos = theRead.pos
 *     cdef int i = 0
 */
  __pyx_t_2 = __pyx_v_theRead->rlen;
  __pyx_v_length = __pyx_t_2;

  /* "assembler.pyx":1354
 *     cdef char* theQuals = theRead.qual
 *     cdef int length = theRead.rlen
 *     cdef int startPos = theRead.pos             # <<<<<<<<<<<<<<
 *     cdef int i = 0
 *     cdef int j = 0
 */
  __pyx_t_3 = __pyx_v_theRead->pos;
  __pyx_v_startPos = __pyx_t_3;

  /* "assembler.pyx":1355
 *     cdef int length = theRead.rlen
 *     cdef int startPos = theRead.pos
 *     cdef int i = 0             # <<<<<<<<<<<<<<
 *     cdef int j = 0
 *     cdef int thisMinQual = 100000000
 */
  __pyx_v_i = 0;

  /* "assembler.pyx":1356
 *     cdef int startPos = theRead.pos
 *     cdef int i = 0
 *     cdef int j = 0             # <<<<<<<<<<<<<<
 *     cdef int thisMinQual = 100000000
 *     cdef int NsInKmer = 0
 */
  __pyx_v_j = 0;

  /* "assembler.pyx":1357
 *     cdef int i = 0
 *     cdef int j = 0
 *     cdef int thisMinQual = 100000000             # <<<<<<<<<<<<<<
 *     cdef int NsInKmer = 0
 *     cdef Node tempStartNode
 */
  __pyx_v_thisMinQual = 100000000;

  /* "assembler.pyx":1358
 *     cdef int j = 0
 *     cdef int thisMinQual = 100000000
 *     cdef int NsInKmer = 0             # <<<<<<<<<<<<<<
 *     cdef Node tempStartNode
 *     cdef Node tempEndNode
 */
  __pyx_v_NsInKmer = 0;

  /* "assembler.pyx":1362
 *     cdef Node tempEndNode
 * 
 *     for i in range( (length-kmerSize) - 1):             # <<<<<<<<<<<<<<
 *         thisMinQual = 100000000
 *         NsInKmer = 0
 */
  __pyx_t_4 = ((__pyx_v_length - __pyx_v_kmerSize) - 1);
  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_4; __pyx_t_3+=1) {
    __pyx_v_i = __pyx_t_3;

    /* "assembler.pyx":1363
 * 
 *     for i in range( (length-kmerSize) - 1):
 *         thisMinQual = 100000000             # <<<<<<<<<<<<<<
 *         NsInKmer = 0
 * 
 */
    __pyx_v_thisMinQual = 100000000;

    /* "assembler.pyx":1364
 *     for i in range( (length-kmerSize) - 1):
 *         thisMinQual = 100000000
 *         NsInKmer = 0             # <<<<<<<<<<<<<<
 * 
 *         for j in range(i, i+kmerSize+1):
 */
    __pyx_v_NsInKmer = 0;

    /* "assembler.pyx":1366
 *         NsInKmer = 0
 * 
 *         for j in range(i, i+kmerSize+1):             # <<<<<<<<<<<<<<
 * 
 *             thisMinQual = min(thisMinQual, theQuals[j])
 */
    __pyx_t_5 = ((__pyx_v_i + __pyx_v_kmerSize) + 1);
    for (__pyx_t_6 = __pyx_v_i; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
      __pyx_v_j = __pyx_t_6;

      /* "assembler.pyx":1368
 *         for j in range(i, i+kmerSize+1):
 * 
 *             thisMinQual = min(thisMinQual, theQuals[j])             # <<<<<<<<<<<<<<
 * 
 *             if theSeq[j] == 'N':
 */
      __pyx_t_7 = (__pyx_v_theQuals[__pyx_v_j]);
      __pyx_t_8 = __pyx_v_thisMinQual;
      if (((__pyx_t_7 < __pyx_t_8) != 0)) {
        __pyx_t_9 = __pyx_t_7;
      } else {
        __pyx_t_9 = __pyx_t_8;
      }
      __pyx_v_thisMinQual = __pyx_t_9;

      /* "assembler.pyx":1370
 *             thisMinQual = min(thisMinQual, theQuals[j])
 * 
 *             if theSeq[j] == 'N':             # <<<<<<<<<<<<<<
 *                 NsInKmer = 1
 * 
 */
      __pyx_t_10 = (((__pyx_v_theSeq[__pyx_v_j]) == 'N') != 0);
      if (__pyx_t_10) {

        /* "assembler.pyx":1371
 * 
 *             if theSeq[j] == 'N':
 *                 NsInKmer = 1             # <<<<<<<<<<<<<<
 * 
 *         if thisMinQual >= minQual and NsInKmer == 0:
 */
        __pyx_v_NsInKmer = 1;
        goto __pyx_L7;
      }
      __pyx_L7:;
    }

    /* "assembler.pyx":1373
 *                 NsInKmer = 1
 * 
 *         if thisMinQual >= minQual and NsInKmer == 0:             # <<<<<<<<<<<<<<
 * 
 *             tempStartNode.sequence = theSeq + i
 */
    __pyx_t_10 = ((__pyx_v_thisMinQual >= __pyx_v_minQual) != 0);
    if (__pyx_t_10) {
      __pyx_t_11 = ((__pyx_v_NsInKmer == 0) != 0);
      __pyx_t_12 = __pyx_t_11;
    } else {
      __pyx_t_12 = __pyx_t_10;
    }
    if (__pyx_t_12) {

      /* "assembler.pyx":1375
 *         if thisMinQual >= minQual and NsInKmer == 0:
 * 
 *             tempStartNode.sequence = theSeq + i             # <<<<<<<<<<<<<<
 *             tempStartNode.kmerSize = kmerSize
 *             tempStartNode.colours = READ
 */
      __pyx_v_tempStartNode.sequence = (__pyx_v_theSeq + __pyx_v_i);

      /* "assembler.pyx":1376
 * 
 *             tempStartNode.sequence = theSeq + i
 *             tempStartNode.kmerSize = kmerSize             # <<<<<<<<<<<<<<
 *             tempStartNode.colours = READ
 *             tempStartNode.position = - 1
 */
      __pyx_v_tempStartNode.kmerSize = __pyx_v_kmerSize;

      /* "assembler.pyx":1377
 *             tempStartNode.sequence = theSeq + i
 *             tempStartNode.kmerSize = kmerSize
 *             tempStartNode.colours = READ             # <<<<<<<<<<<<<<
 *             tempStartNode.position = - 1
 *             tempStartNode.weight = thisMinQual
 */
      __pyx_v_tempStartNode.colours = __pyx_v_9assembler_READ;

      /* "assembler.pyx":1378
 *             tempStartNode.kmerSize = kmerSize
 *             tempStartNode.colours = READ
 *             tempStartNode.position = - 1             # <<<<<<<<<<<<<<
 *             tempStartNode.weight = thisMinQual
 * 
 */
      __pyx_v_tempStartNode.position = -1;

      /* "assembler.pyx":1379
 *             tempStartNode.colours = READ
 *             tempStartNode.position = - 1
 *             tempStartNode.weight = thisMinQual             # <<<<<<<<<<<<<<
 * 
 *             tempEndNode.sequence = theSeq + i + 1
 */
      __pyx_v_tempStartNode.weight = __pyx_v_thisMinQual;

      /* "assembler.pyx":1381
 *             tempStartNode.weight = thisMinQual
 * 
 *             tempEndNode.sequence = theSeq + i + 1             # <<<<<<<<<<<<<<
 *             tempEndNode.kmerSize = kmerSize
 *             tempEndNode.colours = READ
 */
      __pyx_v_tempEndNode.sequence = ((__pyx_v_theSeq + __pyx_v_i) + 1);

      /* "assembler.pyx":1382
 * 
 *             tempEndNode.sequence = theSeq + i + 1
 *             tempEndNode.kmerSize = kmerSize             # <<<<<<<<<<<<<<
 *             tempEndNode.colours = READ
 *             tempEndNode.position = -1
 */
      __pyx_v_tempEndNode.kmerSize = __pyx_v_kmerSize;

      /* "assembler.pyx":1383
 *             tempEndNode.sequence = theSeq + i + 1
 *             tempEndNode.kmerSize = kmerSize
 *             tempEndNode.colours = READ             # <<<<<<<<<<<<<<
 *             tempEndNode.position = -1
 *             tempEndNode.weight = thisMinQual
 */
      __pyx_v_tempEndNode.colours = __pyx_v_9assembler_READ;

      /* "assembler.pyx":1384
 *             tempEndNode.kmerSize = kmerSize
 *             tempEndNode.colours = READ
 *             tempEndNode.position = -1             # <<<<<<<<<<<<<<
 *             tempEndNode.weight = thisMinQual
 * 
 */
      __pyx_v_tempEndNode.position = -1;

      /* "assembler.pyx":1385
 *             tempEndNode.colours = READ
 *             tempEndNode.position = -1
 *             tempEndNode.weight = thisMinQual             # <<<<<<<<<<<<<<
 * 
 *             DeBruijnGraph_AddEdge(theGraph, &tempStartNode, &tempEndNode, thisMinQual)
 */
      __pyx_v_tempEndNode.weight = __pyx_v_thisMinQual;

      /* "assembler.pyx":1387
 *             tempEndNode.weight = thisMinQual
 * 
 *             DeBruijnGraph_AddEdge(theGraph, &tempStartNode, &tempEndNode, thisMinQual)             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
      __pyx_f_9assembler_DeBruijnGraph_AddEdge(__pyx_v_theGraph, (&__pyx_v_tempStartNode), (&__pyx_v_tempEndNode), __pyx_v_thisMinQual);
      goto __pyx_L8;
    }
    __pyx_L8:;
  }

  /* "assembler.pyx":1348
 * ###################################################################################################
 * 
 * cdef void loadReadIntoGraph(cAlignedRead* theRead, DeBruijnGraph* theGraph, int minQual, int kmerSize):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":1391
 * ###################################################################################################
 * 
 * cdef void loadBAMDataIntoGraph(DeBruijnGraph* theGraph, list readBuffers, int assembleBadReads, int assembleBrokenPairs, int minQual, int kmerSize):             # <<<<<<<<<<<<<<
 *     """
 *     Load k-mers from the specified BAM file into the graph. K-mers containing
 */

static void __pyx_f_9assembler_loadBAMDataIntoGraph(__pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph, PyObject *__pyx_v_readBuffers, int __pyx_v_assembleBadReads, int __pyx_v_assembleBrokenPairs, int __pyx_v_minQual, int __pyx_v_kmerSize) {
  struct __pyx_obj_7cwindow_bamReadBuffer *__pyx_v_theBuffer = 0;
  __pyx_t_15samtoolsWrapper_cAlignedRead **__pyx_v_readStart;
  __pyx_t_15samtoolsWrapper_cAlignedRead **__pyx_v_readEnd;
  __pyx_t_15samtoolsWrapper_cAlignedRead **__pyx_v_badReadStart;
  __pyx_t_15samtoolsWrapper_cAlignedRead **__pyx_v_badReadEnd;
  __pyx_t_15samtoolsWrapper_cAlignedRead **__pyx_v_brokenReadStart;
  __pyx_t_15samtoolsWrapper_cAlignedRead **__pyx_v_brokenReadEnd;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __pyx_t_15samtoolsWrapper_cAlignedRead **__pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("loadBAMDataIntoGraph", 0);

  /* "assembler.pyx":1398
 *     cdef bamReadBuffer theBuffer
 * 
 *     for theBuffer in readBuffers:             # <<<<<<<<<<<<<<
 * 
 *         readStart = theBuffer.reads.windowStart
 */
  if (unlikely(__pyx_v_readBuffers == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_1 = __pyx_v_readBuffers; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
  for (;;) {
    if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_COMPILING_IN_CPYTHON
    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    #endif
    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_7cwindow_bamReadBuffer))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_XDECREF_SET(__pyx_v_theBuffer, ((struct __pyx_obj_7cwindow_bamReadBuffer *)__pyx_t_3));
    __pyx_t_3 = 0;

    /* "assembler.pyx":1400
 *     for theBuffer in readBuffers:
 * 
 *         readStart = theBuffer.reads.windowStart             # <<<<<<<<<<<<<<
 *         readEnd = theBuffer.reads.windowEnd
 *         badReadStart = theBuffer.badReads.windowStart
 */
    __pyx_t_4 = __pyx_v_theBuffer->reads->windowStart;
    __pyx_v_readStart = __pyx_t_4;

    /* "assembler.pyx":1401
 * 
 *         readStart = theBuffer.reads.windowStart
 *         readEnd = theBuffer.reads.windowEnd             # <<<<<<<<<<<<<<
 *         badReadStart = theBuffer.badReads.windowStart
 *         badReadEnd = theBuffer.badReads.windowEnd
 */
    __pyx_t_4 = __pyx_v_theBuffer->reads->windowEnd;
    __pyx_v_readEnd = __pyx_t_4;

    /* "assembler.pyx":1402
 *         readStart = theBuffer.reads.windowStart
 *         readEnd = theBuffer.reads.windowEnd
 *         badReadStart = theBuffer.badReads.windowStart             # <<<<<<<<<<<<<<
 *         badReadEnd = theBuffer.badReads.windowEnd
 *         brokenReadStart = theBuffer.brokenMates.windowStart
 */
    __pyx_t_4 = __pyx_v_theBuffer->badReads->windowStart;
    __pyx_v_badReadStart = __pyx_t_4;

    /* "assembler.pyx":1403
 *         readEnd = theBuffer.reads.windowEnd
 *         badReadStart = theBuffer.badReads.windowStart
 *         badReadEnd = theBuffer.badReads.windowEnd             # <<<<<<<<<<<<<<
 *         brokenReadStart = theBuffer.brokenMates.windowStart
 *         brokenReadEnd = theBuffer.brokenMates.windowEnd
 */
    __pyx_t_4 = __pyx_v_theBuffer->badReads->windowEnd;
    __pyx_v_badReadEnd = __pyx_t_4;

    /* "assembler.pyx":1404
 *         badReadStart = theBuffer.badReads.windowStart
 *         badReadEnd = theBuffer.badReads.windowEnd
 *         brokenReadStart = theBuffer.brokenMates.windowStart             # <<<<<<<<<<<<<<
 *         brokenReadEnd = theBuffer.brokenMates.windowEnd
 * 
 */
    __pyx_t_4 = __pyx_v_theBuffer->brokenMates->windowStart;
    __pyx_v_brokenReadStart = __pyx_t_4;

    /* "assembler.pyx":1405
 *         badReadEnd = theBuffer.badReads.windowEnd
 *         brokenReadStart = theBuffer.brokenMates.windowStart
 *         brokenReadEnd = theBuffer.brokenMates.windowEnd             # <<<<<<<<<<<<<<
 * 
 *         while readStart != readEnd:
 */
    __pyx_t_4 = __pyx_v_theBuffer->brokenMates->windowEnd;
    __pyx_v_brokenReadEnd = __pyx_t_4;

    /* "assembler.pyx":1407
 *         brokenReadEnd = theBuffer.brokenMates.windowEnd
 * 
 *         while readStart != readEnd:             # <<<<<<<<<<<<<<
 *             if not Read_IsQCFail(readStart[0]):
 *                 loadReadIntoGraph(readStart[0], theGraph, minQual, kmerSize)
 */
    while (1) {
      __pyx_t_5 = ((__pyx_v_readStart != __pyx_v_readEnd) != 0);
      if (!__pyx_t_5) break;

      /* "assembler.pyx":1408
 * 
 *         while readStart != readEnd:
 *             if not Read_IsQCFail(readStart[0]):             # <<<<<<<<<<<<<<
 *                 loadReadIntoGraph(readStart[0], theGraph, minQual, kmerSize)
 * 
 */
      __pyx_t_5 = ((!(__pyx_f_15samtoolsWrapper_Read_IsQCFail((__pyx_v_readStart[0])) != 0)) != 0);
      if (__pyx_t_5) {

        /* "assembler.pyx":1409
 *         while readStart != readEnd:
 *             if not Read_IsQCFail(readStart[0]):
 *                 loadReadIntoGraph(readStart[0], theGraph, minQual, kmerSize)             # <<<<<<<<<<<<<<
 * 
 *             readStart += 1
 */
        __pyx_f_9assembler_loadReadIntoGraph((__pyx_v_readStart[0]), __pyx_v_theGraph, __pyx_v_minQual, __pyx_v_kmerSize);
        goto __pyx_L7;
      }
      __pyx_L7:;

      /* "assembler.pyx":1411
 *                 loadReadIntoGraph(readStart[0], theGraph, minQual, kmerSize)
 * 
 *             readStart += 1             # <<<<<<<<<<<<<<
 * 
 *         if assembleBadReads:
 */
      __pyx_v_readStart = (__pyx_v_readStart + 1);
    }

    /* "assembler.pyx":1413
 *             readStart += 1
 * 
 *         if assembleBadReads:             # <<<<<<<<<<<<<<
 *             while badReadStart != badReadEnd:
 *                 if not Read_IsQCFail(badReadStart[0]):
 */
    __pyx_t_5 = (__pyx_v_assembleBadReads != 0);
    if (__pyx_t_5) {

      /* "assembler.pyx":1414
 * 
 *         if assembleBadReads:
 *             while badReadStart != badReadEnd:             # <<<<<<<<<<<<<<
 *                 if not Read_IsQCFail(badReadStart[0]):
 *                     loadReadIntoGraph(badReadStart[0], theGraph, minQual, kmerSize)
 */
      while (1) {
        __pyx_t_5 = ((__pyx_v_badReadStart != __pyx_v_badReadEnd) != 0);
        if (!__pyx_t_5) break;

        /* "assembler.pyx":1415
 *         if assembleBadReads:
 *             while badReadStart != badReadEnd:
 *                 if not Read_IsQCFail(badReadStart[0]):             # <<<<<<<<<<<<<<
 *                     loadReadIntoGraph(badReadStart[0], theGraph, minQual, kmerSize)
 * 
 */
        __pyx_t_5 = ((!(__pyx_f_15samtoolsWrapper_Read_IsQCFail((__pyx_v_badReadStart[0])) != 0)) != 0);
        if (__pyx_t_5) {

          /* "assembler.pyx":1416
 *             while badReadStart != badReadEnd:
 *                 if not Read_IsQCFail(badReadStart[0]):
 *                     loadReadIntoGraph(badReadStart[0], theGraph, minQual, kmerSize)             # <<<<<<<<<<<<<<
 * 
 *                 badReadStart += 1
 */
          __pyx_f_9assembler_loadReadIntoGraph((__pyx_v_badReadStart[0]), __pyx_v_theGraph, __pyx_v_minQual, __pyx_v_kmerSize);
          goto __pyx_L11;
        }
        __pyx_L11:;

        /* "assembler.pyx":1418
 *                     loadReadIntoGraph(badReadStart[0], theGraph, minQual, kmerSize)
 * 
 *                 badReadStart += 1             # <<<<<<<<<<<<<<
 * 
 *         if assembleBrokenPairs:
 */
        __pyx_v_badReadStart = (__pyx_v_badReadStart + 1);
      }
      goto __pyx_L8;
    }
    __pyx_L8:;

    /* "assembler.pyx":1420
 *                 badReadStart += 1
 * 
 *         if assembleBrokenPairs:             # <<<<<<<<<<<<<<
 *             while brokenReadStart != brokenReadEnd:
 *                 if not Read_IsQCFail(brokenReadStart[0]):
 */
    __pyx_t_5 = (__pyx_v_assembleBrokenPairs != 0);
    if (__pyx_t_5) {

      /* "assembler.pyx":1421
 * 
 *         if assembleBrokenPairs:
 *             while brokenReadStart != brokenReadEnd:             # <<<<<<<<<<<<<<
 *                 if not Read_IsQCFail(brokenReadStart[0]):
 *                     loadReadIntoGraph(brokenReadStart[0], theGraph, minQual, kmerSize)
 */
      while (1) {
        __pyx_t_5 = ((__pyx_v_brokenReadStart != __pyx_v_brokenReadEnd) != 0);
        if (!__pyx_t_5) break;

        /* "assembler.pyx":1422
 *         if assembleBrokenPairs:
 *             while brokenReadStart != brokenReadEnd:
 *                 if not Read_IsQCFail(brokenReadStart[0]):             # <<<<<<<<<<<<<<
 *                     loadReadIntoGraph(brokenReadStart[0], theGraph, minQual, kmerSize)
 * 
 */
        __pyx_t_5 = ((!(__pyx_f_15samtoolsWrapper_Read_IsQCFail((__pyx_v_brokenReadStart[0])) != 0)) != 0);
        if (__pyx_t_5) {

          /* "assembler.pyx":1423
 *             while brokenReadStart != brokenReadEnd:
 *                 if not Read_IsQCFail(brokenReadStart[0]):
 *                     loadReadIntoGraph(brokenReadStart[0], theGraph, minQual, kmerSize)             # <<<<<<<<<<<<<<
 * 
 *                 brokenReadStart += 1
 */
          __pyx_f_9assembler_loadReadIntoGraph((__pyx_v_brokenReadStart[0]), __pyx_v_theGraph, __pyx_v_minQual, __pyx_v_kmerSize);
          goto __pyx_L15;
        }
        __pyx_L15:;

        /* "assembler.pyx":1425
 *                     loadReadIntoGraph(brokenReadStart[0], theGraph, minQual, kmerSize)
 * 
 *                 brokenReadStart += 1             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
        __pyx_v_brokenReadStart = (__pyx_v_brokenReadStart + 1);
      }
      goto __pyx_L12;
    }
    __pyx_L12:;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "assembler.pyx":1391
 * ###################################################################################################
 * 
 * cdef void loadBAMDataIntoGraph(DeBruijnGraph* theGraph, list readBuffers, int assembleBadReads, int assembleBrokenPairs, int minQual, int kmerSize):             # <<<<<<<<<<<<<<
 *     """
 *     Load k-mers from the specified BAM file into the graph. K-mers containing
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_WriteUnraisable("assembler.loadBAMDataIntoGraph", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_theBuffer);
  __Pyx_RefNannyFinishContext();
}

/* "assembler.pyx":1429
 * ###################################################################################################
 * 
 * cdef list assembleReadsAndDetectVariants(char* chrom, int assemStart, int assemEnd, int refStart, int refEnd, list readBuffers, char* refSeq, options):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

static PyObject *__pyx_f_9assembler_assembleReadsAndDetectVariants(char *__pyx_v_chrom, int __pyx_v_assemStart, int __pyx_v_assemEnd, int __pyx_v_refStart, int __pyx_v_refEnd, PyObject *__pyx_v_readBuffers, char *__pyx_v_refSeq, PyObject *__pyx_v_options) {
  int __pyx_v_minQual;
  CYTHON_UNUSED int __pyx_v_minMapQual;
  CYTHON_UNUSED int __pyx_v_largestVariant;
  int __pyx_v_minReads;
  int __pyx_v_assembleBadReads;
  int __pyx_v_assembleBrokenPairs;
  int __pyx_v_kmerSize;
  int __pyx_v_minWeight;
  int __pyx_v_nBuckets;
  int __pyx_v_verbosity;
  PyObject *__pyx_v_theVars = 0;
  __pyx_t_9assembler_DeBruijnGraph *__pyx_v_theGraph;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("assembleReadsAndDetectVariants", 0);

  /* "assembler.pyx":1432
 *     """
 *     """
 *     cdef int minQual = options.minBaseQual             # <<<<<<<<<<<<<<
 *     cdef int minMapQual = options.minMapQual
 *     cdef int largestVariant = options.assemblyRegionSize
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_options, __pyx_n_s_minBaseQual); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_minQual = __pyx_t_2;

  /* "assembler.pyx":1433
 *     """
 *     cdef int minQual = options.minBaseQual
 *     cdef int minMapQual = options.minMapQual             # <<<<<<<<<<<<<<
 *     cdef int largestVariant = options.assemblyRegionSize
 *     cdef int minReads = options.minReads
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_options, __pyx_n_s_minMapQual); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1433; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1433; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_minMapQual = __pyx_t_2;

  /* "assembler.pyx":1434
 *     cdef int minQual = options.minBaseQual
 *     cdef int minMapQual = options.minMapQual
 *     cdef int largestVariant = options.assemblyRegionSize             # <<<<<<<<<<<<<<
 *     cdef int minReads = options.minReads
 *     cdef int assembleBadReads = options.assembleBadReads
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_options, __pyx_n_s_assemblyRegionSize); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_largestVariant = __pyx_t_2;

  /* "assembler.pyx":1435
 *     cdef int minMapQual = options.minMapQual
 *     cdef int largestVariant = options.assemblyRegionSize
 *     cdef int minReads = options.minReads             # <<<<<<<<<<<<<<
 *     cdef int assembleBadReads = options.assembleBadReads
 *     cdef int assembleBrokenPairs = options.assembleBrokenPairs
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_options, __pyx_n_s_minReads); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_minReads = __pyx_t_2;

  /* "assembler.pyx":1436
 *     cdef int largestVariant = options.assemblyRegionSize
 *     cdef int minReads = options.minReads
 *     cdef int assembleBadReads = options.assembleBadReads             # <<<<<<<<<<<<<<
 *     cdef int assembleBrokenPairs = options.assembleBrokenPairs
 *     cdef int kmerSize = options.assemblerKmerSize
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_options, __pyx_n_s_assembleBadReads); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_assembleBadReads = __pyx_t_2;

  /* "assembler.pyx":1437
 *     cdef int minReads = options.minReads
 *     cdef int assembleBadReads = options.assembleBadReads
 *     cdef int assembleBrokenPairs = options.assembleBrokenPairs             # <<<<<<<<<<<<<<
 *     cdef int kmerSize = options.assemblerKmerSize
 *     cdef int minWeight = minReads*minQual
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_options, __pyx_n_s_assembleBrokenPairs); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_assembleBrokenPairs = __pyx_t_2;

  /* "assembler.pyx":1438
 *     cdef int assembleBadReads = options.assembleBadReads
 *     cdef int assembleBrokenPairs = options.assembleBrokenPairs
 *     cdef int kmerSize = options.assemblerKmerSize             # <<<<<<<<<<<<<<
 *     cdef int minWeight = minReads*minQual
 *     cdef int nBuckets = 5000
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_options, __pyx_n_s_assemblerKmerSize); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_kmerSize = __pyx_t_2;

  /* "assembler.pyx":1439
 *     cdef int assembleBrokenPairs = options.assembleBrokenPairs
 *     cdef int kmerSize = options.assemblerKmerSize
 *     cdef int minWeight = minReads*minQual             # <<<<<<<<<<<<<<
 *     cdef int nBuckets = 5000
 *     cdef int verbosity = options.verbosity
 */
  __pyx_v_minWeight = (__pyx_v_minReads * __pyx_v_minQual);

  /* "assembler.pyx":1440
 *     cdef int kmerSize = options.assemblerKmerSize
 *     cdef int minWeight = minReads*minQual
 *     cdef int nBuckets = 5000             # <<<<<<<<<<<<<<
 *     cdef int verbosity = options.verbosity
 *     cdef list theVars = []
 */
  __pyx_v_nBuckets = 5000;

  /* "assembler.pyx":1441
 *     cdef int minWeight = minReads*minQual
 *     cdef int nBuckets = 5000
 *     cdef int verbosity = options.verbosity             # <<<<<<<<<<<<<<
 *     cdef list theVars = []
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_options, __pyx_n_s_verbosity); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_verbosity = __pyx_t_2;

  /* "assembler.pyx":1442
 *     cdef int nBuckets = 5000
 *     cdef int verbosity = options.verbosity
 *     cdef list theVars = []             # <<<<<<<<<<<<<<
 * 
 *     if verbosity >= 3:
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1442; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_theVars = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "assembler.pyx":1444
 *     cdef list theVars = []
 * 
 *     if verbosity >= 3:             # <<<<<<<<<<<<<<
 *         logger.debug("Assembling region %s:%s-%s" %(chrom, assemStart, assemEnd))
 * 
 */
  __pyx_t_3 = ((__pyx_v_verbosity >= 3) != 0);
  if (__pyx_t_3) {

    /* "assembler.pyx":1445
 * 
 *     if verbosity >= 3:
 *         logger.debug("Assembling region %s:%s-%s" %(chrom, assemStart, assemEnd))             # <<<<<<<<<<<<<<
 * 
 *     cdef DeBruijnGraph* theGraph = createDeBruijnGraph(kmerSize, nBuckets)
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_debug); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_chrom); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_assemStart); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_assemEnd); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = PyTuple_New(3); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_7, 2, __pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    __pyx_t_1 = 0;
    __pyx_t_5 = 0;
    __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Assembling_region_s_s_s, __pyx_t_7); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "assembler.pyx":1447
 *         logger.debug("Assembling region %s:%s-%s" %(chrom, assemStart, assemEnd))
 * 
 *     cdef DeBruijnGraph* theGraph = createDeBruijnGraph(kmerSize, nBuckets)             # <<<<<<<<<<<<<<
 * 
 *     loadReferenceIntoGraph(theGraph, refSeq, refStart, kmerSize)
 */
  __pyx_v_theGraph = __pyx_f_9assembler_createDeBruijnGraph(__pyx_v_kmerSize, __pyx_v_nBuckets);

  /* "assembler.pyx":1449
 *     cdef DeBruijnGraph* theGraph = createDeBruijnGraph(kmerSize, nBuckets)
 * 
 *     loadReferenceIntoGraph(theGraph, refSeq, refStart, kmerSize)             # <<<<<<<<<<<<<<
 *     loadBAMDataIntoGraph(theGraph, readBuffers, assembleBadReads, assembleBrokenPairs, minQual, kmerSize)
 * 
 */
  __pyx_f_9assembler_loadReferenceIntoGraph(__pyx_v_theGraph, __pyx_v_refSeq, __pyx_v_refStart, __pyx_v_kmerSize);

  /* "assembler.pyx":1450
 * 
 *     loadReferenceIntoGraph(theGraph, refSeq, refStart, kmerSize)
 *     loadBAMDataIntoGraph(theGraph, readBuffers, assembleBadReads, assembleBrokenPairs, minQual, kmerSize)             # <<<<<<<<<<<<<<
 * 
 *     # If this is true, then don't allow cycles in the graph.
 */
  __pyx_f_9assembler_loadBAMDataIntoGraph(__pyx_v_theGraph, __pyx_v_readBuffers, __pyx_v_assembleBadReads, __pyx_v_assembleBrokenPairs, __pyx_v_minQual, __pyx_v_kmerSize);

  /* "assembler.pyx":1453
 * 
 *     # If this is true, then don't allow cycles in the graph.
 *     if options.noCycles:             # <<<<<<<<<<<<<<
 *         while detectCyclesInGraph_Recursive(theGraph, minWeight):
 *             if kmerSize > 50:
 */
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_options, __pyx_n_s_noCycles); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (__pyx_t_3) {

    /* "assembler.pyx":1454
 *     # If this is true, then don't allow cycles in the graph.
 *     if options.noCycles:
 *         while detectCyclesInGraph_Recursive(theGraph, minWeight):             # <<<<<<<<<<<<<<
 *             if kmerSize > 50:
 *                 if verbosity >= 3:
 */
    while (1) {
      __pyx_t_3 = (__pyx_f_9assembler_detectCyclesInGraph_Recursive(__pyx_v_theGraph, __pyx_v_minWeight) != 0);
      if (!__pyx_t_3) break;

      /* "assembler.pyx":1455
 *     if options.noCycles:
 *         while detectCyclesInGraph_Recursive(theGraph, minWeight):
 *             if kmerSize > 50:             # <<<<<<<<<<<<<<
 *                 if verbosity >= 3:
 *                     logger.debug("Could not assemble region %s:%s-%s without cycles. Max k-mer size tried = %s" %(chrom, assemStart, assemEnd, kmerSize))
 */
      __pyx_t_3 = ((__pyx_v_kmerSize > 50) != 0);
      if (__pyx_t_3) {

        /* "assembler.pyx":1456
 *         while detectCyclesInGraph_Recursive(theGraph, minWeight):
 *             if kmerSize > 50:
 *                 if verbosity >= 3:             # <<<<<<<<<<<<<<
 *                     logger.debug("Could not assemble region %s:%s-%s without cycles. Max k-mer size tried = %s" %(chrom, assemStart, assemEnd, kmerSize))
 *                 break
 */
        __pyx_t_3 = ((__pyx_v_verbosity >= 3) != 0);
        if (__pyx_t_3) {

          /* "assembler.pyx":1457
 *             if kmerSize > 50:
 *                 if verbosity >= 3:
 *                     logger.debug("Could not assemble region %s:%s-%s without cycles. Max k-mer size tried = %s" %(chrom, assemStart, assemEnd, kmerSize))             # <<<<<<<<<<<<<<
 *                 break
 *             else:
 */
          __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_debug); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_7);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_chrom); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_assemStart); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_4);
          __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_assemEnd); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_5);
          __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_kmerSize); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_8 = PyTuple_New(4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_8);
          PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6);
          __Pyx_GIVEREF(__pyx_t_6);
          PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_4);
          __Pyx_GIVEREF(__pyx_t_4);
          PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_5);
          PyTuple_SET_ITEM(__pyx_t_8, 3, __pyx_t_1);
          __Pyx_GIVEREF(__pyx_t_1);
          __pyx_t_6 = 0;
          __pyx_t_4 = 0;
          __pyx_t_5 = 0;
          __pyx_t_1 = 0;
          __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_Could_not_assemble_region_s_s_s, __pyx_t_8); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_8);
          PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_1);
          __Pyx_GIVEREF(__pyx_t_1);
          __pyx_t_1 = 0;
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          goto __pyx_L8;
        }
        __pyx_L8:;

        /* "assembler.pyx":1458
 *                 if verbosity >= 3:
 *                     logger.debug("Could not assemble region %s:%s-%s without cycles. Max k-mer size tried = %s" %(chrom, assemStart, assemEnd, kmerSize))
 *                 break             # <<<<<<<<<<<<<<
 *             else:
 *                 if verbosity >= 3:
 */
        goto __pyx_L6_break;
      }
      /*else*/ {

        /* "assembler.pyx":1460
 *                 break
 *             else:
 *                 if verbosity >= 3:             # <<<<<<<<<<<<<<
 *                     logger.debug("Found cycles in region %s:%s-%s with kmer size %s. Trying again with kmer size %s" %(chrom, assemStart, assemEnd, kmerSize, kmerSize+5))
 * 
 */
        __pyx_t_3 = ((__pyx_v_verbosity >= 3) != 0);
        if (__pyx_t_3) {

          /* "assembler.pyx":1461
 *             else:
 *                 if verbosity >= 3:
 *                     logger.debug("Found cycles in region %s:%s-%s with kmer size %s. Trying again with kmer size %s" %(chrom, assemStart, assemEnd, kmerSize, kmerSize+5))             # <<<<<<<<<<<<<<
 * 
 *                 kmerSize += 5
 */
          __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_logger); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_debug); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_8);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_chrom); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_assemStart); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_7);
          __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_assemEnd); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_5);
          __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_kmerSize); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_4);
          __pyx_t_6 = __Pyx_PyInt_From_long((__pyx_v_kmerSize + 5)); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __pyx_t_9 = PyTuple_New(5); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_9);
          PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_1);
          __Pyx_GIVEREF(__pyx_t_1);
          PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_t_7);
          __Pyx_GIVEREF(__pyx_t_7);
          PyTuple_SET_ITEM(__pyx_t_9, 2, __pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_5);
          PyTuple_SET_ITEM(__pyx_t_9, 3, __pyx_t_4);
          __Pyx_GIVEREF(__pyx_t_4);
          PyTuple_SET_ITEM(__pyx_t_9, 4, __pyx_t_6);
          __Pyx_GIVEREF(__pyx_t_6);
          __pyx_t_1 = 0;
          __pyx_t_7 = 0;
          __pyx_t_5 = 0;
          __pyx_t_4 = 0;
          __pyx_t_6 = 0;
          __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Found_cycles_in_region_s_s_s_wit, __pyx_t_9); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
          __pyx_t_9 = PyTuple_New(1); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_9);
          PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_6);
          __Pyx_GIVEREF(__pyx_t_6);
          __pyx_t_6 = 0;
          __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_9, NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          goto __pyx_L9;
        }
        __pyx_L9:;

        /* "assembler.pyx":1463
 *                     logger.debug("Found cycles in region %s:%s-%s with kmer size %s. Trying again with kmer size %s" %(chrom, assemStart, assemEnd, kmerSize, kmerSize+5))
 * 
 *                 kmerSize += 5             # <<<<<<<<<<<<<<
 *                 destroyDeBruijnGraph(theGraph)
 *                 theGraph = createDeBruijnGraph(kmerSize, nBuckets)
 */
        __pyx_v_kmerSize = (__pyx_v_kmerSize + 5);

        /* "assembler.pyx":1464
 * 
 *                 kmerSize += 5
 *                 destroyDeBruijnGraph(theGraph)             # <<<<<<<<<<<<<<
 *                 theGraph = createDeBruijnGraph(kmerSize, nBuckets)
 *                 loadReferenceIntoGraph(theGraph, refSeq, refStart, kmerSize)
 */
        __pyx_f_9assembler_destroyDeBruijnGraph(__pyx_v_theGraph);

        /* "assembler.pyx":1465
 *                 kmerSize += 5
 *                 destroyDeBruijnGraph(theGraph)
 *                 theGraph = createDeBruijnGraph(kmerSize, nBuckets)             # <<<<<<<<<<<<<<
 *                 loadReferenceIntoGraph(theGraph, refSeq, refStart, kmerSize)
 *                 loadBAMDataIntoGraph(theGraph, readBuffers, assembleBadReads, assembleBrokenPairs, minQual, kmerSize)
 */
        __pyx_v_theGraph = __pyx_f_9assembler_createDeBruijnGraph(__pyx_v_kmerSize, __pyx_v_nBuckets);

        /* "assembler.pyx":1466
 *                 destroyDeBruijnGraph(theGraph)
 *                 theGraph = createDeBruijnGraph(kmerSize, nBuckets)
 *                 loadReferenceIntoGraph(theGraph, refSeq, refStart, kmerSize)             # <<<<<<<<<<<<<<
 *                 loadBAMDataIntoGraph(theGraph, readBuffers, assembleBadReads, assembleBrokenPairs, minQual, kmerSize)
 *         else:
 */
        __pyx_f_9assembler_loadReferenceIntoGraph(__pyx_v_theGraph, __pyx_v_refSeq, __pyx_v_refStart, __pyx_v_kmerSize);

        /* "assembler.pyx":1467
 *                 theGraph = createDeBruijnGraph(kmerSize, nBuckets)
 *                 loadReferenceIntoGraph(theGraph, refSeq, refStart, kmerSize)
 *                 loadBAMDataIntoGraph(theGraph, readBuffers, assembleBadReads, assembleBrokenPairs, minQual, kmerSize)             # <<<<<<<<<<<<<<
 *         else:
 *             theVars = findBubblesInGraph(theGraph, minWeight, refSeq, chrom, refStart, refEnd, assemStart, assemEnd, verbosity)
 */
        __pyx_f_9assembler_loadBAMDataIntoGraph(__pyx_v_theGraph, __pyx_v_readBuffers, __pyx_v_assembleBadReads, __pyx_v_assembleBrokenPairs, __pyx_v_minQual, __pyx_v_kmerSize);
      }
    }

    /* "assembler.pyx":1469
 *                 loadBAMDataIntoGraph(theGraph, readBuffers, assembleBadReads, assembleBrokenPairs, minQual, kmerSize)
 *         else:
 *             theVars = findBubblesInGraph(theGraph, minWeight, refSeq, chrom, refStart, refEnd, assemStart, assemEnd, verbosity)             # <<<<<<<<<<<<<<
 *     else:
 *         theVars = findBubblesInGraph(theGraph, minWeight, refSeq, chrom, refStart, refEnd, assemStart, assemEnd, verbosity)
 */
    /*else*/ {
      __pyx_t_6 = __pyx_f_9assembler_findBubblesInGraph(__pyx_v_theGraph, __pyx_v_minWeight, __pyx_v_refSeq, __pyx_v_chrom, __pyx_v_refStart, __pyx_v_refEnd, __pyx_v_assemStart, __pyx_v_assemEnd, __pyx_v_verbosity); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF_SET(__pyx_v_theVars, ((PyObject*)__pyx_t_6));
      __pyx_t_6 = 0;
    }
    __pyx_L6_break:;
    goto __pyx_L4;
  }
  /*else*/ {

    /* "assembler.pyx":1471
 *             theVars = findBubblesInGraph(theGraph, minWeight, refSeq, chrom, refStart, refEnd, assemStart, assemEnd, verbosity)
 *     else:
 *         theVars = findBubblesInGraph(theGraph, minWeight, refSeq, chrom, refStart, refEnd, assemStart, assemEnd, verbosity)             # <<<<<<<<<<<<<<
 * 
 *     destroyDeBruijnGraph(theGraph)
 */
    __pyx_t_6 = __pyx_f_9assembler_findBubblesInGraph(__pyx_v_theGraph, __pyx_v_minWeight, __pyx_v_refSeq, __pyx_v_chrom, __pyx_v_refStart, __pyx_v_refEnd, __pyx_v_assemStart, __pyx_v_assemEnd, __pyx_v_verbosity); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF_SET(__pyx_v_theVars, ((PyObject*)__pyx_t_6));
    __pyx_t_6 = 0;
  }
  __pyx_L4:;

  /* "assembler.pyx":1473
 *         theVars = findBubblesInGraph(theGraph, minWeight, refSeq, chrom, refStart, refEnd, assemStart, assemEnd, verbosity)
 * 
 *     destroyDeBruijnGraph(theGraph)             # <<<<<<<<<<<<<<
 *     #logger.debug("Finished assembling region %s:%s-%s" %(chrom, start, end))
 *     #logger.debug("Found vars %s" %(theVars))
 */
  __pyx_f_9assembler_destroyDeBruijnGraph(__pyx_v_theGraph);

  /* "assembler.pyx":1476
 *     #logger.debug("Finished assembling region %s:%s-%s" %(chrom, start, end))
 *     #logger.debug("Found vars %s" %(theVars))
 *     return sorted(theVars)             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1476; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_INCREF(__pyx_v_theVars);
  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_theVars);
  __Pyx_GIVEREF(__pyx_v_theVars);
  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_builtin_sorted, __pyx_t_6, NULL); if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1476; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_9);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (!(likely(PyList_CheckExact(__pyx_t_9))||((__pyx_t_9) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "list", Py_TYPE(__pyx_t_9)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1476; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = ((PyObject*)__pyx_t_9);
  __pyx_t_9 = 0;
  goto __pyx_L0;

  /* "assembler.pyx":1429
 * ###################################################################################################
 * 
 * cdef list assembleReadsAndDetectVariants(char* chrom, int assemStart, int assemEnd, int refStart, int refEnd, list readBuffers, char* refSeq, options):             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("assembler.assembleReadsAndDetectVariants", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_theVars);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":300
 * # And here are accessor functions for the bit-fields
 * @cython.profile(False)
 * cdef inline int Read_IsReverse(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FREVERSE) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsReverse(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":301
 * @cython.profile(False)
 * cdef inline int Read_IsReverse(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FREVERSE) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 16) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":300
 * # And here are accessor functions for the bit-fields
 * @cython.profile(False)
 * cdef inline int Read_IsReverse(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FREVERSE) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":304
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsPaired(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FPAIRED) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsPaired(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":305
 * @cython.profile(False)
 * cdef inline int Read_IsPaired(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FPAIRED) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 1) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":304
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsPaired(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FPAIRED) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":308
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsProperPair(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FPROPER_PAIR) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsProperPair(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":309
 * @cython.profile(False)
 * cdef inline int Read_IsProperPair(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FPROPER_PAIR) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 2) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":308
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsProperPair(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FPROPER_PAIR) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":312
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsDuplicate(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FDUP) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsDuplicate(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":313
 * @cython.profile(False)
 * cdef inline int Read_IsDuplicate(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FDUP) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 1024) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":312
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsDuplicate(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FDUP) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":316
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsUnmapped(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FUNMAP) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsUnmapped(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":317
 * @cython.profile(False)
 * cdef inline int Read_IsUnmapped(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FUNMAP) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 4) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":316
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsUnmapped(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FUNMAP) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":320
 * 
 * @cython.profile(False)
 * cdef inline int Read_MateIsUnmapped(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FMUNMAP) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_MateIsUnmapped(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":321
 * @cython.profile(False)
 * cdef inline int Read_MateIsUnmapped(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FMUNMAP) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 8) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":320
 * 
 * @cython.profile(False)
 * cdef inline int Read_MateIsUnmapped(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FMUNMAP) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":324
 * 
 * @cython.profile(False)
 * cdef inline int Read_MateIsReverse(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FMREVERSE) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_MateIsReverse(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":325
 * @cython.profile(False)
 * cdef inline int Read_MateIsReverse(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FMREVERSE) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 32) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":324
 * 
 * @cython.profile(False)
 * cdef inline int Read_MateIsReverse(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FMREVERSE) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":328
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsQCFail(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FQCFAIL) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsQCFail(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":329
 * @cython.profile(False)
 * cdef inline int Read_IsQCFail(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FQCFAIL) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 512) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":328
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsQCFail(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FQCFAIL) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":332
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsReadOne(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FREAD1) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsReadOne(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":333
 * @cython.profile(False)
 * cdef inline int Read_IsReadOne(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FREAD1) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 64) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":332
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsReadOne(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FREAD1) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":336
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsSecondaryAlignment(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FSECONDARY) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsSecondaryAlignment(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":337
 * @cython.profile(False)
 * cdef inline int Read_IsSecondaryAlignment(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FSECONDARY) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 256) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":336
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsSecondaryAlignment(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FSECONDARY) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":340
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsCompressed(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FCOMPRESSED) != 0)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_IsCompressed(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":341
 * @cython.profile(False)
 * cdef inline int Read_IsCompressed(cAlignedRead* theRead) nogil:
 *     return ( (theRead.bitFlag & BAM_FCOMPRESSED) != 0)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_r = ((__pyx_v_theRead->bitFlag & 2048) != 0);
  goto __pyx_L0;

  /* "samtoolsWrapper.pxd":340
 * 
 * @cython.profile(False)
 * cdef inline int Read_IsCompressed(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     return ( (theRead.bitFlag & BAM_FCOMPRESSED) != 0)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":344
 * 
 * @cython.profile(False)
 * cdef inline int Read_SetIsNotReverse(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag &= (~BAM_FREVERSE)
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_SetIsNotReverse(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":345
 * @cython.profile(False)
 * cdef inline int Read_SetIsNotReverse(cAlignedRead* theRead) nogil:
 *     theRead.bitFlag &= (~BAM_FREVERSE)             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_v_theRead->bitFlag = (__pyx_v_theRead->bitFlag & (~16));

  /* "samtoolsWrapper.pxd":344
 * 
 * @cython.profile(False)
 * cdef inline int Read_SetIsNotReverse(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag &= (~BAM_FREVERSE)
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":348
 * 
 * @cython.profile(False)
 * cdef inline int Read_SetIsReverse(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag |= BAM_FREVERSE
 * 
 */

static CYTHON_INLINE int __pyx_f_15samtoolsWrapper_Read_SetIsReverse(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {
  int __pyx_r;

  /* "samtoolsWrapper.pxd":349
 * @cython.profile(False)
 * cdef inline int Read_SetIsReverse(cAlignedRead* theRead) nogil:
 *     theRead.bitFlag |= BAM_FREVERSE             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_v_theRead->bitFlag = (__pyx_v_theRead->bitFlag | 16);

  /* "samtoolsWrapper.pxd":348
 * 
 * @cython.profile(False)
 * cdef inline int Read_SetIsReverse(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag |= BAM_FREVERSE
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  return __pyx_r;
}

/* "samtoolsWrapper.pxd":352
 * 
 * @cython.profile(False)
 * cdef inline void Read_SetQCFail(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag |= BAM_FQCFAIL
 * 
 */

static CYTHON_INLINE void __pyx_f_15samtoolsWrapper_Read_SetQCFail(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {

  /* "samtoolsWrapper.pxd":353
 * @cython.profile(False)
 * cdef inline void Read_SetQCFail(cAlignedRead* theRead) nogil:
 *     theRead.bitFlag |= BAM_FQCFAIL             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_v_theRead->bitFlag = (__pyx_v_theRead->bitFlag | 512);

  /* "samtoolsWrapper.pxd":352
 * 
 * @cython.profile(False)
 * cdef inline void Read_SetQCFail(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag |= BAM_FQCFAIL
 * 
 */

  /* function exit code */
}

/* "samtoolsWrapper.pxd":356
 * 
 * @cython.profile(False)
 * cdef inline void Read_SetCompressed(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag |= BAM_FCOMPRESSED
 * 
 */

static CYTHON_INLINE void __pyx_f_15samtoolsWrapper_Read_SetCompressed(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {

  /* "samtoolsWrapper.pxd":357
 * @cython.profile(False)
 * cdef inline void Read_SetCompressed(cAlignedRead* theRead) nogil:
 *     theRead.bitFlag |= BAM_FCOMPRESSED             # <<<<<<<<<<<<<<
 * 
 * @cython.profile(False)
 */
  __pyx_v_theRead->bitFlag = (__pyx_v_theRead->bitFlag | 2048);

  /* "samtoolsWrapper.pxd":356
 * 
 * @cython.profile(False)
 * cdef inline void Read_SetCompressed(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag |= BAM_FCOMPRESSED
 * 
 */

  /* function exit code */
}

/* "samtoolsWrapper.pxd":360
 * 
 * @cython.profile(False)
 * cdef inline void Read_SetUnCompressed(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag &= (~BAM_FCOMPRESSED)
 * 
 */

static CYTHON_INLINE void __pyx_f_15samtoolsWrapper_Read_SetUnCompressed(__pyx_t_15samtoolsWrapper_cAlignedRead *__pyx_v_theRead) {

  /* "samtoolsWrapper.pxd":361
 * @cython.profile(False)
 * cdef inline void Read_SetUnCompressed(cAlignedRead* theRead) nogil:
 *     theRead.bitFlag &= (~BAM_FCOMPRESSED)             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_v_theRead->bitFlag = (__pyx_v_theRead->bitFlag & (~2048));

  /* "samtoolsWrapper.pxd":360
 * 
 * @cython.profile(False)
 * cdef inline void Read_SetUnCompressed(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag &= (~BAM_FCOMPRESSED)
 * 
 */

  /* function exit code */
}

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    __Pyx_NAMESTR("assembler"),
    __Pyx_DOCSTR(__pyx_k_Cython_module_used_to_interface), /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_Assembling_region_s_s_s, __pyx_k_Assembling_region_s_s_s, sizeof(__pyx_k_Assembling_region_s_s_s), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_allocate_hash_table_bu, __pyx_k_Could_not_allocate_hash_table_bu, sizeof(__pyx_k_Could_not_allocate_hash_table_bu), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_allocate_memory_for_De, __pyx_k_Could_not_allocate_memory_for_De, sizeof(__pyx_k_Could_not_allocate_memory_for_De), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_allocate_memory_for_ch, __pyx_k_Could_not_allocate_memory_for_ch, sizeof(__pyx_k_Could_not_allocate_memory_for_ch), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_allocate_memory_for_st, __pyx_k_Could_not_allocate_memory_for_st, sizeof(__pyx_k_Could_not_allocate_memory_for_st), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_allocate_node, __pyx_k_Could_not_allocate_node, sizeof(__pyx_k_Could_not_allocate_node), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_allocate_path, __pyx_k_Could_not_allocate_path, sizeof(__pyx_k_Could_not_allocate_path), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_assemble_region_s_s_s, __pyx_k_Could_not_assemble_region_s_s_s, sizeof(__pyx_k_Could_not_assemble_region_s_s_s), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_re_allocate_EdgeStack, __pyx_k_Could_not_re_allocate_EdgeStack, sizeof(__pyx_k_Could_not_re_allocate_EdgeStack), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_re_allocate_NodeStack, __pyx_k_Could_not_re_allocate_NodeStack, sizeof(__pyx_k_Could_not_re_allocate_NodeStack), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_re_allocate_PathStack, __pyx_k_Could_not_re_allocate_PathStack, sizeof(__pyx_k_Could_not_re_allocate_PathStack), 0, 0, 1, 0},
  {&__pyx_kp_s_Could_not_re_allocate_bucket, __pyx_k_Could_not_re_allocate_bucket, sizeof(__pyx_k_Could_not_re_allocate_bucket), 0, 0, 1, 0},
  {&__pyx_kp_s_Error_Could_not_NodeDict, __pyx_k_Error_Could_not_NodeDict, sizeof(__pyx_k_Error_Could_not_NodeDict), 0, 0, 1, 0},
  {&__pyx_kp_s_Error_Could_not_NodeDict_bucketS, __pyx_k_Error_Could_not_NodeDict_bucketS, sizeof(__pyx_k_Error_Could_not_NodeDict_bucketS), 0, 0, 1, 0},
  {&__pyx_kp_s_Error_Could_not_NodeDict_buckets, __pyx_k_Error_Could_not_NodeDict_buckets, sizeof(__pyx_k_Error_Could_not_NodeDict_buckets), 0, 0, 1, 0},
  {&__pyx_kp_s_Error_Could_not_allocate_edge, __pyx_k_Error_Could_not_allocate_edge, sizeof(__pyx_k_Error_Could_not_allocate_edge), 0, 0, 1, 0},
  {&__pyx_kp_s_Error_Could_not_allocate_edge_st, __pyx_k_Error_Could_not_allocate_edge_st, sizeof(__pyx_k_Error_Could_not_allocate_edge_st), 0, 0, 1, 0},
  {&__pyx_kp_s_Error_Could_not_allocate_edge_st_2, __pyx_k_Error_Could_not_allocate_edge_st_2, sizeof(__pyx_k_Error_Could_not_allocate_edge_st_2), 0, 0, 1, 0},
  {&__pyx_kp_s_Error_Could_not_allocate_node_st, __pyx_k_Error_Could_not_allocate_node_st, sizeof(__pyx_k_Error_Could_not_allocate_node_st), 0, 0, 1, 0},
  {&__pyx_kp_s_Error_Could_not_allocate_node_st_2, __pyx_k_Error_Could_not_allocate_node_st_2, sizeof(__pyx_k_Error_Could_not_allocate_node_st_2), 0, 0, 1, 0},
  {&__pyx_kp_s_Error_Could_not_allocate_path_st, __pyx_k_Error_Could_not_allocate_path_st, sizeof(__pyx_k_Error_Could_not_allocate_path_st), 0, 0, 1, 0},
  {&__pyx_kp_s_Error_Could_not_allocate_path_st_2, __pyx_k_Error_Could_not_allocate_path_st_2, sizeof(__pyx_k_Error_Could_not_allocate_path_st_2), 0, 0, 1, 0},
  {&__pyx_kp_s_Found_complex_variation_that_Pla, __pyx_k_Found_complex_variation_that_Pla, sizeof(__pyx_k_Found_complex_variation_that_Pla), 0, 0, 1, 0},
  {&__pyx_kp_s_Found_cycles_in_region_s_s_s_wit, __pyx_k_Found_cycles_in_region_s_s_s_wit, sizeof(__pyx_k_Found_cycles_in_region_s_s_s_wit), 0, 0, 1, 0},
  {&__pyx_n_s_Log, __pyx_k_Log, sizeof(__pyx_k_Log), 0, 0, 1, 1},
  {&__pyx_kp_s_Logging_path_of_s_nodes, __pyx_k_Logging_path_of_s_nodes, sizeof(__pyx_k_Logging_path_of_s_nodes), 0, 0, 1, 0},
  {&__pyx_kp_s_Node_struct_cannot_have_4_edges, __pyx_k_Node_struct_cannot_have_4_edges, sizeof(__pyx_k_Node_struct_cannot_have_4_edges), 0, 0, 1, 0},
  {&__pyx_kp_s_Null_Node, __pyx_k_Null_Node, sizeof(__pyx_k_Null_Node), 0, 0, 1, 0},
  {&__pyx_kp_s_Null_path, __pyx_k_Null_path, sizeof(__pyx_k_Null_path), 0, 0, 1, 0},
  {&__pyx_kp_s_Platypus_assembler_found_candida, __pyx_k_Platypus_assembler_found_candida, sizeof(__pyx_k_Platypus_assembler_found_candida), 0, 0, 1, 0},
  {&__pyx_kp_s_Pos_s_Seq_s_RefSeq_c_Colours_s_N, __pyx_k_Pos_s_Seq_s_RefSeq_c_Colours_s_N, sizeof(__pyx_k_Pos_s_Seq_s_RefSeq_c_Colours_s_N), 0, 0, 1, 0},
  {&__pyx_n_s_StandardError, __pyx_k_StandardError, sizeof(__pyx_k_StandardError), 0, 0, 1, 1},
  {&__pyx_n_s_assembleBadReads, __pyx_k_assembleBadReads, sizeof(__pyx_k_assembleBadReads), 0, 0, 1, 1},
  {&__pyx_n_s_assembleBrokenPairs, __pyx_k_assembleBrokenPairs, sizeof(__pyx_k_assembleBrokenPairs), 0, 0, 1, 1},
  {&__pyx_n_s_assemblerKmerSize, __pyx_k_assemblerKmerSize, sizeof(__pyx_k_assemblerKmerSize), 0, 0, 1, 1},
  {&__pyx_n_s_assemblyRegionSize, __pyx_k_assemblyRegionSize, sizeof(__pyx_k_assemblyRegionSize), 0, 0, 1, 1},
  {&__pyx_n_s_collections, __pyx_k_collections, sizeof(__pyx_k_collections), 0, 0, 1, 1},
  {&__pyx_n_s_debug, __pyx_k_debug, sizeof(__pyx_k_debug), 0, 0, 1, 1},
  {&__pyx_n_s_defaultdict, __pyx_k_defaultdict, sizeof(__pyx_k_defaultdict), 0, 0, 1, 1},
  {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
  {&__pyx_n_s_getLogger, __pyx_k_getLogger, sizeof(__pyx_k_getLogger), 0, 0, 1, 1},
  {&__pyx_n_s_heapq, __pyx_k_heapq, sizeof(__pyx_k_heapq), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_info, __pyx_k_info, sizeof(__pyx_k_info), 0, 0, 1, 1},
  {&__pyx_n_s_logger, __pyx_k_logger, sizeof(__pyx_k_logger), 0, 0, 1, 1},
  {&__pyx_n_s_logging, __pyx_k_logging, sizeof(__pyx_k_logging), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_minBaseQual, __pyx_k_minBaseQual, sizeof(__pyx_k_minBaseQual), 0, 0, 1, 1},
  {&__pyx_n_s_minMapQual, __pyx_k_minMapQual, sizeof(__pyx_k_minMapQual), 0, 0, 1, 1},
  {&__pyx_n_s_minReads, __pyx_k_minReads, sizeof(__pyx_k_minReads), 0, 0, 1, 1},
  {&__pyx_kp_s_nNodes_s_nFilledBuckets_s_mean_e, __pyx_k_nNodes_s_nFilledBuckets_s_mean_e, sizeof(__pyx_k_nNodes_s_nFilledBuckets_s_mean_e), 0, 0, 1, 0},
  {&__pyx_n_s_noCycles, __pyx_k_noCycles, sizeof(__pyx_k_noCycles), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
  {&__pyx_n_s_sorted, __pyx_k_sorted, sizeof(__pyx_k_sorted), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_verbosity, __pyx_k_verbosity, sizeof(__pyx_k_verbosity), 0, 0, 1, 1},
  {&__pyx_n_s_warning, __pyx_k_warning, sizeof(__pyx_k_warning), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_StandardError = __Pyx_GetBuiltinName(__pyx_n_s_StandardError); if (!__pyx_builtin_StandardError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 595; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_sorted = __Pyx_GetBuiltinName(__pyx_n_s_sorted); if (!__pyx_builtin_sorted) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1476; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "assembler.pyx":135
 * 
 *     if thePath == NULL:
 *         logger.error("Could not allocate path")             # <<<<<<<<<<<<<<
 * 
 *     thePath.nodes = createNodeStack(initialSize)
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_Could_not_allocate_path); if (unlikely(!__pyx_tuple_)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "assembler.pyx":162
 *     """
 *     if thePath == NULL:
 *         logger.error("Null path")             # <<<<<<<<<<<<<<
 * 
 *     if theNode == NULL:
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_Null_path); if (unlikely(!__pyx_tuple__2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "assembler.pyx":165
 * 
 *     if theNode == NULL:
 *         logger.error("Null Node")             # <<<<<<<<<<<<<<
 * 
 *     NodeStack_Push(thePath.nodes, theNode)
 */
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_Null_Node); if (unlikely(!__pyx_tuple__3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "assembler.pyx":180
 * 
 *     if theNode == NULL:
 *         logger.error("Could not allocate node")             # <<<<<<<<<<<<<<
 * 
 *     # Need to allocate kmerSize + 1 to store the null terminating character
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_Could_not_allocate_node); if (unlikely(!__pyx_tuple__4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "assembler.pyx":369
 * 
 *         if temp == NULL:
 *             logger.error("Could not re-allocate PathStack")             # <<<<<<<<<<<<<<
 *         else:
 *             theStack.elements = temp
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_Could_not_re_allocate_PathStack); if (unlikely(!__pyx_tuple__5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "assembler.pyx":462
 * 
 *         if temp == NULL:
 *             logger.error("Could not re-allocate NodeStack")             # <<<<<<<<<<<<<<
 *         else:
 *             theStack.elements = temp
 */
  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_Could_not_re_allocate_NodeStack); if (unlikely(!__pyx_tuple__6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__6);
  __Pyx_GIVEREF(__pyx_tuple__6);

  /* "assembler.pyx":508
 * 
 *     if theEdge == NULL:
 *         logger.error("Error. Could not allocate edge")             # <<<<<<<<<<<<<<
 * 
 *     theEdge.startNode = startNode
 */
  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_Error_Could_not_allocate_edge); if (unlikely(!__pyx_tuple__7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__7);
  __Pyx_GIVEREF(__pyx_tuple__7);

  /* "assembler.pyx":627
 * 
 *     if theDict == NULL:
 *         logger.error("Error. Could not NodeDict")             # <<<<<<<<<<<<<<
 * 
 *     theDict.buckets = <Node***>(malloc(nBuckets*sizeof(Node**)))
 */
  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_Error_Could_not_NodeDict); if (unlikely(!__pyx_tuple__8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);

  /* "assembler.pyx":750
 * 
 *     if theGraph == NULL:
 *         logger.error("Could not allocate memory for DeBruijnGraph")             # <<<<<<<<<<<<<<
 * 
 *     theGraph.kmerSize = kmerSize
 */
  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_Could_not_allocate_memory_for_De); if (unlikely(!__pyx_tuple__9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 750; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__9);
  __Pyx_GIVEREF(__pyx_tuple__9);

  /* "assembler.pyx":26
 * from variant cimport Variant,ASSEMBLER_VAR
 * 
 * logger = logging.getLogger("Log")             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_n_s_Log); if (unlikely(!__pyx_tuple__10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__10);
  __Pyx_GIVEREF(__pyx_tuple__10);
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_int_100 = PyInt_FromLong(100); if (unlikely(!__pyx_int_100)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initassembler(void); /*proto*/
PyMODINIT_FUNC initassembler(void)
#else
PyMODINIT_FUNC PyInit_assembler(void); /*proto*/
PyMODINIT_FUNC PyInit_assembler(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_assembler(void)", 0);
  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #ifdef __Pyx_CyFunction_USED
  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("assembler"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_Cython_module_used_to_interface), 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  /*--- Initialize various global constants etc. ---*/
  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  if (__pyx_module_is_main_assembler) {
    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (!PyDict_GetItemString(modules, "assembler")) {
      if (unlikely(PyDict_SetItemString(modules, "assembler", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Constants init code ---*/
  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  if (__Pyx_ExportFunction("assembleReadsAndDetectVariants", (void (*)(void))__pyx_f_9assembler_assembleReadsAndDetectVariants, "PyObject *(char *, int, int, int, int, PyObject *, char *, PyObject *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Type init code ---*/
  /*--- Type import code ---*/
  __pyx_ptype_15samtoolsWrapper_Samfile = __Pyx_ImportType("samtoolsWrapper", "Samfile", sizeof(struct __pyx_obj_15samtoolsWrapper_Samfile), 1); if (unlikely(!__pyx_ptype_15samtoolsWrapper_Samfile)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_vtabptr_15samtoolsWrapper_Samfile = (struct __pyx_vtabstruct_15samtoolsWrapper_Samfile*)__Pyx_GetVtable(__pyx_ptype_15samtoolsWrapper_Samfile->tp_dict); if (unlikely(!__pyx_vtabptr_15samtoolsWrapper_Samfile)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_15samtoolsWrapper_IteratorRow = __Pyx_ImportType("samtoolsWrapper", "IteratorRow", sizeof(struct __pyx_obj_15samtoolsWrapper_IteratorRow), 1); if (unlikely(!__pyx_ptype_15samtoolsWrapper_IteratorRow)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_vtabptr_15samtoolsWrapper_IteratorRow = (struct __pyx_vtabstruct_15samtoolsWrapper_IteratorRow*)__Pyx_GetVtable(__pyx_ptype_15samtoolsWrapper_IteratorRow->tp_dict); if (unlikely(!__pyx_vtabptr_15samtoolsWrapper_IteratorRow)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9fastafile_FastaIndex = __Pyx_ImportType("fastafile", "FastaIndex", sizeof(struct __pyx_obj_9fastafile_FastaIndex), 1); if (unlikely(!__pyx_ptype_9fastafile_FastaIndex)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_vtabptr_9fastafile_FastaIndex = (struct __pyx_vtabstruct_9fastafile_FastaIndex*)__Pyx_GetVtable(__pyx_ptype_9fastafile_FastaIndex->tp_dict); if (unlikely(!__pyx_vtabptr_9fastafile_FastaIndex)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_9fastafile_FastaFile = __Pyx_ImportType("fastafile", "FastaFile", sizeof(struct __pyx_obj_9fastafile_FastaFile), 1); if (unlikely(!__pyx_ptype_9fastafile_FastaFile)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 5; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_vtabptr_9fastafile_FastaFile = (struct __pyx_vtabstruct_9fastafile_FastaFile*)__Pyx_GetVtable(__pyx_ptype_9fastafile_FastaFile->tp_dict); if (unlikely(!__pyx_vtabptr_9fastafile_FastaFile)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 5; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7cwindow_ReadArray = __Pyx_ImportType("cwindow", "ReadArray", sizeof(struct __pyx_obj_7cwindow_ReadArray), 1); if (unlikely(!__pyx_ptype_7cwindow_ReadArray)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 13; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_vtabptr_7cwindow_ReadArray = (struct __pyx_vtabstruct_7cwindow_ReadArray*)__Pyx_GetVtable(__pyx_ptype_7cwindow_ReadArray->tp_dict); if (unlikely(!__pyx_vtabptr_7cwindow_ReadArray)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 13; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7cwindow_bamReadBuffer = __Pyx_ImportType("cwindow", "bamReadBuffer", sizeof(struct __pyx_obj_7cwindow_bamReadBuffer), 1); if (unlikely(!__pyx_ptype_7cwindow_bamReadBuffer)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 29; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_vtabptr_7cwindow_bamReadBuffer = (struct __pyx_vtabstruct_7cwindow_bamReadBuffer*)__Pyx_GetVtable(__pyx_ptype_7cwindow_bamReadBuffer->tp_dict); if (unlikely(!__pyx_vtabptr_7cwindow_bamReadBuffer)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 29; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7variant_Variant = __Pyx_ImportType("variant", "Variant", sizeof(struct __pyx_obj_7variant_Variant), 1); if (unlikely(!__pyx_ptype_7variant_Variant)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_vtabptr_7variant_Variant = (struct __pyx_vtabstruct_7variant_Variant*)__Pyx_GetVtable(__pyx_ptype_7variant_Variant->tp_dict); if (unlikely(!__pyx_vtabptr_7variant_Variant)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7variant_VariantCandidateGenerator = __Pyx_ImportType("variant", "VariantCandidateGenerator", sizeof(struct __pyx_obj_7variant_VariantCandidateGenerator), 1); if (unlikely(!__pyx_ptype_7variant_VariantCandidateGenerator)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 45; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_vtabptr_7variant_VariantCandidateGenerator = (struct __pyx_vtabstruct_7variant_VariantCandidateGenerator*)__Pyx_GetVtable(__pyx_ptype_7variant_VariantCandidateGenerator->tp_dict); if (unlikely(!__pyx_vtabptr_7variant_VariantCandidateGenerator)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 45; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Variable import code ---*/
  __pyx_t_1 = __Pyx_ImportModule("variant"); if (!__pyx_t_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ImportVoidPtr(__pyx_t_1, "PLATYPUS_VAR", (void **)&__pyx_vp_7variant_PLATYPUS_VAR, "int") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ImportVoidPtr(__pyx_t_1, "FILE_VAR", (void **)&__pyx_vp_7variant_FILE_VAR, "int") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ImportVoidPtr(__pyx_t_1, "ASSEMBLER_VAR", (void **)&__pyx_vp_7variant_ASSEMBLER_VAR, "int") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  Py_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "assembler.pyx":8
 * 
 * cimport cython
 * import logging             # <<<<<<<<<<<<<<
 * import heapq
 * from collections import defaultdict
 */
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_logging, 0, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_logging, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "assembler.pyx":9
 * cimport cython
 * import logging
 * import heapq             # <<<<<<<<<<<<<<
 * from collections import defaultdict
 * 
 */
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_heapq, 0, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_heapq, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "assembler.pyx":10
 * import logging
 * import heapq
 * from collections import defaultdict             # <<<<<<<<<<<<<<
 * 
 * from samtoolsWrapper cimport cAlignedRead
 */
  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_s_defaultdict);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_defaultdict);
  __Pyx_GIVEREF(__pyx_n_s_defaultdict);
  __pyx_t_3 = __Pyx_Import(__pyx_n_s_collections, __pyx_t_2, -1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_defaultdict); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_defaultdict, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "assembler.pyx":26
 * from variant cimport Variant,ASSEMBLER_VAR
 * 
 * logger = logging.getLogger("Log")             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_logging); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_getLogger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_logger, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "assembler.pyx":30
 * ###################################################################################################
 * 
 * cdef int REF = 1             # <<<<<<<<<<<<<<
 * cdef int READ = 2
 * cdef int REF_AND_READ = 3
 */
  __pyx_v_9assembler_REF = 1;

  /* "assembler.pyx":31
 * 
 * cdef int REF = 1
 * cdef int READ = 2             # <<<<<<<<<<<<<<
 * cdef int REF_AND_READ = 3
 * 
 */
  __pyx_v_9assembler_READ = 2;

  /* "assembler.pyx":32
 * cdef int REF = 1
 * cdef int READ = 2
 * cdef int REF_AND_READ = 3             # <<<<<<<<<<<<<<
 * 
 * ###################################################################################################
 */
  __pyx_v_9assembler_REF_AND_READ = 3;

  /* "assembler.pyx":1
 * """             # <<<<<<<<<<<<<<
 * Cython module used to interface to assembler routines.
 * """
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "samtoolsWrapper.pxd":360
 * 
 * @cython.profile(False)
 * cdef inline void Read_SetUnCompressed(cAlignedRead* theRead) nogil:             # <<<<<<<<<<<<<<
 *     theRead.bitFlag &= (~BAM_FCOMPRESSED)
 * 
 */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  if (__pyx_m) {
    __Pyx_AddTraceback("init assembler", __pyx_clineno, __pyx_lineno, __pyx_filename);
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init assembler");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* Runtime support code */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif /* CYTHON_REFNANNY */

static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if CYTHON_COMPILING_IN_CPYTHON
    result = PyDict_GetItem(__pyx_d, name);
    if (result) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
#if PY_VERSION_HEX >= 0x02060000
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
#endif
    result = (*call)(func, arg, kw);
#if PY_VERSION_HEX >= 0x02060000
    Py_LeaveRecursiveCall();
#endif
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_Restore(type, value, tb);
#endif
}
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(type, value, tb);
#endif
}

static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                  int full_traceback) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
    if (full_traceback) {
        Py_XINCREF(old_exc);
        Py_XINCREF(old_val);
        Py_XINCREF(old_tb);
        __Pyx_ErrRestore(old_exc, old_val, old_tb);
        PyErr_PrintEx(1);
    }
    #if PY_MAJOR_VERSION < 3
    ctx = PyString_FromString(name);
    #else
    ctx = PyUnicode_FromString(name);
    #endif
    __Pyx_ErrRestore(old_exc, old_val, old_tb);
    if (!ctx) {
        PyErr_WriteUnraisable(Py_None);
    } else {
        PyErr_WriteUnraisable(ctx);
        Py_DECREF(ctx);
    }
}

#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    #if PY_VERSION_HEX < 0x02050000
    if (PyClass_Check(type)) {
    #else
    if (PyType_Check(type)) {
    #endif
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        #if PY_VERSION_HEX < 0x02050000
        if (PyInstance_Check(type)) {
            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
            Py_INCREF(type);
        } else {
            type = 0;
            PyErr_SetString(PyExc_TypeError,
                "raise: exception must be an old-style class or instance");
            goto raise_error;
        }
        #else
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
        #endif
    }
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else /* Python 3+ */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                if (PyObject_IsSubclass(instance_class, type)) {
                    type = instance_class;
                } else {
                    instance_class = NULL;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
#if PY_VERSION_HEX >= 0x03030000
    if (cause) {
#else
    if (cause && cause != Py_None) {
#endif
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (wraparound & unlikely(i < 0)) i += PyList_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
        PyObject *r = PyList_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (wraparound & unlikely(i < 0)) i += PyTuple_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
        PyObject *r = PyTuple_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
            PyObject *r = PyList_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    }
    else if (PyTuple_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (PyErr_ExceptionMatches(PyExc_OverflowError))
                        PyErr_Clear();
                    else
                        return NULL;
                }
            }
            return m->sq_item(o, i);
        }
    }
#else
    if (is_list || PySequence_Check(o)) {
        return PySequence_GetItem(o, i);
    }
#endif
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
}

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(PyObject_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

static void* __Pyx_GetVtable(PyObject *dict) {
    void* ptr;
    PyObject *ob = PyObject_GetItem(dict, __pyx_n_s_pyx_vtable);
    if (!ob)
        goto bad;
#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
    ptr = PyCapsule_GetPointer(ob, 0);
#else
    ptr = PyCObject_AsVoidPtr(ob);
#endif
    if (!ptr && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
    Py_DECREF(ob);
    return ptr;
bad:
    Py_XDECREF(ob);
    return NULL;
}

static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Format(PyExc_ImportError,
        #if PY_MAJOR_VERSION < 3
            "cannot import name %.230s", PyString_AS_STRING(name));
        #else
            "cannot import name %S", name);
        #endif
    }
    return value;
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    #if PY_VERSION_HEX >= 0x02050000
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0; /* try absolute import on failure */
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
    #else
    if (level>0) {
        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
        goto bad;
    }
    module = PyObject_CallFunctionObjArgs(py_import,
        name, global_dict, empty_dict, list, NULL);
    #endif
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
    const int neg_one = (int) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(int) <= sizeof(unsigned long long)) {
            return PyLong_FromUnsignedLongLong((unsigned long long) value);
        }
    } else {
        if (sizeof(int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(long long)) {
            return PyLong_FromLongLong((long long) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int),
                                     little, !is_unsigned);
    }
}

#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func)             \
    {                                                                     \
        func_type value = func(x);                                        \
        if (sizeof(target_type) < sizeof(func_type)) {                    \
            if (unlikely(value != (func_type) (target_type) value)) {     \
                func_type zero = 0;                                       \
                PyErr_SetString(PyExc_OverflowError,                      \
                    (is_unsigned && unlikely(value < zero)) ?             \
                    "can't convert negative value to " #target_type :     \
                    "value too large to convert to " #target_type);       \
                return (target_type) -1;                                  \
            }                                                             \
        }                                                                 \
        return (target_type) value;                                       \
    }

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
 #endif
#endif
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG)
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to int");
                return (int) -1;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(int)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return (int) ((PyLongObject*)x)->ob_digit[0];
                }
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to int");
                return (int) -1;
            }
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(int, unsigned long, PyLong_AsUnsignedLong)
            } else if (sizeof(int) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(int, unsigned long long, PyLong_AsUnsignedLongLong)
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(int)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return +(int) ((PyLongObject*)x)->ob_digit[0];
                    case -1: return -(int) ((PyLongObject*)x)->ob_digit[0];
                }
            }
 #endif
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(int, long, PyLong_AsLong)
            } else if (sizeof(int) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(int, long long, PyLong_AsLongLong)
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(long) <= sizeof(unsigned long long)) {
            return PyLong_FromUnsignedLongLong((unsigned long long) value);
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(long long)) {
            return PyLong_FromLongLong((long long) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_char(char value) {
    const char neg_one = (char) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(char) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(char) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(char) <= sizeof(unsigned long long)) {
            return PyLong_FromUnsignedLongLong((unsigned long long) value);
        }
    } else {
        if (sizeof(char) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(char) <= sizeof(long long)) {
            return PyLong_FromLongLong((long long) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(char),
                                     little, !is_unsigned);
    }
}

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
 #endif
#endif
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG)
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to long");
                return (long) -1;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(long)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
                }
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to long");
                return (long) -1;
            }
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(long, unsigned long, PyLong_AsUnsignedLong)
            } else if (sizeof(long) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(long, unsigned long long, PyLong_AsUnsignedLongLong)
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(long)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
                }
            }
 #endif
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(long, long, PyLong_AsLong)
            } else if (sizeof(long) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(long, long long, PyLong_AsLongLong)
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        #if PY_VERSION_HEX < 0x02050000
        return PyErr_Warn(NULL, message);
        #else
        return PyErr_WarnEx(NULL, message, 1);
        #endif
    }
    return 0;
}

static int __Pyx_ExportFunction(const char *name, void (*f)(void), const char *sig) {
    PyObject *d = 0;
    PyObject *cobj = 0;
    union {
        void (*fp)(void);
        void *p;
    } tmp;
    d = PyObject_GetAttrString(__pyx_m, (char *)"__pyx_capi__");
    if (!d) {
        PyErr_Clear();
        d = PyDict_New();
        if (!d)
            goto bad;
        Py_INCREF(d);
        if (PyModule_AddObject(__pyx_m, (char *)"__pyx_capi__", d) < 0)
            goto bad;
    }
    tmp.fp = f;
#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
    cobj = PyCapsule_New(tmp.p, sig, 0);
#else
    cobj = PyCObject_FromVoidPtrAndDesc(tmp.p, (void *)sig, 0);
#endif
    if (!cobj)
        goto bad;
    if (PyDict_SetItemString(d, name, cobj) < 0)
        goto bad;
    Py_DECREF(cobj);
    Py_DECREF(d);
    return 0;
bad:
    Py_XDECREF(cobj);
    Py_XDECREF(d);
    return -1;
}

#ifndef __PYX_HAVE_RT_ImportModule
#define __PYX_HAVE_RT_ImportModule
static PyObject *__Pyx_ImportModule(const char *name) {
    PyObject *py_name = 0;
    PyObject *py_module = 0;
    py_name = __Pyx_PyIdentifier_FromString(name);
    if (!py_name)
        goto bad;
    py_module = PyImport_Import(py_name);
    Py_DECREF(py_name);
    return py_module;
bad:
    Py_XDECREF(py_name);
    return 0;
}
#endif

#ifndef __PYX_HAVE_RT_ImportType
#define __PYX_HAVE_RT_ImportType
static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
    size_t size, int strict)
{
    PyObject *py_module = 0;
    PyObject *result = 0;
    PyObject *py_name = 0;
    char warning[200];
    Py_ssize_t basicsize;
#ifdef Py_LIMITED_API
    PyObject *py_basicsize;
#endif
    py_module = __Pyx_ImportModule(module_name);
    if (!py_module)
        goto bad;
    py_name = __Pyx_PyIdentifier_FromString(class_name);
    if (!py_name)
        goto bad;
    result = PyObject_GetAttr(py_module, py_name);
    Py_DECREF(py_name);
    py_name = 0;
    Py_DECREF(py_module);
    py_module = 0;
    if (!result)
        goto bad;
    if (!PyType_Check(result)) {
        PyErr_Format(PyExc_TypeError,
            "%.200s.%.200s is not a type object",
            module_name, class_name);
        goto bad;
    }
#ifndef Py_LIMITED_API
    basicsize = ((PyTypeObject *)result)->tp_basicsize;
#else
    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
    if (!py_basicsize)
        goto bad;
    basicsize = PyLong_AsSsize_t(py_basicsize);
    Py_DECREF(py_basicsize);
    py_basicsize = 0;
    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
        goto bad;
#endif
    if (!strict && (size_t)basicsize > size) {
        PyOS_snprintf(warning, sizeof(warning),
            "%s.%s size changed, may indicate binary incompatibility",
            module_name, class_name);
        #if PY_VERSION_HEX < 0x02050000
        if (PyErr_Warn(NULL, warning) < 0) goto bad;
        #else
        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
        #endif
    }
    else if ((size_t)basicsize != size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s has the wrong size, try recompiling",
            module_name, class_name);
        goto bad;
    }
    return (PyTypeObject *)result;
bad:
    Py_XDECREF(py_module);
    Py_XDECREF(result);
    return NULL;
}
#endif

#ifndef __PYX_HAVE_RT_ImportVoidPtr
#define __PYX_HAVE_RT_ImportVoidPtr
static int __Pyx_ImportVoidPtr(PyObject *module, const char *name, void **p, const char *sig) {
    PyObject *d = 0;
    PyObject *cobj = 0;
    d = PyObject_GetAttrString(module, (char *)"__pyx_capi__");
    if (!d)
        goto bad;
    cobj = PyDict_GetItemString(d, name);
    if (!cobj) {
        PyErr_Format(PyExc_ImportError,
            "%.200s does not export expected C variable %.200s",
                PyModule_GetName(module), name);
        goto bad;
    }
#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3 && PY_MINOR_VERSION==0)
    if (!PyCapsule_IsValid(cobj, sig)) {
        PyErr_Format(PyExc_TypeError,
            "C variable %.200s.%.200s has wrong signature (expected %.500s, got %.500s)",
             PyModule_GetName(module), name, sig, PyCapsule_GetName(cobj));
        goto bad;
    }
    *p = PyCapsule_GetPointer(cobj, sig);
#else
    {const char *desc, *s1, *s2;
    desc = (const char *)PyCObject_GetDesc(cobj);
    if (!desc)
        goto bad;
    s1 = desc; s2 = sig;
    while (*s1 != '\0' && *s1 == *s2) { s1++; s2++; }
    if (*s1 != *s2) {
        PyErr_Format(PyExc_TypeError,
            "C variable %.200s.%.200s has wrong signature (expected %.500s, got %.500s)",
             PyModule_GetName(module), name, sig, desc);
        goto bad;
    }
    *p = PyCObject_AsVoidPtr(cobj);}
#endif
    if (!(*p))
        goto bad;
    Py_DECREF(d);
    return 0;
bad:
    Py_XDECREF(d);
    return -1;
}
#endif

static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = (start + end) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,            /*int argcount,*/
        0,            /*int kwonlyargcount,*/
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,      /*int firstlineno,*/
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_globals = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = py_line;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else  /* Python 3+ has unicode identifiers */
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
}
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
#if PY_VERSION_HEX < 0x03030000
        char* defenc_c;
        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
        if (!defenc) return NULL;
        defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        {
            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
            char* c;
            for (c = defenc_c; c < end; c++) {
                if ((unsigned char) (*c) >= 128) {
                    PyUnicode_AsASCIIString(o);
                    return NULL;
                }
            }
        }
#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
        *length = PyBytes_GET_SIZE(defenc);
        return defenc_c;
#else /* PY_VERSION_HEX < 0x03030000 */
        if (PyUnicode_READY(o) == -1) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        if (PyUnicode_IS_ASCII(o)) {
            *length = PyUnicode_GET_DATA_SIZE(o);
            return PyUnicode_AsUTF8(o);
        } else {
            PyUnicode_AsASCIIString(o);
            return NULL;
        }
#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
        return PyUnicode_AsUTF8AndSize(o, length);
#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
#endif /* PY_VERSION_HEX < 0x03030000 */
    } else
#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
#if !CYTHON_COMPILING_IN_PYPY
#if PY_VERSION_HEX >= 0x02060000
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return Py_INCREF(x), x;
  m = Py_TYPE(x)->tp_as_number;
#if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_MAJOR_VERSION < 3
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%.4s__ returned non-%.4s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
 #endif
#endif
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b)))
      return PyInt_AS_LONG(b);
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
     #if CYTHON_USE_PYLONG_INTERNALS
       switch (Py_SIZE(b)) {
       case -1: return -(sdigit)((PyLongObject*)b)->ob_digit[0];
       case  0: return 0;
       case  1: return ((PyLongObject*)b)->ob_digit[0];
       }
     #endif
    #endif
  #if PY_VERSION_HEX < 0x02060000
    return PyInt_AsSsize_t(b);
  #else
    return PyLong_AsSsize_t(b);
  #endif
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
#if PY_VERSION_HEX < 0x02050000
   if (ival <= LONG_MAX)
       return PyInt_FromLong((long)ival);
   else {
       unsigned char *bytes = (unsigned char *) &ival;
       int one = 1; int little = (int)*(unsigned char*)&one;
       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
   }
#else
   return PyInt_FromSize_t(ival);
#endif
}


#endif /* Py_PYTHON_H */
